- en: 10 End-to-end encryption
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 端到端加密
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: End-to-end encryption and its importance
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端加密及其重要性
- en: Different attempts at solving email encryption
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决电子邮件加密的不同尝试
- en: How end-to-end encryption is changing the landscape of messaging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端加密如何改变消息传递的格局
- en: 'Chapter 9 explained transport security via protocols like TLS and Noise. At
    the same time, I spent quite some time explaining where trust is rooted on the
    web: hundreds of certificate authorities (CAs) trusted by your browser and operating
    system. While not perfect, this system has worked so far for the web, which is
    a complex network of participants who know nothing of each other.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第 9 章解释了通过诸如 TLS 和 Noise 等协议的传输安全。同时，我花了相当多的时间解释了信任在网络上的根基：由您的浏览器和操作系统信任的数百个证书颁发机构（CA）。虽然并不完美，但这个系统迄今为止在
    Web 上运作良好，Web 是一个复杂的参与者网络，他们彼此一无所知。
- en: This problem of finding ways to trust others (and their public keys) and making
    it scale is at the center of real-world cryptography. A famous cryptographer was
    once heard saying, “Symmetric crypto is solved,” to describe a field of research
    that had overstayed its welcome. And, for the most part, the statement was true.
    We seldom have issues encrypting communications, and we have strong confidence
    in the current encryption algorithms we use. When it comes to encryption, most
    engineering challenges are not about the algorithms themselves anymore, but about
    who Alice and Bob are and how to prove it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 找到信任他人（及其公钥）并使其规模化的方法是现实世界密码学的核心问题。一位著名的密码学家曾经说过，“对称加密问题已经解决了”，以描述一门已经过时的研究领域。而且，在很大程度上，这种说法是正确的。我们很少遇到加密通信的问题，我们对当前使用的加密算法有很强的信心。在加密方面，大多数工程挑战不再是关于算法本身，而是关于谁是
    Alice 和 Bob 以及如何证明它的问题。
- en: Cryptography does not provide one solution to trust but many different ones
    that are more or less practical, depending on the context. In this chapter, I
    will survey some of the different techniques that people and applications use
    to create trust between users.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学没有提供对信任的一个解决方案，而是提供了许多不同的解决方案，这些解决方案更或者更少地依赖于上下文。在本章中，我将调查人们和应用程序用于创建用户之间信任的一些不同技术。
- en: 10.1 Why end-to-end encryption?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 为什么端到端加密？
- en: 'This chapter starts with a “why” instead of a “what.” This is because end-to-end
    encryption is a concept more than a cryptographic protocol; it’s a concept of
    securing communications between two (or more) participants across an adversarial
    path. I started this book with a simple example: Queen Alice wanted to send a
    message to Lord Bob without anyone in the middle being able to see it. Nowadays,
    many applications like email and messaging exist to connect users, and most of
    them seldom encrypt messages from soup to nuts.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以“为什么”而不是“什么”开始。这是因为端到端加密是一个概念而不是一个密码协议；它是一个在敌对路径上保护两个（或更多）参与者之间通信的概念。我在这本书中以一个简单的例子开始：女王
    Alice 想要向爵士 Bob 发送一条消息，而中间没有任何人能够看到。如今，许多应用程序如电子邮件和消息传递存在以连接用户的方式，并且大多数情况下很少对消息进行端到端加密。
- en: 'You might ask, isn’t TLS enough? In theory, it could be. You learned in chapter
    9 that TLS is used in many places to secure communications. But end-to-end encryption
    is a concept that involves actual human beings. In contrast, TLS is most often
    used by systems that are “men-in-the-middle” by design (see figure 10.1). In these
    systems, TLS is only used to protect the communications between a central server
    and its users, allowing the server to see everything. Effectively, these MITM
    servers sit in between users, are necessary for the application to function, and
    are *trusted third parties* of the protocol. That is to say, we have to trust
    these parts of the system in order for the protocol to be considered secure (spoiler
    alert: that’s not a great protocol).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，TLS 不够吗？在理论上，它可能足够。在第 9 章中，你了解到 TLS 被用于许多地方来保护通信。但端到端加密是涉及实际人类的概念。相比之下，TLS
    大多被设计为“中间人”，在这些系统中，TLS 仅用于保护中央服务器与其用户之间的通信，允许服务器看到一切。实际上，这些 MITM 服务器位于用户之间，对应用程序的功能是必要的，并且是协议的*受信任的第三方*。也就是说，为了使协议被视为安全（剧透警告：这不是一个很好的协议），我们必须信任系统的这些部分。
- en: '![](../Images/10_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_01.jpg)'
- en: Figure 10.1 In most systems, a central server (top diagram) relays messages
    between users. A secure connection is usually established between a user and the
    central server, which can thus see all user messages. A protocol providing end-to-end
    encryption (bottom diagram) encrypts communications from one user up to its intended
    recipient, preventing any server in the middle from observing messages in cleartext.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 在大多数系统中，一个中央服务器（顶部图表）在用户之间传递消息。通常在用户和中央服务器之间建立安全连接，因此中央服务器可以看到所有用户消息。提供端到端加密的协议（底部图表）将通信从一个用户加密到其预期接收者，防止中间任何服务器观察明文消息。
- en: 'In practice, much worse topologies exist. Communications between a user and
    a server can go through many network hops, and some of these hops might be machines
    that look at the traffic (often referred to as *middleboxes*). Even if traffic
    is encrypted, some middleboxes are set up to end the TLS connection (we say that
    they *terminate TLS*) and either forward the traffic in clear from that point
    on or start another TLS connection with the next hop. TLS termination is sometimes
    done for “good” reasons: to better filter traffic, balance connections geographically
    or within a data center, and so on. This adds to the attack surface as traffic
    is now visible in the clear in more places. Sometimes, TLS termination is done
    for “bad” reasons: to intercept, record, and spy on traffic.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，存在更糟糕的拓扑结构。用户和服务器之间的通信可能经过许多网络跳点，其中一些跳点可能是查看流量的机器（通常称为*中间盒*）。即使流量被加密，有些中间盒被设置为终止TLS连接（我们称之为*终止TLS*），然后要么从那一点开始明文转发流量，要么与下一个跳点建立另一个TLS连接。有时终止TLS是出于“好”的原因：为了更好地过滤流量，地理上或数据中心内部平衡连接等。这增加了攻击面，因为流量现在在更多地方以明文形式可见。有时，终止TLS是出于“坏”的原因：为了拦截、记录和监视流量。
- en: In 2015, Lenovo was caught selling laptops with pre-installed custom CAs (covered
    in chapter 9) and software. The software was MITM’ing HTTPS connections using
    Lenovo’s CAs and injecting ads into web pages. More concerning, large countries
    like China and Russia have been caught redirecting traffic on the internet, making
    it pass through their networks in order to intercept and observe connections.
    In 2013, Edward Snowden leaked a massive number of documents from NSA showing
    the abuses of many governments (not just the US) in spying on people’s communications
    by intercepting the internet cables that link the world together.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，联想被发现销售预装有自定义CA（在第9章中介绍）和软件的笔记本电脑。该软件使用联想的CA进行HTTPS连接的中间人攻击，并向网页注入广告。更令人担忧的是，像中国和俄罗斯这样的大国被发现在互联网上重定向流量，使其经过他们的网络以拦截和观察连接。2013年，爱德华·斯诺登泄露了来自NSA的大量文件，显示了许多政府（不仅仅是美国）在通过拦截连接世界的互联网电缆来监视人们通信方面的滥用行为。
- en: Owning and seeing user data is also a liability for companies. As I’ve mentioned
    many times in this book, breaches and hacks happen way too often and can be devastating
    for the credibility of a company. From a legal standpoint, laws like the General
    Data Protection Regulation (GDPR) can end up costing organizations a lot of money.
    Government requests like the infamous National Security Letters (NSLs) that sometimes
    prevent companies and people involved from even mentioning that they have received
    the letters (so-called gag orders) can be seen as additional cost and stress to
    an organization, too, unless you have nothing much to share.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有和查看用户数据对公司也是一种责任。正如我在本书中多次提到的那样，数据泄震和黑客攻击发生得太频繁，可能对公司的信誉造成毁灭性打击。从法律角度来看，像《通用数据保护条例》（GDPR）这样的法律可能会让组织付出巨额代价。政府要求，比如臭名昭著的国家安全信函（NSLs），有时会阻止公司和相关人员甚至提及他们收到了信函（所谓的禁言令），这也可以被视为对组织的额外成本和压力，除非你没有太多可以分享的内容。
- en: Bottom line, if you’re using a popular online application, chances are that
    one or more governments already have access or have the ability to gain access
    to everything you wrote or uploaded there. Depending on an application’s *threat
    model* (what the application wants to protect against) or the threat model of
    an application’s most vulnerable users, end-to-end encryption plays a major role
    in ensuring confidentiality and privacy of end users.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，如果你正在使用一个流行的在线应用程序，很可能一个或多个政府已经可以访问或有能力访问你在那里写下或上传的所有内容。根据应用程序的*威胁模型*（应用程序想要防范的威胁）或应用程序最容易受到攻击的用户的威胁模型，端到端加密在确保最终用户的机密性和隐私方面发挥着重要作用。
- en: This chapter covers different techniques and protocols that have been created
    in order to create trust between people. In particular, you will learn about how
    email encryption works today and how secure messaging is changing the landscape
    of end-to-end encrypted communications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了为建立人与人之间的信任而创建的不同技术和协议。特别是，你将了解当今电子邮件加密的工作原理以及安全消息传递如何改变端到端加密通信的格局。
- en: 10.2 A root of trust nowhere to be found
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 无处可寻的信任根源
- en: 'One of the simplest scenarios for end-to-end encryption is the following: Alice
    wants to send an encrypted file to Bob over the internet. With all the cryptographic
    algorithms you learned about in the first chapters of this book, you can probably
    think of a way to do this. For example'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的端到端加密场景之一是：Alice想要通过互联网向Bob发送加密文件。通过本书前几章学到的所有加密算法，你可能可以想到一种方法来实现这一点。例如
- en: Bob sends his public key to Alice.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob向Alice发送他的公钥。
- en: Alice encrypts the file with Bob’s public key and sends it to Bob.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice用Bob的公钥加密文件并发送给Bob。
- en: Perhaps Alice and Bob can meet in real life or use another secure channel they
    already share to exchange the public key in the first message. If this is possible,
    we say that they have an *out-of-band* way of creating trust. This is not always
    the case, though. You can imagine me including my own public key in this book
    and asking you to use it to send me an encrypted message at some email address.
    Who says my copyeditor did not replace the public key with hers?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或许Alice和Bob可以在现实生活中见面，或者使用他们已经共享的另一个安全渠道来在第一条消息中交换公钥。如果这是可能的，我们称他们有一种*out-of-band*的方式来建立信任。然而，并非总是如此。你可以想象我在这本书中包含了我的公钥，并要求你使用它向我发送加密消息到某个电子邮件地址。谁说我的编辑没有用她的公钥替换我的公钥呢？
- en: 'Same for Alice: how does she figure out if the public key she received truly
    is Bob’s public key? It’s possible that someone in the middle could have tampered
    with the first message. As you will see in this chapter, cryptography has no real
    answer to this issue of trust. Instead, it provides different solutions to help
    in different scenarios. The reason why there is no true solution is that we are
    trying to bridge reality (real human beings) with a theoretical cryptographic
    protocol.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Alice也是一样：她如何确定她收到的公钥是否真的是Bob的公钥？中间某人可能篡改了第一条消息。正如你将在本章中看到的，密码学对于这个信任问题没有真正的答案。相反，它提供了不同的解决方案来帮助不同的情况。没有真正解决方案的原因是我们试图将现实（真实的人类）与理论的加密协议联系起来。
- en: '*This whole business of protecting public keys from tampering is the single
    most difficult problem in practical public key applications. It is the ‘Achilles
    heel’ of public key cryptography, and a lot of software complexity is tied up
    in solving this one problem*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*保护公钥免受篡改的整个过程是实际公钥应用中最困难的问题。这是公钥密码学的“阿喀琉斯之踵”，许多软件复杂性都与解决这一问题有关*。'
- en: '—Zimmermann et al. (“PGP User’s Guide Volume I: Essential Topics,” 1992)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: —Zimmermann等人（“PGP用户指南第一卷：基本主题”，1992）
- en: Going back to our simple setup where Alice wants to send a file to Bob, and
    assuming that their untrusted connection is all they have, they have somewhat
    of an impossible trust issue at hand. Alice has no good way of knowing for sure
    what truly is Bob’s public key. It’s a chicken-and-egg type of scenario. Yet,
    let me point out that if no malicious *active* MITM attacker replaces Bob’s public
    key in the first message, then the protocol is safe. Even if the messages are
    being passively recorded, it is too late for an attacker to come after the fact
    to decrypt the second message.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们简单的设置，Alice想要向Bob发送文件，并假设他们不受信任的连接是他们唯一拥有的，他们面临着一种几乎不可能解决的信任问题。Alice没有好的方法确切地知道什么才是Bob的真正公钥。这是一种鸡生蛋蛋生鸡的情况。然而，让我指出，如果没有恶意的*主动*中间人攻击者在第一条消息中替换了Bob的公钥，那么协议是安全的。即使消息被被动记录，攻击者也来不及事后解密第二条消息。
- en: Of course, relying on the fact that your chances of being actively MITM’d are
    *not too high* is not the best way to undertake cryptography. We, unfortunately,
    often do not have a way to avoid this. For example, Google Chrome ships with a
    set of certificate authorities (CAs) that it chooses to trust, but how did you
    obtain Chrome in the first place? Perhaps you used the default browser of your
    operating system, which relies on its own set of CAs. But where did that come
    from? From the laptop you bought. But where did this laptop come from? As you
    can quickly see, it’s “turtles all the way down.” At some point, you will have
    to trust that something was done right.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，依赖于你被主动中间人攻击的机会*不太高*并不是进行密码学的最佳方式。不幸的是，我们通常无法避免这种情况。例如，Google Chrome 预装了一组证书颁发机构（CA），它选择信任这些机构，但你最初是如何获取
    Chrome 的呢？也许你使用了操作系统的默认浏览器，它依赖于自己的一组 CA。但这些又是从哪里来的呢？从你购买的笔记本电脑。但这台笔记本电脑又是从哪里来的呢？很快你就会发现，这是“无穷的乌龟”。在某个时刻，你将不得不相信某件事是正确的。
- en: A threat model typically chooses to stop addressing issues after a specific
    turtle and considers that any turtle further down is out-of-scope. This is why
    the rest of the chapter will assume that you have a secure way to obtain some
    *root of trust*. All systems based on cryptography work by relying on a root of
    trust, something that a protocol can build security on top of. A root of trust
    can be a secret or a public value that we start the protocol with or an out-of-band
    channel that we can use to obtain them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁模型通常选择在特定的层次停止解决问题，并认为任何更深层次的问题都不在范围之内。这就是为什么本章的其余部分将假设你有一种安全的方式来获取一些*信任根源*。所有基于密码学的系统都依赖于一个信任根源，一个协议可以在其上构建安全性的东西。信任根源可以是一个我们用来启动协议的秘密或公共值，或者是一个我们可以用来获取它们的带外信道。
- en: 10.3 The failure of encrypted email
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 加密电子邮件的失败
- en: Email was created as (and is still today) an *unencrypted* protocol. We can
    only blame a time where security was second thought. Email encryption started
    to become more than just an idea after the release of a tool called *Pretty Good
    Privacy* (PGP) in 1991\. At the time, the creator of PGP, Phil Zimmermann, decided
    to release PGP in reaction to a bill that almost became law earlier in the same
    year. The bill would have allowed the US government to obtain all voice and text
    communications from any electronic communication company and manufacturer. In
    his 1994 essay “Why Do You Need PGP?”, Philip Zimmermann ends with “PGP empowers
    people to take their privacy into their own hands. There’s a growing social need
    for it. That’s why I wrote it.”
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件被创建为（今天仍然是）一个*未加密*的协议。我们只能责怪一个安全性是次要考虑的时代。电子邮件加密开始变得不再只是一个想法，是在1991年发布了一个名为*Pretty
    Good Privacy*（PGP）的工具之后。当时，PGP 的创造者 Phil Zimmermann 决定在同一年早些时候几乎成为法律的一项法案发布 PGP。该法案允许美国政府从任何电子通信公司和制造商获取所有语音和文本通信。在他1994年的文章“为什么你需要
    PGP？”中，Philip Zimmermann 结束时说：“PGP 让人们能够掌握自己的隐私。这是一个日益增长的社会需求。这就是为什么我写了它。”
- en: The protocol was finally standardized in RFC 2440 as *OpenPGP* in 1998 and caught
    traction with the release of the open source implementation, *GNU Privacy Guard*
    (GPG), around the same time. Today, GPG is still the main implementation, and
    people interchangeably use the terms GPG and PGP to pretty much mean the same
    thing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议最终在1998年的 RFC 2440 中标准化为*OpenPGP*，并随着开源实现*GNU Privacy Guard*（GPG）的发布而受到关注。今天，GPG
    仍然是主要的实现，人们可以互换使用术语 GPG 和 PGP 来几乎表示相同的意思。
- en: 10.3.1 PGP or GPG? And how does it work?
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 PGP 还是 GPG？它是如何工作的？
- en: 'PGP, or OpenPGP, works by simply making use of hybrid encryption (covered in
    chapter 6). The details are in RFC 4880, the last version of OpenPGP, and can
    be simplified to the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PGP，或者 OpenPGP，通过简单地使用混合加密（在第6章中介绍）来工作。详细信息在 RFC 4880 中，这是 OpenPGP 的最新版本，可以简化为以下步骤：
- en: The sender creates an email. At this point the email’s content is compressed
    before it is encrypted.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发件人创建一封电子邮件。在加密之前，电子邮件的内容会被压缩。
- en: The OpenPGP implementation generates a random symmetric key and symmetrically
    encrypts the email using the symmetric key.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenPGP 实现生成一个随机对称密钥，并使用该对称密钥对电子邮件进行对称加密。
- en: The symmetric key is asymmetrically encrypted to each recipient’s public key
    (using the techniques you learned in chapter 6).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称密钥被非对称加密到每个接收者的公钥上（使用你在第6章学到的技术）。
- en: All of the intended recipients’ encrypted versions of the symmetric key are
    concatenated with the encrypted message. The email body is replaced with this
    blob of data and sent to all recipients.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有预期收件人的加密版本的对称密钥都与加密消息连接在一起。电子邮件正文被替换为此数据块并发送给所有收件人。
- en: To decrypt an email, a recipient uses their private key to decrypt the symmetric
    key, then decrypts the content of the email using the decrypted symmetric key.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解密电子邮件，收件人使用他们的私钥解密对称密钥，然后使用解密后的对称密钥解密电子邮件的内容。
- en: Note that OpenPGP also defines how an email can be signed in order to authenticate
    the sender. To do this, the plaintext email’s body is hashed and then signed using
    the sender’s private key. The signature is then added to the message before being
    encrypted in step 2\. Finally, so that the recipient can figure out what public
    key to use to verify the signature, the sender’s public key is sent along the
    encrypted email in step 4\. I illustrate the PGP flow in figure 10.2.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，OpenPGP 还定义了如何签署电子邮件以验证发件人的方法。为此，明文电子邮件的主体被散列，然后使用发件人的私钥进行签名。在第 2 步加密之前，签名然后被添加到消息中。最后，为了使接收者能够找出要用于验证签名的公钥，发件人的公钥在第
    4 步加密电子邮件中发送。我在图 10.2 中说明了 PGP 流程。
- en: '![](../Images/10_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_02.jpg)'
- en: Figure 10.2 PGP’s goal is to encrypt and sign messages. When integrated with
    email clients it does not care about hiding the subject or other metadata.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 PGP 的目标是加密和签署消息。当与电子邮件客户端集成时，它不关心隐藏主题或其他元数据。
- en: Exercise
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Do you know why the email’s content is compressed before it is encrypted and
    not after?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道为什么电子邮件内容在加密之前被压缩而不是之后吗？
- en: There’s nothing inherently wrong with this design at first sight. It seems to
    prevent MITM attackers from seeing your email’s content, although the subject
    and other email headers are not encrypted.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这种设计本质上没有问题。它似乎防止中间人攻击者查看您的电子邮件内容，尽管主题和其他电子邮件标题未加密。
- en: Note It is important to note that cryptography cannot always hide all metadata.
    In privacy-conscious applications, metadata is a big problem and can, in the worst
    cases, de-anonymize you! For example, in end-to-end encrypted protocols, you might
    not be able to decrypt messages between users, but you can probably tell what
    their IP addresses are, what the length of the messages they send and receive
    is, who they commonly talk to (their social graphs), and so on. A lot of engineering
    is put into hiding this type of metadata.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：重要的是要注意，加密并不总是能够隐藏所有元数据。在注重隐私的应用程序中，元数据是一个大问题，而且在最糟糕的情况下，可以对您进行去匿名化！例如，在端到端加密协议中，您可能无法解密用户之间的消息，但您可能可以知道他们的
    IP 地址、他们发送和接收的消息的长度、他们通常与谁交谈（他们的社交图谱）等信息。有很多工程工作被投入到隐藏这种类型的元数据中。
- en: Yet, in the details, PGP is actually quite bad. The OpenPGP standard and its
    main implementation, GPG, make use of old algorithms, and backward compatibility
    prevents them from improving the situation. The most critical issue is that encryption
    is not authenticated, which means that anyone intercepting an email that hasn’t
    been signed might be able to tamper with the encrypted content to some degree,
    depending on the exact encryption algorithm used. For this reason alone, I would
    not recommend anyone to use PGP today.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在细节方面，PGP 实际上相当糟糕。OpenPGP 标准及其主要实现 GPG 使用了老算法，并且向后兼容性阻碍了它们改善情况。最关键的问题是加密没有经过身份验证，这意味着拦截未签名的电子邮件的任何人可能能够在一定程度上篡改加密内容，具体取决于所使用的确切加密算法。仅因为这个原因，我不建议任何人今天使用
    PGP。
- en: A surprising flaw of PGP comes from the fact that the signing and encryption
    operations are composed without care. In 2001, Don Davis pointed out that because
    of this naive composition of cryptographic algorithms, one can re-encrypt a signed
    email they received and send that to another recipient. This effectively allows
    Bob to send you the email Alice sent him as if you were the intended recipient!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: PGP 的一个令人惊讶的缺陷源于签名和加密操作的不合理组合。在 2001 年，唐·戴维斯指出，由于这种加密算法的天真组合，一个人可以重新加密他们收到的已签名电子邮件，并将其发送给另一个收件人。这实际上允许
    Bob 将 Alice 发送给他的电子邮件发送给你，就好像你是预期的收件人一样！
- en: If you’re wondering, signing the ciphertext instead of the plaintext is still
    flawed as one could then simply remove the signature that comes with the ciphertext
    and add their own signature instead. In effect, Bob could pretend that he sent
    you an email that was actually coming from Alice. I recapitulate these two signing
    issues in figure 10.3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道，用密文而不是明文签名仍然有缺陷，因为然后可以简单地删除随密文一起发送的签名，然后添加自己的签名。实际上，Bob可以假装他发送给你一封实际上来自Alice的电子邮件。我在图10.3中总结了这两个签名问题。
- en: '![](../Images/10_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_03.jpg)'
- en: Figure 10.3 In the top diagram, Alice encrypts a message and signature over
    the message with Bob’s public key. Bob can re-encrypt this message to Charles,
    who might believe that it was intended for him to begin with. This is the PGP
    flow. In the bottom diagram, this time Alice encrypts a message to Charles. She
    also signs the encrypted message instead of the plaintext content. Bob, who intercepts
    the encrypted message, can replace the signature with his own, fooling Charles
    into thinking that he wrote the content of the message.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 在顶部图中，Alice使用Bob的公钥对消息进行加密，并对消息进行签名。Bob可以重新加密此消息给Charles，Charles可能认为最初就是为他准备的。这是PGP的流程。在底部图中，这次Alice向Charles加密了一条消息。她还对加密消息进行了签名，而不是明文内容。截获加密消息的Bob可以用自己的签名替换签名，愚弄Charles以为他写了消息的内容。
- en: Exercise
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Can you think of an unambiguous way of signing a message?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一种明确的签名消息的方式吗？
- en: The icing on the cake is that the algorithm does not provide *forward secrecy*
    by default. As a reminder, without forward secrecy, a compromise of your private
    key implies that all previous emails sent to you encrypted under that key can
    now be decrypted. You can still force forward secrecy by changing your PGP key,
    but this process is not straightforward (you can, for example, sign your new key
    with your older key) and most users just don’t bother. To recap, remember that
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 雪上加霜的是，默认情况下该算法不提供*前向保密性*。作为提醒，没有前向保密性，你的私钥被泄露意味着可以解密以该密钥加密的所有先前发送给你的电子邮件。你仍然可以通过更改你的PGP密钥来强制前向保密性，但这个过程并不简单（你可以，例如，用你的旧密钥签署你的新密钥），大多数用户并不在意。总之，记住
- en: PGP uses old cryptographic algorithms.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PGP使用旧的加密算法。
- en: PGP does not have authenticated encryption and is, thus, not secure if used
    without signatures.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PGP没有经过身份验证的加密，因此，如果没有签名，它是不安全的。
- en: Due to bad design, receiving a signed message doesn’t necessarily mean we were
    the intended recipient.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于设计不良，收到签名消息并不一定意味着我们是预期的接收者。
- en: There is no forward secrecy by default.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下没有前向保密性。
- en: 10.3.2 Scaling trust between users with the web of trust
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 在用户之间使用信任网络进行信任扩展
- en: 'So why am I really talking about PGP here? Well, there is something interesting
    about PGP that I haven’t talked about yet: how do you obtain and how can you trust
    other people’s public keys? The answer is that in PGP, you build trust yourself!'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我为什么在这里谈论PGP呢？好吧，PGP有件有趣的事情我还没谈到：你如何获取并信任其他人的公钥？答案是在PGP中，你自己建立信任！
- en: 'OK, what does that mean? Imagine that you install GPG and decide that you want
    to encrypt some messages to your friends. To start, you must first find a secure
    way to obtain your friends’ PGP public keys. Meeting them in real life is one
    sure way to do this. You meet, you copy their public keys on a piece of paper,
    and then you type those keys back into your laptop at home. Now, you can send
    your friends signed and encrypted messages with OpenPGP. But this is tedious.
    Do you have to do this for every person you want to email? Of course not. Let’s
    take the following scenario:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这意味着什么？想象一下，你安装了GPG，并决定想给你的朋友发送一些加密消息。首先，你必须找到一种安全的方式获取你朋友的PGP公钥。面对面见面是一种确保这样做的方法。你们见面了，你抄写下他们的公钥在一张纸上，然后你回到家里将那些密钥输入你的笔记本电脑。现在，你可以用OpenPGP发送给你的朋友签名和加密的消息了。但这很繁琐。你必须为每个你想发送电子邮件的人都这样做吗？当然不是。让我们看看以下情景：
- en: You have obtained Bob’s public key in real life and, thus, you trust it.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经在现实生活中获得了Bob的公钥，因此你信任它。
- en: You do not have Mark’s public key, but Bob does and he trusts it.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你没有Mark的公钥，但Bob有，并且他信任它。
- en: Take a moment here to think about what you could be doing to trust Mark’s public
    key. Bob can simply sign Mark’s key, showing you that he trusts the association
    between the public key and Mark’s email. If you trust Bob, you can now trust Mark’s
    public key and add it to your repertoire. This is the main idea behind PGP’s concept
    of *decentralized* trust. It is called the *web of trust* (WOT) as figure 10.4
    illustrates.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里花一点时间思考一下如何信任马克的公钥。鲍勃可以简单地签署马克的密钥，向你展示他信任公钥与马克的电子邮件之间的关联。如果你信任鲍勃，现在你就可以信任马克的公钥并将其添加到你的资源库中。这就是PGP概念中
    *分散式* 信任的主要思想。正如图10.4所示，这被称为 *信任网络*（WOT）。
- en: '![](../Images/10_04.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_04.jpg)'
- en: Figure 10.4 The web of trust (WOT) is the concept that users can transitively
    trust other users by relying on signatures. In this figure, we can see that Alice
    trusts Bob who trusts Charles. Alice can use Bob’s signature over Charles’s identity
    and public key to trust Charles as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 信任网络（WOT）是指用户可以通过依赖签名来转移信任给其他用户的概念。在这个图中，我们可以看到爱丽丝信任鲍勃，鲍勃信任查理。爱丽丝可以使用鲍勃对查理身份和公钥的签名来信任查理。
- en: You will sometimes see “key parties” at conferences, where people meet in real
    life and sign their respective public keys. But most of that is role-playing,
    and, in practice, few people rely on the WOT to enlarge their PGP circle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会在会议上看到“密钥派对”，人们在现实生活中相遇并签署各自的公钥。但其中大部分都是角色扮演，在实践中，很少有人依赖WOT来扩大他们的PGP圈子。
- en: 10.3.3 Key discovery is a real issue
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 密钥发现是一个真实的问题
- en: 'PGP did try another way to solve the issue of discovering public keys—*key
    registries*. The concept is pretty simple: publish your PGP public key and associated
    signatures from others that attest to your identity on some public list so that
    people can find it. In practice, this doesn’t work as anyone can publish a key
    and associated signature purportedly matching your email. In fact, some attackers
    intentionally spoofed keys on key servers, although possibly more to cause havoc
    than to spy on emails. In some settings, we can relax our threat model and allow
    for a trusted authority to attest to identities and public keys. Think of a company
    managing their employees’ emails, for example.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: PGP确实尝试了另一种解决发现公钥问题的方法—— *密钥注册表*。这个概念非常简单：在某个公共列表上发布你的PGP公钥和其他人为你的身份作证的关联签名，以便人们可以找到它。在实践中，这并不奏效，因为任何人都可以发布一个与你的电子邮件相匹配的密钥和关联签名。事实上，一些攻击者故意在密钥服务器上伪造密钥，尽管可能更多是为了制造混乱而不是窃听电子邮件。在某些情况下，我们可以放宽我们的威胁模型，允许一个可信任的权威对身份和公钥进行证明。例如，想象一家公司管理他们员工的电子邮件。
- en: In 1995, the RSA company proposed *Secure/Multipurpose Internet Mail Extensions*
    (S/MIME) as an extension to the MIME format (which itself is an extension to the
    email standard) and as an alternative to PGP. S/MIME, standardized in RFC 5751,
    took an interesting departure from the WOT by using a public key infrastructure
    to build trust. That is pretty much the only conceptual difference that S/MIME
    has with PGP. As companies have processes in place to onboard and offboard employees,
    it makes sense for them to start using protocols like S/MIME in order to bootstrap
    trust in their internal email ecosystem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，RSA公司提出了作为MIME格式的扩展（MIME本身是电子邮件标准的扩展）和PGP的一种替代方案的 *安全/多用途互联网邮件扩展*（S/MIME）。S/MIME，标准化在RFC
    5751中，通过使用公钥基础设施来构建信任，与WOT有了有趣的区别。这几乎是S/MIME与PGP唯一的概念性区别。随着公司建立起了适用于员工的流程，开始使用诸如S/MIME之类的协议来启动对内部电子邮件生态系统的信任也就有了意义。
- en: It is important to note that both PGP and S/MIME are generally used over the
    *Simple Mail Transfer Protocol* (SMTP), which is the protocol used today for sending
    and receiving emails. PGP and S/MIME were also invented later, and for this reason,
    their integration with SMTP and email clients is far from perfect. For example,
    only the body of an email is encrypted not the subject or any of the other email
    headers. S/MIME, like PGP, is also quite an old protocol that uses outdated cryptography
    and practices. Like PGP, it does not offer authenticated encryption.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，PGP和S/MIME通常用于 *简单邮件传输协议*（SMTP），这是今天用于发送和接收电子邮件的协议。PGP和S/MIME也是后来才被发明出来的，因此它们与SMTP和电子邮件客户端的集成远非完美。例如，只有电子邮件的正文是加密的，而不是主题或任何其他电子邮件头部信息。与PGP类似，S/MIME也是一个相当古老的协议，使用过时的加密和做法。与PGP类似，它也不提供身份验证加密。
- en: 'Recent research (Efail: “Breaking S/MIME and OpenPGP Email Encryption using
    Exfiltration Channels”) on the integration of both protocols in email clients
    showed that most of them were vulnerable to *exfiltration attacks*, where an attacker
    who observes encrypted emails can retrieve the content by sending tampered versions
    to the recipients.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的研究（Efail：“利用渗透通道破解 S/MIME 和 OpenPGP 电子邮件加密”）关于在电子邮件客户端中集成这两种协议显示，大多数客户端都容易受到*渗透攻击*的影响，攻击者可以通过发送篡改版本的加密邮件给接收者来检索内容。
- en: In the end, these shortcomings might not even matter, as most emails being sent
    and received in the world move along the global network unencrypted. PGP has proven
    to be quite difficult to use for nontechnical, as well as advanced, users who
    are required to understand the many subtleties and flows of PGP in order to encrypt
    their emails. For example, it’s not uncommon to see users responding to an encrypted
    email without using encryption, quoting the whole thread in cleartext. On top
    of that, the poor (or nonexistent) support for PGP by popular email clients hasn’t
    helped.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这些缺点甚至可能无关紧要，因为世界上发送和接收的大多数电子邮件都在全球网络上未加密传输。对于非技术人员以及需要理解 PGP 的许多微妙之处和流程才能加密他们的电子邮件的高级用户来说，PGP
    使用起来相当困难。例如，经常会看到用户在不使用加密的情况下回复加密邮件，以明文引用整个线程。此外，流行电子邮件客户端对 PGP 的支持（或根本没有支持）也没有帮助。
- en: '*In the 1990s, I was excited about the future, and I dreamed of a world where
    everyone would install GPG. Now I’m still excited about the future, but I dream
    of a world where I can uninstall it*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 1990 年代，我对未来感到兴奋，梦想着一个每个人都会安装 GPG 的世界。现在，我仍然对未来感到兴奋，但我梦想着一个我可以卸载它的世界*。'
- en: —Moxie Marlinspike (“GPG and Me,” 2015)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: —Moxie Marlinspike（“GPG 和我”，2015）
- en: For these reasons, PGP has slowly been losing support (for example, Golang removed
    support for PGP from its standard library in 2019), while more and more real-world
    cryptography applications are aiming at replacing PGP and solving its usability
    problems. Today, it is hard to argue that email encryption will ever have the
    same level of success and adoption that, for example, HTTPS has.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，PGP 已经逐渐失去了支持（例如，Golang 在 2019 年从其标准库中移除了对 PGP 的支持），而越来越多的真实世界的加密应用程序正致力于取代
    PGP 并解决其可用性问题。如今，很难争辩电子邮件加密会像 HTTPS 那样取得相同的成功和普及。
- en: '*If messages can be sent in plaintext, they will be sent in plaintext. Email
    is end-to-end unencrypted by default. The foundations of electronic mail are plaintext.
    All mainstream email software expects plaintext. In meaningful ways, the Internet
    email system is simply designed not to be encrypted*.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果消息可以以明文发送，它们就会以明文发送。电子邮件默认是端到端未加密的。电子邮件的基础是明文。所有主流电子邮件软件都期望明文。在某种意义上，互联网电子邮件系统简单地设计成不加密*。'
- en: —Thomas Ptacek (“Stop Using Encrypted Email,” 2020)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: —Thomas Ptacek（“停止使用加密电子邮件”，2020）
- en: 10.3.4 If not PGP, then what?
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 如果不是 PGP，那又是什么呢？
- en: I spent several pages talking about how a simple design like PGP can fail in
    a lot of different and surprising ways in practice. Yes, I would recommend against
    using PGP. While email encryption is still an unsolved problem, alternatives are
    being developed to replace different PGP use cases.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了几页的篇幅讨论了像 PGP 这样简单的设计在实践中可能以许多不同和令人惊讶的方式失败。是的，我建议不要使用 PGP。虽然电子邮件加密仍然是一个未解决的问题，但正在开发替代方案来取代不同的
    PGP 使用情况。
- en: '*saltpack* is a similar protocol and message format to PGP. It attempts to
    fix some of the PGP flaws I’ve talked about. In 2021, saltpack’s main implementations
    are keybase ([https://keybase.io](https://keybase.io)) and keys.pub ([https://keys.pub](https://keys.pub)).
    Figure 10.5 illustrates the keys.pub tool.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*saltpack* 是一种类似于 PGP 的协议和消息格式。它试图修复我所谈到的一些 PGP 的缺陷。在 2021 年，saltpack 的主要实现是
    keybase（[https://keybase.io](https://keybase.io)）和 keys.pub（[https://keys.pub](https://keys.pub)）。图
    10.5 展示了 keys.pub 工具。'
- en: '![](../Images/10_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_05.jpg)'
- en: Figure 10.5 keys.pub is a native desktop application that implements the saltpack
    protocol. You can use it to import other people’s public keys and to encrypt and
    sign messages to them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 keys.pub 是一个实现 saltpack 协议的本地桌面应用程序。您可以使用它导入其他人的公钥，并向他们加密和签名消息。
- en: These implementations have all moved away from WOT and allow users to broadcast
    their public keys on different social networks in order to instill their identity
    into their public keys (as figure 10.6 illustrates). PGP could obviously not have
    anticipated this key discovery mechanism as it predates the boom of social networks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现都已经摆脱了信任路径（WOT），允许用户在不同的社交网络上广播他们的公钥，以将他们的身份融入到他们的公钥中（如图10.6所示）。PGP 显然无法预见到这种密钥发现机制，因为它早于社交网络的蓬勃发展。
- en: '![](../Images/10_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_06.jpg)'
- en: Figure 10.6 A keybase user broadcasting their public key on the Twitter social
    network. This allows other users to obtain additional proof that his identity
    is linked to a specific public key.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 一个 keybase 用户在 Twitter 社交网络上广播他们的公钥。这使得其他用户可以获得额外的证据，证明他的身份与特定的公钥相关联。
- en: On the other hand, most secure communication nowadays is far from a one-time
    message, and the use of these tools is less and less relevant. In the next section,
    I talk about *secure messaging*, one of the fields that aims to replace the communication
    aspect of PGP.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如今大多数安全通信远非一次性消息，使用这些工具的意义越来越不明显。在下一节中，我将讨论*安全通信*，这是一个旨在取代 PGP 通信方面的领域。
- en: '10.4 Secure messaging: A modern look at end-to-end encryption with Signal'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 安全通信：使用 Signal 进行端到端加密的现代视角
- en: In 2004, *Off-The-Record* (OTR*)* was introduced in a white paper titled “Off-the-Record
    Communication, or, Why Not To Use PGP.” Unlike PGP or S/MIME, OTR is not used
    to encrypt emails but, instead, chat messages; specifically, it extends a chat
    protocol called the *Extensible Messaging and Presence Protocol* (XMPP).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 2004 年，*Off-The-Record*（OTR*）* 在一篇名为“离线记录通信，或者，为什么不使用 PGP”的白皮书中介绍。与 PGP 或 S/MIME
    不同，OTR 不用于加密电子邮件，而是聊天消息；具体来说，它扩展了一种称为*可扩展消息和出席协议*（XMPP）的聊天协议。
- en: One of the distinctive features of OTR was *deniability*—a claim that recipients
    of your messages and passive observers cannot use messages you sent them in a
    court of justice. Because messages you send are authenticated and encrypted symmetrically
    with a key your recipient shares with you, they could have easily forged these
    messages themselves. By contrast, with PGP, messages are signed and are, thus,
    the inverse of deniable—messages are *non-repudiable*. To my knowledge, none of
    these properties have actually been tested in court.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: OTR 的一个独特特性是*可否认性*——即您的消息接收者和被动观察者无法在法庭上使用您发送给他们的消息。因为您发送的消息是经过身份验证和对称加密的，使用的密钥是您的接收者与您共享的，他们很容易伪造这些消息。相比之下，使用
    PGP，消息被签名，因此，与否认相反——消息是*不可否认的*。据我所知，这些属性实际上没有在法庭上进行过测试。
- en: In 2010, the Signal mobile phone application (then called TextSecure) was released,
    making use of a newly created protocol called the *Signal protocol*. At the time,
    most secure communication protocols like PGP, S/MIME, and OTR were based on *federated
    protocols*, where no central entity was required for the network to work. The
    Signal mobile application largely departed from tradition by running a central
    service and offering a single official Signal client application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2010 年，Signal 手机应用程序（当时称为 TextSecure）发布，使用了一个新创建的协议，称为*Signal 协议*。当时，大多数安全通信协议如
    PGP、S/MIME 和 OTR 都是基于*联邦协议*的，即网络无需中央实体即可运行。Signal 手机应用程序在很大程度上背离了传统，通过运行一个中央服务并提供一个官方
    Signal 客户端应用程序。
- en: While Signal prevents interoperability with other servers, the Signal protocol
    is open standard and has been adopted by many other messaging applications including
    Google Allo (now defunct), WhatsApp, Facebook Messenger, Skype, and many others.
    The Signal protocol is truly a success story, transparently being used by billions
    of people including journalists, targets of government surveillance, and even
    my 92-year-old grandmother (I swear I did not make her install it).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Signal 阻止了与其他服务器的互操作性，但 Signal 协议是开放标准，并已被许多其他消息应用程序采用，包括 Google Allo（现已停用）、WhatsApp、Facebook
    Messenger、Skype 等等。Signal 协议真正是一个成功的故事，透明地被数十亿人使用，包括记者、政府监视目标，甚至是我 92 岁的奶奶（我发誓我没有让她安装）。
- en: 'It is interesting to look at how Signal works because it attempts to fix many
    of the flaws that I previously mentioned with PGP. In this section, I will go
    over each one of the following interesting features of Signal:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 研究 Signal 如何工作是很有趣的，因为它试图修复我之前提到的 PGP 的许多缺陷。在本节中，我将逐个讨论 Signal 的以下有趣特性：
- en: How can we do better than the WOT? Is there a way to upgrade the existing social
    graphs with end-to-end encryption? Signal’s answer is to use a *trust on first
    use* (TOFU) approach. TOFU allows users to blindly trust other users the first
    time they communicate, relying on this first, insecure exchange to establish a
    long-lasting secure communication channel. Users are then free to check if the
    first exchange was MITM’d by matching their session secret out of band and at
    any point in the future.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能比WOT做得更好吗？有没有办法升级现有的社交图与端到端加密？Signal的答案是使用*首次使用信任*（TOFU）方法。TOFU允许用户在第一次通信时盲目信任其他用户，依靠这种首次不安全的交换来建立持久的安全通信渠道。然后用户可以自由地通过在任何时候在辅助渠道上匹配会话密钥来检查第一次交换是否被MITM攻击。
- en: 'How can we upgrade PGP to obtain forward secrecy every time we start a conversation
    with someone? The first part of the Signal protocol is like most secure transport
    protocols: it’s a key exchange, but a particular one called *Extended Triple Diffie-Hellman*
    (X3DH). More on that later.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何升级PGP以在每次与某人开始对话时都获得前向保密性？Signal协议的第一部分与大多数安全传输协议类似：它是一个密钥交换，但是一个特殊的称为*扩展三重Diffie-Hellman*（X3DH）的密钥交换。稍后详细介绍。
- en: How can we upgrade PGP to obtain forward secrecy for every single message? This
    is important because conversations between users can span years, and a compromise
    at some point in time should not reveal years of communication. Signal addresses
    this with something called a *symmetric ratchet*.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何升级PGP以使每条消息都获得前向保密性？这很重要，因为用户之间的对话可能会跨越多年，某个时间点的泄密不应该暴露多年的通信。Signal用一种称为*对称棘轮*的东西来解决这个问题。
- en: What if two users’ session secrets are compromised at some point in time? Is
    that game over? Can we also recover from that? Signal introduces a new security
    property called *post-compromise security* (PCS) and addresses this with what
    is called a *Diffie-Hellman* (DH) *ratchet*.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个用户的会话密钥在某个时间点被泄露，会怎么样？这意味着游戏结束吗？我们是否也可以从中恢复？Signal引入了一个称为*后置泄密安全*（PCS）的新安全属性，并用所谓的*Diffie-Hellman*（DH）*棘轮*来解决这个问题。
- en: Let’s get started! First, we’ll see how Signal’s flavor of TOFU works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！首先，我们将看看Signal的TOFU是如何工作的。
- en: '10.4.1 More user-friendly than the WOT: Trust but verify'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 比WOT更用户友好：信任但验证
- en: One of email encryption’s biggest failures was its reliance on PGP and the WOT
    model to transform social graphs into *secure* social graphs. PGP’s original design
    intended for people to meet in person to perform a *key-signing ceremony* (also
    called a *key-signing party*) to confirm one another’s keys, but this was cumbersome
    and inconvenient in many and various ways. It is really rare today to see people
    signing each other’s PGP keys.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件加密最大的失败之一是其依赖于PGP和WOT模型将社交图转化为*安全*的社交图。PGP的原始设计打算让人们面对面进行*密钥签名仪式*（也称为*密钥签名派对*）来确认彼此的密钥，但这在许多方面都很繁琐和不方便。今天很少见到人们互相签署PGP密钥。
- en: The way most people use applications like PGP, OTR, Signal, and so on, is to
    blindly trust a key the first time they see it and to reject any future changes
    (as figure 10.7 illustrates). This way, only the first connection can be attacked
    (and this only by an active MITM attacker).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人使用PGP、OTR、Signal等应用程序的方式是盲目信任第一次见到的密钥，并拒绝任何未来的更改（如图10.7所示）。这样，只有第一次连接才可能受到攻击（而且仅受到主动MITM攻击者的攻击）。
- en: '![](../Images/10_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_07.jpg)'
- en: Figure 10.7 Trust on first use (TOFU) allows Alice to trust her first connection
    but not subsequent connections if they don’t exhibit the same public key. TOFU
    is an easy mechanism to build trust when the chances that the first connection
    is actively MITM’d are low. The association between a public key and the identity
    (here Bob) can also be verified after the fact in a different channel.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7的首次使用信任（TOFU）允许Alice信任她的第一个连接，但如果后续连接没有展示相同的公钥，则不信任。当第一个连接被潜在的中间人攻击的可能性很低时，TOFU是一种建立信任的简单机制。公钥与身份（这里是Bob）之间的关联也可以在之后的不同渠道中验证。
- en: While TOFU is not the best security model, it is often the best we have and
    has proven extremely useful. The Secure Shell (SSH) protocol, for example, is
    often used by trusting the server’s public key during the initial connection (see
    figure 10.8) and by rejecting any future change.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TOFU不是最佳的安全模型，但它通常是我们拥有的最佳模型，并且已被证明非常有用。例如，安全外壳（SSH）协议通常在初始连接时信任服务器的公钥（参见图10.8），并拒绝任何未来的更改。
- en: '![](../Images/10_08.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_08.jpg)'
- en: Figure 10.8 SSH clients use trust on first use. The first time you connect to
    an SSH server (the left picture), you have the option to blindly trust the association
    between the SSH server and the public key displayed. If the public key of the
    SSH server later changes (right picture), your SSH client prevents you from connecting
    to it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 SSH 客户端使用第一次使用时信任。当您第一次连接到 SSH 服务器时（左图），您可以选择盲目地信任 SSH 服务器和显示的公钥之间的关联。如果
    SSH 服务器的公钥稍后更改（右图），您的 SSH 客户端将阻止您连接到它。
- en: While TOFU systems trust the first key they see, they still allow the user to
    later verify that the key is, indeed, the right one and to catch any impersonation
    attempts. In real-world applications, users typically compare *fingerprints*,
    which are most often hexadecimal representations of public keys or hashes of public
    keys. This verification is, of course, done out of band. (If the SSH connection
    is compromised, then the verification is compromised as well.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TOFU 系统信任它们看到的第一个密钥，但它们仍允许用户稍后验证该密钥是否确实正确，并捕捉任何冒充尝试。在现实世界的应用中，用户通常比较*指纹*，这些指纹通常是公钥的十六进制表示或公钥的哈希值。当然，此验证是在带外完成的。（如果
    SSH 连接被破坏，那么验证也会被破坏。）
- en: Note Of course, if users do not verify fingerprints, then they can be MITM’d
    without knowing it. But that is the kind of tradeoff that real-world applications
    have to deal with when bringing end-to-end encryption at scale. Indeed, the failure
    of the WOT shows that security-focused applications must keep usability in mind
    to get widely adopted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 当然，如果用户不验证指纹，则可能在不知情的情况下成为中间人攻击的受害者。但这是现实世界应用在实现大规模端到端加密时必须处理的一种权衡。事实上，WOT
    的失败表明，面向安全的应用必须考虑可用性才能被广泛采用。
- en: 'In the Signal mobile application, a fingerprint between Alice and Bob is computed
    by:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Signal 移动应用中，Alice 和 Bob 之间的指纹是通过以下方式计算的：
- en: Hashing Alice’s identity key prefixed by her username (a phone number in Signal)
    and interpreting a truncation of that digest as a series of numbers
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 Alice 的用户名（在 Signal 中是电话号码）作为前缀，对她的身份密钥进行哈希，并将该摘要的截断解释为一系列数字
- en: Doing the same for Bob
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 Bob 做同样的操作
- en: Displaying the concatenation of the two series of numbers to the user
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两系列数字的串联显示给用户
- en: Applications like Signal make use of *QR codes* to let users verify fingerprints
    more easily as these codes can be lengthy. Figure 10.9 illustrates this use case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序像 Signal 使用*QR 码*让用户更轻松地验证指纹，因为这些码可能很长。图 10.9 展示了这种用法。
- en: '![](../Images/10_09.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_09.jpg)'
- en: Figure 10.9 With Signal, you can verify the authenticity and confidentiality
    of the connection you have with a friend by using a different channel (just like
    in real life) to make sure the two fingerprints (Signal calls them *safety numbers*)
    of you and your friend match. This can be done more easily via the use of a QR
    code, which encodes this information in a scannable format. Signal also hashes
    the session secret instead of the two users’ public keys, allowing them to verify
    one large string instead of two.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 使用 Signal，您可以通过使用不同的通道（就像在现实生活中一样）来验证与朋友的连接的真实性和机密性，以确保您和朋友的两个指纹（Signal
    称它们为*安全号码*）匹配。通过使用 QR 码，可以更容易地完成此操作，该码以可扫描的格式编码此信息。Signal 还对会话密钥进行哈希处理，而不是两个用户的公钥，使它们可以验证一个大字符串而不是两个。
- en: Next, let’s see how the Signal protocol works under the hood—specifically, how
    Signal manages to be forward secure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 Signal 协议在幕后是如何工作的——具体来说，Signal 如何确保前向安全性。
- en: '10.4.2 X3DH: the Signal protocol’s handshake'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 X3DH：Signal 协议的握手
- en: Most secure messaging apps before Signal were *synchronous*. This meant that,
    for example, Alice wasn’t able to start (or continue) an end-to-end encrypted
    conversation with Bob if Bob was not online. The Signal protocol, on the other
    hand, is *asynchronous* (like email), meaning that Alice can start (and continue)
    a conversation with people that are offline.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Signal 之前，大多数安全消息应用程序都是*同步*的。这意味着，例如，如果 Bob 不在线，Alice 就无法开始（或继续）与 Bob 进行端到端加密的对话。另一方面，Signal
    协议是*异步*的（像电子邮件一样），这意味着 Alice 可以开始（并继续）与离线的人进行对话。
- en: Remember that *forward secrecy* (covered in chapter 9) means that a compromise
    of keys does not compromise previous sessions and that forward secrecy usually
    means that the key exchanges are interactive because both sides have to generate
    ephemeral Diffie-Hellman (DH) key pairs. In this section, you will see how Signal
    uses *non-interactive* key exchanges (key exchanges where one side is potentially
    offline) that are still forward secure. OK, let’s get going.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 *前向保密性*（在第 9 章中介绍）意味着密钥的泄露不会泄露先前的会话，并且前向保密性通常意味着密钥交换是交互式的，因为双方都必须生成临时的 Diffie-Hellman（DH）密钥对。在本节中，您将了解
    Signal 如何使用 *非交互式* 密钥交换（其中一方有可能处于离线状态）仍然保持前向安全性。好的，让我们开始吧。
- en: 'To start a conversation with Bob, Alice initiates a key exchange with him.
    Signal’s key exchange, X3DH, combines three (or more) DH key exchanges into one.
    But before you learn how that works, you need to understand the three different
    types of DH keys that Signal uses:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 Bob 开始对话，Alice 与他启动密钥交换。Signal 的密钥交换 X3DH 将三（或更多）个 DH 密钥交换组合成一个。但在了解其工作原理之前，您需要了解
    Signal 使用的三种不同类型的 DH 密钥：
- en: '*Identity keys*—These are the long-term keys that represent the users. You
    can imagine that if Signal only used identity keys, then the scheme would be fairly
    similar to PGP, and there would be no forward secrecy.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*身份密钥* — 这些是代表用户的长期密钥。您可以想象，如果 Signal 只使用身份密钥，那么该方案与 PGP 非常相似，并且不会有前向保密性。'
- en: '*One-time prekeys*—In order to add forward secrecy to the key exchange, even
    when the recipient of a new conversation is not online, Signal has users upload
    multiple *single-use* public keys. They are simply ephemeral keys that are uploaded
    in advance and are deleted after being used.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一次性 prekeys* — 为了在密钥交换中添加前向保密性，即使新对话的接收方不在线，Signal 让用户上传多个 *单次使用* 公钥。它们只是预先上传的短暂密钥，在使用后将被删除。'
- en: '*Signed prekeys*—We could stop here, but there’s one edge case missing. Because
    the one-time prekeys that a user uploads can, at some point, be depleted, users
    also have to upload a *medium-term* public key that they sign: a signed prekey.
    This way, if no more one-time prekeys are available on the server under your username,
    someone can still use your signed prekey to add forward secrecy up to the last
    time you changed your signed prekey. This also means that you have to periodically
    rotate your signed prekey (for example, every week).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*签名的 prekeys* — 我们可以到此为止，但是有一个边缘情况被忽略了。因为用户上传的一次性 prekeys 在某个时候会用完，用户还必须上传一个被签名的
    *中期* 公钥：一个签名的 prekey。这样，如果服务器上您用户名下没有更多的一次性 prekeys，某人仍然可以使用您的签名 prekey 来添加前向保密性，直到您上次更改签名
    prekey 的时间。这也意味着您必须定期轮换您的签名 prekey（例如，每周）。'
- en: This is enough to preview what the flow of a conversation creation in Signal
    looks like. Figure 10.10 presents an overview.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以预览 Signal 中对话创建流程的流程。图 10.10 提供了概述。
- en: '![](../Images/10_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_10.jpg)'
- en: Figure 10.10 Signal’s flow starts with a user registering with a number of public
    keys. If Alice wants to talk to Bob, she first retrieves Bob’s public keys (called
    a *prekey bundle*), then she performs an X3DH key exchange with these keys and
    creates an initial message using the output of the key exchange. After receipt
    of the message, Bob can perform the same on his side to initialize and continue
    the conversation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 信号流程始于用户注册一系列公钥。如果 Alice 想和 Bob 聊天，她首先要获取 Bob 的公钥（称为 *prekey bundle*），然后她使用这些密钥进行
    X3DH 密钥交换，并使用密钥交换的输出创建初始消息。收到消息后，Bob 可以在他这边执行相同的操作来初始化并继续对话。
- en: 'Let’s go over each of these steps in more depth. First, a user registers by
    sending the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解每个步骤。首先，用户通过发送以下内容进行注册：
- en: One identity key
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个身份密钥
- en: One signed prekey and its signature
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个签名的 prekey 及其签名
- en: A defined number of one-time prekeys
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一定数量的一次性 prekeys
- en: At this point, it is the responsibility of the user to periodically rotate the
    signed prekey and upload new one-time prekeys. I recap this flow in figure 10.11.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，用户有责任定期轮换签名 prekey 并上传新的一次性 prekeys。我在图 10.11 中总结了这个流程。
- en: Note Signal makes use of the identity key to perform signatures over signed
    prekeys and key exchanges during the X3DH key exchange. While I’ve warned against
    using the same key for different purposes, Signal has deliberately analyzed that,
    in their case, there should be no issue. This does not mean that this would work
    in *your* case and with *your* key exchange algorithm. I would advise against
    using a key for different purposes in general.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Signal 使用身份密钥对签名进行签名，并在 X3DH 密钥交换期间执行密钥交换。虽然我已经警告不要将同一密钥用于不同的目的，但 Signal
    已经故意分析过，在他们的情况下不应该有问题。这并不意味着这会在*您*的情况下以及*您*的密钥交换算法中起作用。我建议一般情况下不要为不同的目的使用同一密钥。
- en: '![](../Images/10_11.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_11.jpg)'
- en: Figure 10.11 Building on figure 10.10, the first step is for a user to register
    by generating a number of DH key pairs and sending the public parts to a central
    server.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 基于图 10.10，第一步是用户通过生成一些 DH 密钥对并将公共部分发送给中央服务器来注册。
- en: 'After the step introduced in figure 10.11, Alice (going back to our example)
    would then start a conversation with Bob by retrieving:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 10.11 中引入的步骤之后，**Alice**（回到我们的示例中）然后通过检索开始与 **Bob** 对话：
- en: Bob’s identity key.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bob** 的身份密钥。'
- en: Bob’s current signed prekey and its associated signature.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bob** 的当前签名前置密钥及其相关签名。'
- en: If there are still some, one of Bob’s one-time prekeys (the server then deletes
    the one-time prekey sent to Alice).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果仍然存在一些情况，那么是 **Bob** 的一次性预密钥之一（然后服务器会删除发送给 **Alice** 的一次性预密钥）。
- en: 'Alice can verify that the signature over the signed prekey is correct. She
    then performs the X3DH handshake with:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**Alice** 可以验证签名是否正确。然后，她与以下人进行 X3DH 握手：'
- en: All of the public keys from Bob
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 **Bob** 的所有公钥
- en: An ephemeral key pair that she generates for the occasion in order to add forward
    secrecy
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 她为此生成的一对临时密钥，以添加前向保密性
- en: Her own identity key
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 她自己的身份密钥
- en: 'The output of X3DH is then used in a post-X3DH protocol, which is used to encrypt
    her messages to Bob (more on that in the next section). X3DH is composed of three
    (optionally, four) DH key exchanges, grouped into one. The DH key exchanges are
    between:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: X3DH 的输出然后用于后-X3DH 协议，该协议用于将她的消息加密发送给 **Bob**（关于此后详细介绍）。X3DH 由三（可选四）个 DH 密钥交换组成，分组在一起。DH
    密钥交换是在以下之间进行的：
- en: The identity key of Alice and the signed prekey of Bob
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Alice** 的身份密钥和 **Bob** 的签名前置密钥'
- en: The ephemeral key of Alice and the identity key of Bob
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Alice** 的临时密钥和 **Bob** 的身份密钥'
- en: The ephemeral key of Alice and the signed prekey of Bob
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Alice** 的临时密钥和 **Bob** 的签名前置密钥'
- en: If Bob still has a one-time prekey available, his one-time prekey and the ephemeral
    key of Alice
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **Bob** 仍然有一个可用的一次性预密钥，他的一次性预密钥和 **Alice** 的临时密钥
- en: The output of X3DH is the concatenation of all of these DH key exchanges, passed
    to a key derivation function (KDF), which we covered in chapter 8\. Different
    key exchanges provide different properties. The first and second ones are here
    for mutual authentication, while the last two are here for forward secrecy. All
    of this is analyzed in more depth in the X3DH specification ([https://signal.org/docs/specifications/x3dh/](https://signal.org/docs/specifications/x3dh/)),
    which I encourage you to read if you want to know more as it is well written.
    Figure 10.12 recaps this flow.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: X3DH 的输出是所有这些 DH 密钥交换的连接，传递给密钥派生函数（KDF），我们在第 8 章中介绍了它。不同的密钥交换提供不同的属性。前两个是用于相互认证，而最后两个是用于前向保密性。所有这些都在
    X3DH 规范中更深入地分析了（[https://signal.org/docs/specifications/x3dh/](https://signal.org/docs/specifications/x3dh/)），我建议您阅读，因为它写得很好。图
    10.12 概述了这个流程。
- en: '![](../Images/10_12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_12.jpg)'
- en: Figure 10.12 Building on figure 10.10, to send a message to Bob, Alice fetches
    a prekey bundle containing Bob’s long-term key, Bob’s signed prekey, and optionally,
    one of Bob’s one-time prekeys. After performing different key exchanges with the
    different keys, all outputs are concatenated and passed into a KDF to produce
    an output used in a subsequent post-X3DH protocol to encrypt messages to Bob.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 基于图 10.10，要向 **Bob** 发送消息，**Alice** 获取一个预密钥包，其中包含 **Bob** 的长期密钥、**Bob**
    的签名前置密钥，以及可选地，**Bob** 的一次性预密钥之一。在与不同密钥进行不同的密钥交换后，所有输出都被串联并传递到 KDF 中，以生成在后续的后-X3DH
    协议中用于加密消息发送给 **Bob** 的输出。
- en: Alice now can send Bob her identity public key, the ephemeral public key she
    generated to start the conversation, and other relevant information (like which
    of Bob’s one-time prekeys she used). Bob receives the message and can perform
    the exact same X3DH key exchange with the public keys contained in it. (For this
    reason, I skip illustrating the last step of this flow.) If Alice used one of
    Bob’s one-time prekeys, Bob gets rid of it. What happens after X3DH is done? Let’s
    look at that next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Alice 可以将她的身份公钥、她生成的用于开始对话的临时公钥以及其他相关信息（比如她使用了 Bob 的一次性预密钥中的哪个）发送给 Bob。Bob
    收到消息后，可以使用其中包含的公钥执行与 X3DH 相同的密钥交换。（因此，我跳过了此流程的最后一步的说明。）如果 Alice 使用了 Bob 的一次性预密钥之一，Bob
    将其丢弃。X3DH 完成后会发生什么？让我们来看看接下来发生了什么。
- en: '10.4.3 Double Ratchet: Signal’s post-handshake protocol'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 双扭转：Signal 的后握手协议
- en: The post-X3DH phase lives as long as the two users do not delete their conversations
    or lose any of their keys. For this reason, and because Signal was designed with
    SMS conversations in mind, where the time between two messages might be counted
    in months, Signal introduces *forward secrecy* at the message level. In this section,
    you will learn how this post-handshake protocol (called the *Double Ratchet*)
    works.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在双方用户不删除对话或不丢失任何密钥的情况下，后 X3DH 阶段将持续存在。因此，Signal 在消息级别引入*前向保密性*。在这个部分，您将学习到这个后握手协议（称为*双扭转*）是如何工作的。
- en: But first, imagine a simple post-X3DH protocol. Alice and Bob could have taken
    the output of X3DH as a session key and use it to encrypt messages between them
    as figure 10.13 illustrates.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，想象一下一个简单的后 X3DH 协议。Alice 和 Bob 可以将 X3DH 的输出作为会话密钥，并将其用于加密他们之间的消息，如图 10.13
    所示。
- en: '![](../Images/10_13.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13](../Images/10_13.jpg)'
- en: Figure 10.13 Naively, a post-X3DH protocol could simply use the output of X3DH
    as a session key to encrypt messages between Alice and Bob.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 像个简单的后 X3DH 协议，Alice 和 Bob 可以将 X3DH 的输出作为会话密钥，用于加密他们之间的消息。
- en: We usually want to separate the keys used for different purposes though. What
    we can do is to use the output of X3DH as a *seed* (or *root key*, according to
    the Double Ratchet specification) to a KDF in order to derive two other keys.
    Alice can use one key to encrypt messages to Bob, and Bob can use the other key
    to encrypt messages to Alice. I illustrate this in figure 10.14.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望将用于不同目的的密钥分开。我们可以将 X3DH 的输出用作 KDF 的*种子*（或根密钥，根据双扭转规范），以便派生出另外两个密钥。Alice
    可以使用一个密钥来加密发给 Bob 的消息，而 Bob 可以使用另一个密钥来加密发给 Alice 的消息。我在图 10.14 中说明了这一点。
- en: '![](../Images/10_14.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14](../Images/10_14.jpg)'
- en: Figure 10.14 Building on figure 10.13, a better post-X3DH protocol would make
    use of a KDF with the output of the key exchanges to differentiate keys used to
    encrypt Bob’s and Alice’s messages. Here Alice’s sending key is the same as Bob’s
    receiving key, and Bob’s sending key is the same as Alice’s receiving key.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 10.13 的基础上构建一个更好的后 X3DH 协议会利用 KDF 与密钥交换的输出来区分用于加密 Bob 和 Alice 消息的密钥。这里 Alice
    的发送密钥与 Bob 的接收密钥相同，而 Bob 的发送密钥与 Alice 的接收密钥相同。
- en: This approach could be enough, but Signal notes that texting sessions can last
    for years. This is unlike the TLS sessions of chapter 9 that are usually expected
    to be short-lived. Because of this, if at any point in time the session key is
    stolen, all previously recorded messages can be decrypted!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能已经足够了，但 Signal 指出，短信会话可能持续数年。这与通常预期是短暂的第 9 章的 TLS 会话不同。因此，如果在任何时间点会话密钥被窃取，所有先前记录的消息都可以被解密！
- en: To fix this, Signal introduced what is called a *symmetric ratchet* (as figure
    10.15 illustrates). The *sending key* is now renamed a *sending chain key* and
    is not used directly to encrypt messages. When sending a message, Alice continuously
    passes that sending chain key into a one-way function that produces the next sending
    chain key as well as the actual sending keys to encrypt her messages. Bob, on
    the other hand, will have to do the same but with the receiving chain key. Thus,
    by compromising one sending key or sending chain key, an attacker cannot recover
    previous keys. (And the same is true when receiving messages.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Signal 引入了所谓的*对称扭转*（如图 10.15 所示）。*发送密钥*现在被重命名为*发送链密钥*，并且不直接用于加密消息。在发送消息时，Alice
    将不断将发送链密钥传入一个单向函数，该函数产生下一个发送链密钥以及实际用于加密她的消息的发送密钥。另一方面，Bob 将不得不使用接收链密钥执行相同的操作。因此，通过牺牲一个发送密钥或发送链密钥，攻击者无法恢复以前的密钥。（接收消息时也是如此。）
- en: '![](../Images/10_15.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15](../Images/10_15.jpg)'
- en: Figure 10.15 Building on figure 10.14, forward secrecy can be introduced in
    the post-X3DH protocol by *ratcheting* (passing into a KDF) a chain key every
    time one needs to send a message, and ratcheting another chain key every time
    one receives a message. Thus, the compromise of a sending or receiving chain key
    does not allow an attacker to recover previous ones.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 在图 10.14 的基础上构建，在 post-X3DH 协议中可以通过 *ratcheting*（传递到 KDF）每次需要发送消息时引入前向保密性，并在每次接收消息时对另一个链密钥进行
    *ratcheting*。因此，发送或接收链密钥的 compromise 不允许攻击者恢复先前的密钥。
- en: Good. We now have forward secrecy baked into our protocol and at the message
    level. Every message sent and received protects all previously sent and received
    messages. Note that this is somewhat debatable as an attacker who compromises
    a key probably does this by compromising a user’s phone, which will likely contain
    all previous messages in cleartext next to the key. Nevertheless, if both users
    in a conversation decide to delete previous messages (for example, by using Signal’s
    “disappearing messages” feature), the forward secrecy property is achieved.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们现在在我们的协议中和消息级别都嵌入了前向保密性。每个发送和接收的消息都保护了所有先前发送和接收的消息。请注意，这在某种程度上是值得商榷的，因为一个攻击者如果
    compromise 了一个密钥，可能是通过 compromise 一个用户的手机，而这很可能会在密钥旁边以明文的方式包含所有先前的消息。尽管如此，如果对话中的两个用户都决定删除先前的消息（例如，通过使用
    Signal 的“消失消息”功能），则实现了前向保密性属性。
- en: 'The Signal protocol has one last interesting thing I want to talk about: PCS
    (*post-compromise security*, also called *backward secrecy* as you learned in
    chapter 8). PCS is the idea that if your keys get compromised at some point, you
    can still manage to recover as the protocol will heal itself. Of course, if the
    attacker still has access to your device after a compromise, then this is for
    nothing.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Signal 协议还有一件我想谈论的有趣事情：PCS（*post-compromise security*，也称为 *backward secrecy*，正如你在第
    8 章学到的）。PCS 是一个想法，即如果你的密钥在某个时候被 compromise，你仍然可以设法恢复，因为协议会自动修复。当然，如果攻击者在 compromise
    后仍然可以访问你的设备，那么这就没有用了。
- en: PCS can work only by reintroducing new entropy that a nonpersistent compromise
    wouldn’t have access to. The new entropy has to be the same for both peers. Signal’s
    way of finding such entropy is by doing an ephemeral key exchange. To do this,
    the Signal protocol continuously performs key exchanges in what is called a *DH
    ratchet*. Every message sent by the protocol comes with the current ratchet public
    key as figure 10.16 illustrates.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: PCS 只能通过重新引入非持久性 compromise 无法访问的新熵来工作。新熵必须对两个对等体相同。Signal 找到这种熵的方法是通过进行短暂密钥交换。为此，Signal
    协议在所谓的 *DH ratchet* 中不断执行密钥交换。协议发送的每个消息都带有当前的 *ratchet* 公钥，如图 10.16 所示。
- en: '![](../Images/10_16.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_16.jpg)'
- en: Figure 10.16 The Diffie-Hellman (DH) ratchet works by advertising a ratchet
    public key in every message sent. This ratchet public key can be the same as the
    previous one, or it can advertise a new ratchet public key if a participant decides
    to refresh theirs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 Diffie-Hellman（DH）*ratchet* 通过在每个发送的消息中广告一个 *ratchet* 公钥来工作。这个 *ratchet*
    公钥可以与上一个相同，也可以在参与者决定刷新自己的时候广告一个新的 *ratchet* 公钥。
- en: When Bob notices a new ratchet key from Alice, he must perform a new DH key
    exchange with Alice’s new ratchet key and Bob’s own ratchet key. The output can
    then be used with the symmetric ratchet to decrypt the messages received. I illustrate
    this in figure 10.17.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Bob 察觉到来自 Alice 的新 *ratchet* 密钥时，他必须与 Alice 的新 *ratchet* 密钥和 Bob 自己的 *ratchet*
    密钥进行新的 DH 密钥交换。然后可以将输出与对称 *ratchet* 一起用于解密接收到的消息。我在图 10.17 中说明了这一点。
- en: '![](../Images/10_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_17.jpg)'
- en: Figure 10.17 When receiving a new ratchet public key from Alice, Bob must do
    a key exchange with it and his own ratchet key to derive decryption keys. This
    is done with the symmetric ratchet. Alice’s messages can then be decrypted.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 当 Bob 从 Alice 那里接收到一个新的 *ratchet* 公钥时，他必须与它和他自己的 *ratchet* 密钥进行密钥交换，以派生解密密钥。这是用对称
    *ratchet* 来完成的。然后可以解密 Alice 的消息。
- en: Another thing that Bob must do when receiving a new ratchet key is to generate
    a new random ratchet key for himself. With his new ratchet key, he can perform
    another key exchange with Alice’s new ratchet key, which he then uses to encrypt
    messages to her. This should look like figure 10.18.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Bob 接收到新的 *ratchet* 密钥时，他必须为自己生成一个新的随机 *ratchet* 密钥。通过他的新 *ratchet* 密钥，他可以与
    Alice 的新 *ratchet* 密钥进行另一次密钥交换，然后用它来加密发给她的消息。这应该看起来像图 10.18。
- en: '![](../Images/10_18.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_18.jpg)'
- en: Figure 10.18 Building on figure 10.17, after receiving a new ratchet key Bob
    must also generate a new ratchet key for himself. This new ratchet key is used
    to derive encryption keys and is advertised to Alice in his next series of messages
    (up until he receives a new ratchet key from Alice).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 在图 10.17 的基础上构建，在接收到新的棘轮密钥后，Bob 还必须为自己生成新的棘轮密钥。这个新的棘轮密钥用于派生加密密钥，并在他的下一系列消息中向
    Alice 广告（直到他收到来自 Alice 的新的棘轮密钥）。
- en: 'This back and forth of key exchanges is mentioned as a “ping-pong” in the Double
    Ratchet specification:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在双棘轮规范中，密钥交换的这种来回被提及为“乒乓”：
- en: '*This results in a “ping-pong” behavior as the parties take turns replacing
    ratchet key pairs. An eavesdropper who briefly compromises one of the parties
    might learn the value of a current ratchet private key, but that private key will
    eventually be replaced with an uncompromised one. At that point, the Diffie-Hellman
    calculation between ratchet key pairs will define a DH output unknown to the attacker*.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*这导致了一种“乒乓”行为，因为各方轮流替换棘轮密钥对。一个窃听者可能会短暂地 compromise 其中一方，但他可能了解当前棘轮私钥的值，但该私钥最终将被替换为未被
    compromise 的私钥。在这一点上，棘轮密钥对之间的 Diffie-Hellman 计算将定义攻击者不知道的 DH 输出*。'
- en: —The Double Ratchet Algorithm
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: —双棘轮算法
- en: Finally, the combination of the DH ratchet and the symmetric ratchet is called
    the *Double Ratchet*. It’s a bit dense to visualize as one diagram, but figure
    10.19 attempts to do so.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，DH 棘轮和对称棘轮的组合被称为*双棘轮*。作为一个图表来视觉化有点密集，但图 10.19 尝试这样做。
- en: '![](../Images/10_19.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_19.jpg)'
- en: Figure 10.19 The Double Ratchet (from Alice’s point of view) combines the DH
    ratchet (on the left) with the symmetric ratchet (on the right). This provides
    PCS as well as forward secrecy to the post-X3DH protocol. In the first message,
    Alice does not yet know Bob’s ratchet key so she uses his presigned key instead.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 双棘轮（从 Alice 视角）将 DH 棘轮（左侧）与对称棘轮（右侧）结合起来。这为后 X3DH 协议提供了 PCS 和前向保密性。在第一条消息中，Alice
    还不知道 Bob 的棘轮密钥，因此她使用了他的预签名密钥。
- en: I know this last diagram is quite dense, so I encourage you to take a look at
    Signal’s specifications, which are published on [https://signal.org/docs](https://signal.org/docs).
    They provide another well-written explanation of the protocol.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道最后这个图表相当密集，所以我鼓励你查看 Signal 的规范，这些规范已经发布在 [https://signal.org/docs](https://signal.org/docs)
    上。它们提供了协议的另一个写得很好的解释。
- en: 10.5 The state of end-to-end encryption
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 端到端加密的状态
- en: Today, most secure communications between users happen through secure messaging
    applications instead of encrypted emails. The Signal protocol has been the clear
    winner in its category, being adopted by many proprietary applications and also
    by open source and federated protocols like XMPP (via the OMEMO extension) and
    Matrix (a modern alternative to IRC). On the other hand, PGP and S/MIME are being
    dropped as published attacks have led to a loss of trust.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，用户之间的大多数安全通信都是通过安全的消息应用程序进行而不是加密电子邮件。在其类别中，Signal 协议一直是明确的赢家，被许多专有应用程序采用，也被开源和联合协议如
    XMPP（通过 OMEMO 扩展）和 Matrix（IRC 的现代替代品）采用。另一方面，PGP 和 S/MIME 正在被放弃，因为已经发表的攻击导致了信任的丧失。
- en: What if you want to write your own end-to-end encrypted messaging app? Unfortunately,
    a lot of what’s being used in this field is ad hoc, and you would have to fill
    in many of the details yourself in order to obtain a full-featured and secure
    system. Signal has open sourced a lot of its code, but it lacks documentation
    and can be hard to use correctly. On the other hand, you might have better luck
    using a decentralized open source solution like Matrix, which might prove easier
    to integrate with. This is what the French government has done.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想编写自己的端到端加密消息应用程序怎么办？不幸的是，这个领域使用的大部分东西都是临时的，你必须自己填写许多细节才能获得一个功能齐全且安全的系统。Signal
    已经开源了大部分代码，但缺乏文档，并且可能难以正确使用。另一方面，你可能会更容易地使用像 Matrix 这样的分散式开源解决方案，这可能更容易与之集成。这就是法国政府所做的。
- en: Before we close this chapter, there are also a number of open questions and
    active research problems that I want to talk about. For example
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，我还想谈谈一些未解决的问题和正在进行的研究问题。例如
- en: Group messaging
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 群组消息
- en: Support for multiple devices
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对多个设备的支持
- en: Better security assurances than TOFU
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比 TOFU 更好的安全保证
- en: 'Let’s start with the first item: *group messaging*. At this point, while implemented
    in different ways by different applications, group messaging is still being actively
    researched. For example, the Signal application has clients make sense of group
    chats. Servers only see pairs of users talking—never less, never more. This means
    that clients have to encrypt a group chat message to all of the group chat participants
    and send them individually. This is called *client-side fanout* and does not scale
    super well. It is also not too hard for the server to figure out what are the
    group members when it sees Alice, for example, sending several messages of the
    same length to Bob and Charles (figure 10.20).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一项开始：*群组消息传递*。目前，虽然不同应用程序以不同的方式实现，但群组消息传递仍在积极研究中。例如，Signal应用程序让客户端理解群聊。服务器只看到一对一的用户交谈——从来不少，也从来不多。这意味着客户端必须将群聊消息加密发送给所有群聊参与者并单独发送。这称为*客户端端点扩散*，并不是非常适合扩展。当服务器看到例如Alice向Bob和Charles发送多条长度相同的消息时，它也不太难弄清楚谁是群组成员（见图10.20）。
- en: '![](../Images/10_20.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10_20.jpg)'
- en: Figure 10.20 There are two ways to approach end-to-end encryption for group
    chats. A client-side fanout approach means that the client has to individually
    message each recipient using their already existing encrypted channel. This is
    a good approach to hide group membership from the server. A server-side fanout
    approach lets the server forward a message to each group chat participant. This
    is a good approach to reduce the number of messages sent from the client’s perspective.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 有两种方法可以实现群聊的端到端加密。客户端端点扩散方法意味着客户端必须使用其已经存在的加密通道向每个接收者单独发送消息。这是一个很好的方法，可以隐藏群组成员。服务器端端点扩散方法允许服务器将消息转发给每个群聊参与者。从客户端的角度来看，这是一种减少发送消息数量的好方法。
- en: WhatsApp, on the other hand, uses a variant of the Signal protocol where the
    server is aware of group chat membership. This change allows a participant to
    send a single encrypted message to the server that, in turn, will have the responsibility
    to forward it to the group members. This is called *server-side fanout*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，WhatsApp使用Signal协议的变体，其中服务器知道群聊成员。这一变化允许参与者向服务器发送单个加密消息，服务器负责将其转发给群成员。这称为*服务器端端点扩散*。
- en: Another problem of group chat is *scaling* to groups of a large memberset. For
    this, many players in the industry have recently gathered around a *Messaging
    Layer Security* (MLS) standard to tackle secure group messaging at scale. But
    there seems to be a lot of work to be done, and one can wonder, is there really
    any confidentiality in a group chat with more than a hundred participants?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 群聊的另一个问题是*扩展性*，可以扩展到大量成员。为此，行业中的许多参与者最近围绕*消息层安全*（MLS）标准聚集在一起，以应对大规模安全的群组消息传递。但是似乎还有很多工作要做，人们可以想象一下，在拥有一百多名参与者的群聊中是否真的有保密性？
- en: Note This is still an area of active research, and different approaches come
    with different tradeoffs in security and usability. For example, in 2021, no group
    chat protocol seems to provide *transcript consistency*, a cryptographic property
    that ensures that all participants of a group chat see the same messages in the
    same order.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 这仍然是一个积极研究的领域，不同的方法具有安全性和可用性方面的不同权衡。例如，在2021年，似乎没有任何群聊协议提供*转录一致性*，这是一种确保群聊所有参与者以相同顺序看到相同消息的加密属性。
- en: Support for multiple devices is either not a thing or implemented in various
    ways, most often by pretending that your different devices are different participants
    of a group chat. The TOFU model can make handling multiple devices quite complicated
    because having different identity keys per device can become a real key management
    problem. Imagine having to verify fingerprints for each of your devices and each
    of your friends’ devices. Matrix, for example, has a user sign their own devices.
    Other users then can trust all your devices as one entity by verifying their associated
    signatures.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多个设备要么根本不存在，要么以各种方式实现，最常见的是假装你的不同设备是群聊的不同参与者。TOFU模型可以使处理多个设备变得非常复杂，因为每个设备具有不同的身份密钥可能会成为一个真正的密钥管理问题。想象一下，为每个设备以及每个朋友的设备验证指纹。例如，Matrix让用户签署自己的设备。然后其他用户可以通过验证其关联的签名来信任所有你的设备作为一个实体。
- en: Finally, I mentioned that the TOFU model is also not the greatest as it is based
    on trusting a public key the first time we see it, and most users do not verify
    later that the fingerprints match. Can something be done about this? What if the
    server decides to impersonate Bob to Alice only? This is a problem that *Key Transparency*
    is trying to tackle. Key Transparency is a protocol proposed by Google, which
    is similar to the Certificate Transparency protocol that I talked about in chapter
    9\. There is also some research making use of the blockchain technology that I’ll
    talk about in chapter 12 on cryptocurrencies.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我提到 TOFU 模型也不是最好的，因为它是基于第一次看到公钥时信任它，而大多数用户后来并不验证指纹是否匹配。这个问题能做些什么？如果服务器决定只向
    Alice 冒充 Bob 怎么办？这是*密钥透明度*试图解决的问题。密钥透明度是 Google 提出的一个协议，类似于我在第 9 章讨论过的证书透明度协议。还有一些研究利用区块链技术，我将在第
    12 章关于加密货币的部分谈到。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: End-to-end encryption is about securing communications among real human beings.
    A protocol implementing end-to-end encryption is more resilient to vulnerabilities
    that can happen in servers sitting in between users and can greatly simplify legal
    requirements for companies.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端加密是为了保护真实人类之间的通信。实施端到端加密的协议对于服务器之间发生的漏洞更具弹性，并且可以极大地简化公司的法律要求。
- en: End-to-end encryption systems need a way to bootstrap trust between users. This
    trust can come from a public key that we already know or an out-of-band channel
    that we trust.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端加密系统需要一种方法来在用户之间建立信任。这种信任可以来自我们已经知道的公钥，或者是我们信任的带外信道。
- en: PGP and S/MIME are the main protocols that are used to encrypt emails today,
    yet none of them are considered safe to use as they make use of old cryptographic
    algorithms and practices. They also have poor integration with email clients that
    have been shown to be vulnerable to different attacks in practice.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PGP 和 S/MIME 是今天用于加密电子邮件的主要协议，然而它们都不被认为是安全的使用方式，因为它们使用了旧的密码算法和实践。它们还与已经被证明在实践中容易受到不同攻击的电子邮件客户端集成很差。
- en: PGP uses a web of trust (WOT) model, where users sign each other public keys
    in order to allow others to trust them.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PGP 使用信任网（WOT）模型，用户相互签署公钥以便让其他人信任他们。
- en: S/MIME uses a public key infrastructure to build trust between participants.
    It is most commonly used in companies and universities.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: S/MIME 使用公钥基础设施来建立参与者之间的信任。它最常用于公司和大学。
- en: An alternative to PGP is saltpack, which fixes a number of issues while relying
    on social networks to discover other people’s public keys.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PGP 的一种替代方案是 saltpack，它修复了一些问题，同时依赖社交网络来发现其他人的公钥。
- en: Emails will always have issues with encryption as the protocol was built without
    encryption in mind. On the other hand, modern messaging protocols and applications
    are considered better alternatives to encrypted emails as they are built with
    end-to-end encryption in mind.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件在加密方面始终存在问题，因为该协议并未考虑加密。另一方面，现代消息传递协议和应用程序被认为是加密电子邮件的更好选择，因为它们在设计时考虑了端到端加密。
- en: The Signal protocol is used by most messaging applications to secure end-to-end
    communications between users. Signal messenger, WhatsApp, Facebook Messenger,
    and Skype all advertise their use of the Signal protocol to secure messages.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Signal 协议被大多数消息传递应用程序用于保护用户之间的端到端通信。Signal Messenger、WhatsApp、Facebook Messenger
    和 Skype 都宣称他们使用 Signal 协议来保护消息。
- en: Other protocols, like Matrix, attempt to standardize federated protocols for
    end-to-end encrypted messaging. Federated protocols are open protocols that anyone
    can interoperate with (as opposed to centralized protocols that are limited to
    a single application).
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他协议，如 Matrix，试图标准化端到端加密消息传递的联邦协议。联邦协议是任何人都可以与之交互操作的开放协议（与限制在单个应用程序中的集中协议相对）。
