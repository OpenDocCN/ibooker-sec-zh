- en: 11 User authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 用户认证
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: The difference between authenticating people and data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证人员和数据之间的区别
- en: User authentication to authenticate users based on passwords or keys
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户认证，根据密码或密钥对用户进行身份验证。
- en: User-aided authentication to secure connections between a user’s devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户辅助认证以保护用户设备之间的连接
- en: 'In the introduction of this book, I boiled cryptography down to two concepts:
    confidentiality and authentication. In real-world applications, confidentiality
    is (usually) the least of your problems; authentication is where most of the complexity
    arises. I know I’ve already talked a lot about authentication throughout this
    book, but it can be a confusing concept as it is used with different meanings
    in cryptography. For this reason, this chapter starts with an introduction of
    what authentication really is about. As usual with cryptography, no protocol is
    a panacea, and the rest of the chapter will teach you a large number of authentication
    protocols that are used in real-world applications.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的介绍中，我将密码学简化为两个概念：机密性和认证。 在实际应用中，保密性（通常）不是你的问题所在； 认证是大部分复杂性产生的地方。 我知道我已经在整本书中大量谈论了认证，但是它在密码学中使用的含义不同，可能是一个令人困惑的概念。
    因此，本章从介绍认证的真正含义开始。 与密码学一样，没有协议是万能药，本章的其余部分将教你大量在实际应用中使用的认证协议。
- en: 11.1 A recap of authentication
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 认证回顾
- en: By now, you have heard of authentication many times, so let’s recap. You learned
    about
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经多次听说过认证，所以让我们回顾一下。 你学到了关于
- en: Authentication in cryptographic primitives like message authentication codes
    (covered in chapter 3) and authenticated encryption (covered in chapter 4)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在密码学原语中的认证，如消息认证码（在第3章中介绍）和认证加密（在第4章中介绍）
- en: Authentication in cryptographic protocols like TLS (covered in chapter 9) and
    Signal (covered in chapter 10), where one or more participants of a protocol can
    be authenticated
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码协议中的认证，如TLS（在第9章中介绍）和Signal（在第10章中介绍），其中协议的一个或多个参与者可以被认证
- en: 'In the first case, authentication refers to the *authenticity* (or *integrity*)
    of messages. In the latter case, authentication refers to *proving who you are
    to someone else*. These are different concepts covered by the same word, which
    can be quite confusing! But both usages are correct as the Oxford English Dictionary
    ([http://www.oed.com/](http://www.oed.com/)) points out:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，认证指的是消息的*真实性*（或*完整性*）。 在后一种情况下，认证是指*向别人证明自己是谁*。 这些是由相同单词涵盖的不同概念，这可能会相当令人困惑！
    但是牛津英语词典（[http://www.oed.com/](http://www.oed.com/)）指出，这两种用法都是正确的：
- en: '*Authentication. The process or action of proving or showing something to be
    true, genuine, or valid*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证。证明或展示某事物为真实、真正或有效的过程或行为*。'
- en: 'For this reason, you should think of authentication as a term used in cryptography
    to convey two different concepts depending on the context:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，你应该将认证视为密码学术语，根据上下文传达两个不同的概念：
- en: '*Message/payload authentication*—You’re proving that a message is genuine and
    hasn’t been modified since its creation. (For example, are these messages authenticated
    or can someone tamper with them?)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息/有效载荷认证*—你正在证明一条消息是真实的，并且自其创建以来没有被修改过。 （例如，这些消息是否已经认证，还是有人可能篡改它们？）'
- en: '*Origin/entity/identity authentication*—You’re proving that an entity really
    is who they say they are. (For example, am I actually communicating with [google.com](http://google.com)?)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*源/实体/身份认证*—你正在证明一个实体确实是他们声称的那个人。 （例如，我是否真的在与[google.com](http://google.com)通信？）'
- en: 'Bottom line: authentication is about proving that something is what it is supposed
    to be, and that something can be a person, a message, or something else. In this
    chapter, I will use the term *authentication* only to refer to identifying people
    or machines. In other words, *identity* authentication. By the way, you already
    saw a lot about this type of authentication:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 底线：认证是关于证明某物是它应该是的，而某物可以是人、消息或其他东西。 在本章中，我将仅使用术语*认证*来指代识别人或机器。 换句话说，*身份*认证。
    顺便说一句，你已经看到了很多关于这种类型认证的内容：
- en: In chapter 9, on secure transport, you learned that machines can authenticate
    other machines at scale by using public key infrastructures (PKIs).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第9章，关于安全传输，你学到了机器如何通过使用公钥基础设施（PKI）来大规模认证其他机器。
- en: In chapter 10, on end-to-end encryption, you learned about ways humans can authenticate
    one another at scale by using *trust on first use* (TOFU) (and verifying later)
    or by using the web of trust (WOT) techniques.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 10 章中，关于端到端加密，您了解了人类如何通过使用*首次使用信任*（TOFU）（然后稍后验证）或使用信任网络（WOT）技术来规模化认证彼此。
- en: In this chapter, you will learn the following two other cases not previously
    mentioned. (I recap these in figure 11.1.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习到前面未提及的其他两种情况。（我在图 11.1 中进行了回顾。）
- en: '*User authentication*, or how machines authenticate humans—beep boop'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户认证*，或者说机器如何认证人类——滴滴滴滴'
- en: '*User-aided authentication*, or how humans can help machines authenticate one
    another'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户辅助认证*，或者说人类如何帮助机器认证彼此'
- en: '![](../Images/11_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_01.jpg)'
- en: Figure 11.1 In this book, I talk about origin authentication in three types
    of scenarios. User authentication happens when a device authenticates a human
    being. Machine authentication happens when a machine authenticates another machine.
    User-aided authentication happens when a human is involved in a machine authenticating
    another machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 在本书中，我讨论了三种情景下的源认证。当设备认证人类时，就发生了用户认证。当机器认证另一台机器时，就发生了机器认证。当一个人参与机器认证另一台机器时，就发生了用户辅助认证。
- en: Another aspect of identity authentication is the identity part. Indeed, how
    do we define someone like Alice in a cryptographic protocol? How can a machine
    authenticate you and me? There is, unfortunately (or fortunately), an inherent
    gap between flesh and bits. To bridge reality and the digital world, we always
    assume that Alice is the only one who knows some secret data, and to prove her
    identity, she has to demonstrate knowledge of that secret data. For example, she
    could be sending her password or she could be signing a random challenge using
    the private key associated with her public key.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 身份认证的另一个方面是身份部分。确实，我们如何在密码协议中定义像爱丽丝这样的人？机器如何认证你和我？遗憾的是（或者幸运的是），肉体和比特之间存在固有的差距。为了弥合现实和数字世界之间的鸿沟，我们总是假设爱丽丝是唯一知道一些秘密数据的人，为了证明她的身份，她必须证明她知道那些秘密数据。例如，她可以发送她的密码，或者她可以使用与她的公钥相关联的私钥签署一个随机挑战。
- en: Alright, that’s enough intro. If this section didn’t make too much sense, the
    multitude of examples that are to follow will. Let’s now first have a look at
    the many ways machines have found to authenticate us humans!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，介绍就到此为止。如果这一部分让你感到有些迷糊，接下来的众多例子会让你明白的。现在让我们首先看看机器找到的认证我们人类的多种方式！
- en: 11.2 User authentication, or the quest to get rid of passwords
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 用户认证，或摆脱密码的追求
- en: The first part of this chapter is about how machines authenticate humans or,
    in other words, *user authentication*. There are many ways to do this, and no
    solution is a panacea. But in most user authentication scenarios, we assume that
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分是关于机器如何认证人类，换句话说就是*用户认证*。有很多方法可以做到这一点，没有一种解决方案是万能的。但在大多数用户认证场景中，我们假设
- en: The server is already authenticated.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器已经经过认证。
- en: The user shares a secure connection with it.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户与之共享安全连接。
- en: For example, you can imagine that the server is authenticated to the user via
    the web public key infrastructure (PKI) and that the connection is secured via
    TLS (both covered in chapter 9). In a sense, most of this section is about upgrading
    a one-way authenticated connection to a mutually-authenticated connection as figure
    11.2 illustrates.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以想象服务器通过网络公钥基础设施（PKI）对用户进行了认证，并且连接通过 TLS（在第 9 章中都有涉及）。在某种意义上，本节的大部分内容都是关于将单向认证连接升级为双向认证连接，就像图
    11.2 所示的那样。
- en: '![](../Images/11_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_02.jpg)'
- en: Figure 11.2 User authentication typically happens over a channel that is already
    secured but where only the server is authenticated. A typical example is when
    you browse the web using HTTPS and log into a web page using your credentials.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 用户认证通常发生在已经安全的通道上，但只有服务器经过认证的情况。一个典型的例子是当您使用 HTTPS 浏览网页并使用您的凭据登录网页时。
- en: 'I have to warn you: user authentication is a vast land of broken promises.
    You must have used passwords many times to authenticate to different web pages,
    and your own experience probably resembles something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须警告你：用户认证是一个充满了空头支票的广阔领域。您肯定已经多次使用密码对不同的网页进行认证，而您自己的经历可能类似于这样：
- en: You register with a username and password on a website.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在网站上注册了用户名和密码。
- en: You log into the website using your new credentials.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新凭据登录网站。
- en: You change your password after recovering your account or because the website
    forces you to.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您恢复您的账户或者因为网站强制要求时，您需要更改密码。
- en: If you’re out of luck, your password (or a hash of it) is leaked in a series
    of database breaches.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运气不佳，您的密码（或其哈希值）可能会在一系列数据库泄露中泄露。
- en: Sound familiar?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来耳熟吗？
- en: Note I will ignore *password/account recovery* in this chapter, as they have
    little to do with cryptography. Just know that they are often tied to the way
    you first registered. For example, if you registered with the IT department at
    your workplace, then you’ll probably have to go see them if you lose your password,
    and they can be the weakest link in your system if you are not careful. Indeed,
    if I can recover your account by calling a number and giving someone your birth
    date, then no amount of cool cryptography at login time will help.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章节将忽略*密码/账户恢复*，因为它们与密码学关系不大。只需知道它们通常与您最初注册的方式相关联。例如，如果您在工作场所的IT部门注册，那么如果您忘记密码，您可能需要去找他们，如果不小心的话，他们可能是系统中最薄弱的环节。事实上，如果我可以通过拨打一个号码并告诉某人您的生日来恢复您的账户，那么在登录时进行的任何酷炫的密码学都无济于事。
- en: A naive way to implement the previous user authentication flow is to store the
    user password at registration and then ask the user for it at login time. As mentioned
    in chapter 3, once successfully authenticated, a user is typically given a cookie
    that can be sent in every subsequent request instead of a username and password.
    But wait; if the server stores your password in cleartext, then any breach of
    its databases reveals your password to the attackers. These attackers will then
    be able to use it to log into any websites where you use the same password to
    register.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实现先前用户认证流程的一个天真的方法是在注册时存储用户密码，然后在登录时要求用户输入密码。正如第3章所述，一旦成功认证，用户通常会获得一个可以在每个后续请求中发送的cookie，而不是用户名和密码。但是等等；如果服务器以明文形式存储您的密码，那么其数据库的任何泄露都会将您的密码暴露给攻击者。这些攻击者随后将能够使用它登录您在其中使用相同密码注册的任何网站。
- en: A better way to store passwords would be to use a *password hashing* algorithm
    like the standardized Argon2 you’ve learned about in chapter 2\. This would effectively
    prevent a smash-and-grab type of attack on the database to leak your password,
    although an intruder that overextends their welcome would still be able to see
    your password every time you log in. Yet, a lot of websites and companies still
    store passwords in cleartext.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的存储密码的方法是使用像您在第2章中学到的标准化的Argon2这样的*密码哈希*算法。这将有效地防止对数据库进行的一种破坏性攻击，以泄露您的密码，尽管一个过度进入的入侵者仍然可以在您每次登录时看到您的密码。然而，许多网站和公司仍然以明文形式存储密码。
- en: Exercise
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Sometimes applications attempt to fix the issue of the server learning about
    the user passwords at registration by having the client hash (perhaps with a password
    hash) the password before sending it to the server. Can you determine if this
    really works?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序试图通过让客户端在发送密码之前对密码进行哈希处理（也许使用密码哈希）来解决服务器在注册时了解用户密码的问题。您能确定这是否真的有效吗？
- en: Moreover, humans are naturally bad at passwords. We are usually most comfortable
    with small and easy-to-remember passwords. And, if possible, we would want to
    just reuse the same password everywhere.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，人类在密码方面天生就不擅长。我们通常更喜欢使用简单易记的短密码。而且，如果可能的话，我们希望可以在所有地方都重复使用相同的密码。
- en: '*81% of all hacking-related breaches leverage stolen or weak passwords*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*81%的黑客入侵事件利用了被盗或弱密码*。'
- en: —Verizon Data Breach Report (2017)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: —Verizon数据泄露报告（2017）
- en: The problem of weak passwords and password reuse has led to many silly and annoying
    design patterns that attempt to force users to take passwords more seriously.
    For example, some websites require you to use special characters in your passwords
    or force you to change your password every 6 months, and so on. Furthermore, many
    protocols attempt to “fix” passwords or to get rid of them altogether. Every year,
    new security experts seem to think that the concept of “password” is dead. Yet,
    it is still the most widely used user authentication mechanism.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 弱密码和密码重用的问题导致了许多愚蠢和恼人的设计模式，试图迫使用户更加认真对待密码。例如，一些网站要求您在密码中使用特殊字符，或者强制您每6个月更改一次密码，等等。此外，许多协议试图“修复”密码或完全摆脱它们。每年，新的安全专家似乎都认为“密码”这个概念已经过时。然而，它仍然是最广泛使用的用户认证机制。
- en: '![](../Images/11_02_UN01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_02_UN01.jpg)'
- en: So here you have it, passwords are probably here to stay. Yet, there exist many
    protocols that improve or replace passwords. Let’s take a look at those.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里，密码可能会一直存在。然而，存在许多可以改进或替代密码的协议。让我们看看这些。
- en: '11.2.1 One password to rule them all: Single sign-on (SSO) and password managers'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 一切由一个密码控制：单点登录（SSO）和密码管理器
- en: 'OK, password reuse is bad, so what can we do about it? Naively, users could
    use different passwords for different websites, but there are two problems with
    this approach:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，密码重用是不好的，那我们能做些什么呢？天真地，用户可以为不同的网站使用不同的密码，但这种方法有两个问题：
- en: Users are bad at creating many different passwords.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不擅长创建许多不同的密码。
- en: The mental load required to remember multiple passwords is impractical.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住多个密码所需的心理负担是不切实际的。
- en: 'To alleviate these concerns, two solutions have been widely adopted:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这些问题，已经广泛采用了两种解决方案：
- en: '*Single sign-on* (SSO)—The idea of SSO is to allow users to connect to many
    different services by proving that they own the account of a single service. This
    way, the user only has to remember the password associated with that one service
    in order to be able to connect to many services. Think “connect with Facebook”
    type of buttons as figure 11.3 illustrates.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单点登录*（SSO）—SSO的理念是允许用户通过证明他们拥有单个服务的帐户来连接到许多不同的服务。这样，用户只需记住与该服务关联的密码，就能连接到许多服务。想象一下“使用Facebook登录”类型的按钮，正如图11.3所示。'
- en: '*Password managers*—The previous SSO approach is convenient if the different
    services you use all support it, but this is obviously not scalable for scenarios
    like the web. A better approach in these extreme cases is to improve the clients
    as opposed to attempting to fix the issue on the server side. Nowadays, modern
    browsers have built-in password managers that can suggest complex passwords when
    you register on new websites, and they can remember all of your passwords as long
    as you remember one master password.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密码管理器*—如果您使用的不同服务都支持前述SSO方法，那么这种方法很方便，但显然对于像网页这样的场景来说并不可扩展。在这些极端情况下，一个更好的方法是改进客户端，而不是试图在服务器端解决问题。如今，现代浏览器内置了密码管理器，当您在新网站注册时可以建议复杂的密码，并且只要您记住一个主密码，它们就可以记住您的所有密码。'
- en: '![](../Images/11_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_03.jpg)'
- en: Figure 11.3 An example of single sign-on (SSO) on the web. By having an account
    on Facebook or Google, a user can connect to new services (in this example, Airbnb)
    without having to think about a new password.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 网页上单点登录（SSO）的示例。通过在Facebook或Google上拥有帐户，用户可以连接到新服务（在此示例中是Airbnb），而无需考虑新密码。
- en: 'The concept of SSO is not new in the enterprise world, but its success with
    normal end-users is relatively recent. Today, two protocols are the main competitors
    when it comes to setting up SSO:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 单点登录（SSO）的概念在企业世界并不新鲜，但它在普通终端用户中的成功是比较近期的。如今，在建立SSO时，有两个主要竞争者协议：
- en: '*Security Assertion Markup Language 2.0* (SAML)—A protocol using the Extensible
    Markup Language (XML) encoding.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全断言标记语言2.0*（SAML）—一种使用可扩展标记语言（XML）编码的协议。'
- en: '*OpenID Connect* (OIDC)—An extension to the OAuth 2.0 (RFC 6749) authorization
    protocol using the JavaScript Object Notation (JSON) encoding.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenID Connect*（OIDC）—OAuth 2.0（RFC 6749）授权协议的扩展，使用JavaScript对象表示法（JSON）编码。'
- en: SAML is still widely used, mostly in an enterprise setting, but it is (at this
    point) a legacy protocol. OIDC, on the other hand, can be seen everywhere on web
    and mobile applications. You most likely already used it!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SAML仍然被广泛使用，主要是在企业环境中，但（目前）它是一种遗留协议。另一方面，OIDC可以在网页和移动应用程序中随处可见。你很可能已经使用过它！
- en: Authentication protocols are often considered hard to get right. OAuth2, the
    protocol OIDC relies on, is notorious for being easy to misuse. On the other hand,
    OIDC is well specified (see [https://openid.net](https://openid.net)). Make sure
    that you follow the standards and that you look at best practices, as this can
    save you from a lot of trouble.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 认证协议通常被认为很难正确使用。OIDC依赖的协议OAuth2以易被滥用而臭名昭著。另一方面，OIDC被很好地规范化（参见[https://openid.net](https://openid.net)）。确保你遵循标准并查看最佳实践，因为这可以避免许多麻烦。
- en: Note Here’s another example of a pretty large company deciding *not* to follow
    this advice. In May 2020, the Sign-in with Apple SSO flow that took a departure
    from OIDC was found to be vulnerable. Anyone could have obtained a valid ID token
    for any Apple account just by querying Apple’s servers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 这里有另一个例子，一个相当大的公司决定*不*遵循这些建议。2020年5月，苹果登录SSO流程不遵循OIDC的做法被发现存在漏洞。任何人都可以通过查询苹果的服务器获得任何苹果账户的有效ID令牌。
- en: SSO is great for users as it reduces the number of passwords they have to manage,
    but it does not remove passwords altogether. The user still has to use passwords
    to connect to OIDC providers. So next, let’s see how cryptography can help hide
    passwords.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SSO对用户很有好处，因为它减少了他们需要管理的密码数量，但它并没有完全消除密码。用户仍然必须使用密码连接到OIDC提供者。接下来，让我们看看密码学如何帮助隐藏密码。
- en: 11.2.2 Don’t want to see their passwords? Use an asymmetric password-authenticated
    key exchange
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 不想看到他们的密码？使用非对称密码身份验证密钥交换
- en: The previous section surveyed solutions that attempt to simplify identity management
    for users, allowing them to authenticate to multiple services using only one account
    linked to a single service. While protocols like OIDC are great, as they effectively
    decrease the number of passwords users have to manage, they don’t change the fact
    that some service still needs to see the user’s password in cleartext. Even if
    the password is stored after password hashing it, it is still sent in clear every
    time the user registers, changes their password, or logs in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节调查了试图简化用户身份管理的解决方案，允许他们使用仅链接到单个服务的一个帐户来认证到多个服务。虽然OIDC等协议很好，因为它们有效地减少了用户需要管理的密码数量，但它们并不改变某些服务仍然需要以明文形式查看用户密码的事实。即使密码在密码哈希后存储，每次用户注册、更改密码或登录时仍然以明文形式发送。
- en: Cryptographic protocols called *asymmetric (or augmented) password-authenticated
    key exchanges* (PAKEs) attempt to provide user authentication without having users
    ever communicate their passwords directly to the server. This contrasts with *symmetric
    or balanced PAKEs* protocols, where both sides know the password.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 称为*非对称（或增强型）密码身份验证密钥交换*（PAKEs）的加密协议试图提供用户身份验证，而无需用户直接将其密码传递给服务器。这与*对称或平衡的PAKEs*协议形成对比，后者双方都知道密码。
- en: 'The most popular asymmetric PAKE at the moment is the *Secure Remote Password*
    (SRP) protocol, which was standardized for the first time in 2000 in RFC 2944
    (“Telnet Authentication: SRP”) and later integrated into TLS via RFC 5054 (“Using
    the Secure Remote Password (SRP) Protocol for TLS Authentication”). It is quite
    an old protocol and has a number of flaws. For example, if the registration flow
    is intercepted by a MITM attacker, the attacker would then be able to impersonate
    and log in as the victim. It also does not play well with modern protocols as
    it cannot be instantiated on elliptic curves, and worse, it is incompatible with
    TLS 1.3.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '目前最流行的非对称PAKE是*安全远程密码*（SRP）协议，该协议于2000年首次标准化于RFC 2944（“Telnet Authentication:
    SRP”），后来通过RFC 5054（“Using the Secure Remote Password (SRP) Protocol for TLS Authentication”）集成到TLS中。它是一个相当古老的协议，并且存在许多缺陷。例如，如果注册流程被中间人攻击者拦截，那么攻击者将能够冒充并登录为受害者。它还不能很好地与现代协议配合使用，因为它无法在椭圆曲线上实例化，更糟糕的是，它与TLS
    1.3不兼容。'
- en: 'Since the invention of SRP, many asymmetric PAKEs have been proposed and standardized.
    In the summer of 2019, the Crypto Forum Research Group (CFRG) of the IETF started
    a PAKE selection process with the goal to pick one algorithm to standardize for
    each category of PAKEs: symmetric/balanced and asymmetric/ augmented. In March
    2020, the CFRG announced the end of the PAKE selection process, selecting'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 自SRP发明以来，已经提出并标准化了许多非对称PAKE。2019年夏季，IETF的Crypto Forum Research Group（CFRG）开始了一个PAKE选择过程，目标是为每个PAKE类别（对称/平衡和非对称/增强型）选择一个算法进行标准化。2020年3月，CFRG宣布PAKE选择过程结束，选择
- en: '*CPace*—The recommended symmetric/balanced PAKE, invented by Haase and Benoît
    Labrique'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CPace*——由Haase和Benoît Labrique发明的推荐的对称/平衡PAKE'
- en: '*OPAQUE*—The recommended asymmetric/augmented PAKE, invented by Stanislaw Jarecki,
    Hugo Krawczyk, and Jiayu Xu'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OPAQUE*——由Stanislaw Jarecki、Hugo Krawczyk和Jiayu Xu发明的推荐的非对称/增强型PAKE'
- en: In this section, I talk about OPAQUE, which (in early 2021) is still in the
    process of being standardized. In the second section of this chapter, you will
    learn more about symmetric PAKEs and CPace.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论OPAQUE，在2021年初仍在标准化过程中。在本章的第二节中，您将了解更多关于对称PAKEs和CPace的信息。
- en: 'OPAQUE takes its name from the homonym *O-PAKE*, where *O* refers to the term
    *oblivious*. This is because OPAQUE relies on a cryptographic primitive that I
    have not yet mentioned in this book: an *oblivious pseudorandom function* (OPRF).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: OPAQUE 从同音异义词 *O-PAKE* 中取其名称，其中 *O* 指的是术语 *oblivious*。这是因为 OPAQUE 依赖于本书中尚未提到的密码原语：一个
    *oblivious pseudorandom function*（OPRF）。
- en: Oblivious pseudorandom functions (OPRFs)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无意识伪随机函数（OPRFs）
- en: 'OPRFs are a two-participant protocol that mimics the PRFs that you learned
    about in chapter 3\. As a reminder, a PRF is somewhat equivalent to what one would
    expect of a MAC: it takes a key and an input and gives you a totally random output
    of a fixed length.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: OPRFs 是一个模拟第三章中所学的 PRFs 的两方协议。作为提醒，PRF 在某种程度上等同于人们对 MAC 的预期：它接受一个密钥和一个输入，并给出一个固定长度的完全随机输出。
- en: Note The term *oblivious* in cryptography generally refers to protocols where
    one party computes a cryptographic operation without knowing the input provided
    by another party.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：密码学中的术语 *oblivious* 通常指的是一个参与方计算加密操作而不知道另一方提供的输入的协议。
- en: 'Here is how an OPRF works at a high level:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 OPRF 的高层次工作方式：
- en: Alice wants to compute a PRF over an input but wants the input to remain secret.
    She “blinds” her input with a random value (called a *blinding factor*) and sends
    this to Bob.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 想要对输入计算一个 PRF，但希望输入保持秘密。她使用一个随机值（称为 *blinding factor*） “盲化” 她的输入，并将其发送给
    Bob。
- en: Bob runs the OPRFs on this blinded value with his secret key, but the output
    is still blinded so it’s useless for Bob. Bob then sends this back to Alice.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 使用他的秘钥在这个被盲化的数值上运行 OPRFs，但输出仍然被盲化，所以对 Bob 毫无用处。Bob 然后将这个返回给 Alice。
- en: Alice finally “unblinds” the result using the same blinding factor she previously
    used to obtain the real output.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 最后使用与之前用于获取真实输出相同的盲化因子 “解盲” 结果。
- en: It is important to note that every time Alice wants to go over this protocol,
    she has to create a different blinding factor. But no matter what blinding factor
    she uses, as long as she uses the same input, she will always obtain the same
    result. I illustrate this in figure 11.4.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，每次 Alice 想要执行这个协议时，她都必须创建一个不同的盲化因子。但无论她使用什么盲化因子，只要她使用相同的输入，她总是会得到相同的结果。我在图
    11.4 中进行了说明。
- en: '![](../Images/11_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_04.jpg)'
- en: Figure 11.4 An oblivious PRF (OPRF) is a construction that allows one party
    to compute a PRF over the input of another party without learning that input.
    To do this, Alice first generates a random blinding factor, then blinds her input
    with that before sending it to Bob. Bob uses his secret key to compute the PRF
    over the blinded value, then sends the blinded output to Alice who can unblind
    it. The result does not depend on the value of the blinding factor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 一个无意识 PRF（OPRF）是一种构造，允许一个参与方在不了解该参与方输入的情况下计算 PRF。为了实现这一点，Alice 首先生成一个随机的盲化因子，然后使用它来盲化她的输入，然后发送给
    Bob。Bob 使用他的秘密密钥在被盲化的数值上计算 PRF，然后将盲化输出发送给 Alice，Alice 可以对其进行解盲。结果不依赖于盲化因子的值。
- en: 'Here’s an example of an OPRF protocol implemented in a group where the discrete
    logarithm problem is hard:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在离散对数问题难度高的群中实现的 OPRF 协议的一个示例：
- en: Alice converts her input to a group element *x*.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 将她的输入转换为一个群元素 *x*。
- en: Alice generates a random blinding factor *r*.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 生成一个随机的盲化因子 *r*。
- en: Alice blinds her input by computing *blinded_input* = *x*^r.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 通过计算 *blinded_input* = *x*^r 来盲化她的输入。
- en: Alice sends the *blinded_input* to Bob.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 将 *blinded_input* 发送给 Bob。
- en: Bob computes *blinded_output* = *blinded_input*^k, where *k* is the secret key.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 计算 *blinded_output* = *blinded_input*^k，其中 *k* 是秘密密钥。
- en: Bob sends the result back to Alice.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 将结果发送回给 Alice。
- en: Alice can then unblind the produced result by computing *output* = *blinded_output*^(1/*r*)
    = *x*^k, where 1/*r* is the inverse of *r*.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 然后可以通过计算 *output* = *blinded_output*^(1/*r*) = *x*^k 来解盲产生的结果，其中 1/*r*
    是 *r* 的倒数。
- en: How OPAQUE uses this interesting construction is the whole trick behind the
    asymmetric PAKE.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: OPAQUE 如何使用这个有趣的构造是非对称 PAKE 的整个技巧。
- en: The OPAQUE asymmetric PAKE, how does it work?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: OPAQUE 非对称 PAKE，它是如何工作的？
- en: The idea is that we want a client, let’s say Alice, to be able to do an authenticated
    key exchange with some server. We also assume that Alice already knows the server’s
    public key or already has a way to authenticate it (the server could be an HTTPS
    website and, thus, Alice can use the web PKI). Let’s see how we could build this
    to progressively understand how OPAQUE works.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的想法是，我们希望客户端，比如 Alice，能够与某个服务器进行经过身份验证的密钥交换。我们还假设 Alice 已经知道服务器的公钥或已经有一种方法对其进行身份验证（服务器可以是
    HTTPS 网站，因此 Alice 可以使用 Web PKI）。让我们看看如何逐步构建这个来逐渐理解 OPAQUE 的工作原理。
- en: '*First idea:* use public key cryptography to authenticate Alice’s side of the
    connection. If Alice owns a long-term key pair and the server knows the public
    key, she can simply use her private key to perform a mutually authenticated key
    exchange with the server, or she can sign a challenge given by the server. Unfortunately,
    an asymmetric private key is too long, and Alice can only remember her password.
    She could store a key pair on her current device, but she also wants to be able
    to log in from another device later.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一个想法：* 使用公钥密码学来验证 Alice 的连接一侧。如果 Alice 拥有长期密钥对并且服务器知道公钥，她可以简单地使用她的私钥与服务器进行相互验证的密钥交换，或者她可以签署服务器给出的挑战。不幸的是，非对称私钥太长了，Alice
    只能记住她的密码。她可以在当前设备上存储一对密钥，但她也想以后能够从另一台设备登录。'
- en: '*Second idea:* Alice can derive the asymmetric private key from her password,
    using a password-based key derivation function (KDF) like Argon2, which you learned
    about in chapter 2 and chapter 8\. Alice’s public key could then be stored on
    the server. If we want to avoid someone testing a password against the whole database
    in case of a database breach, we can have the server supply each user with a different
    salt that they have to use with the password-based KDF.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二个想法：* Alice 可以使用类似 Argon2 这样的基于密码的密钥派生函数（KDF）从她的密码派生非对称私钥，你在第 2 章和第 8 章学到了。然后，Alice
    的公钥可以存储在服务器上。如果我们想要在数据库泄露的情况下避免有人对整个数据库进行密码测试，我们可以让服务器为每个用户提供一个不同的盐，他们必须将其与基于密码的
    KDF 一起使用。'
- en: 'This is pretty good already, but there’s one attack that OPAQUE wants to discard:
    a *precomputation attack*. I can try to log in as you, receive your salt, and
    then precompute a huge number of asymmetric private keys and their associated
    public keys *offline*. The day the database is compromised, I can quickly see
    if I can find your public key and the associated password in my huge list of precomputed
    asymmetric public keys.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经相当不错了，但 OPAQUE 想要抛弃一种攻击：*预计算攻击*。我可以尝试以你的身份登录，接收到你的盐，然后*离线*预计算大量非对称私钥及其关联的公钥。在数据库被破坏的那一天，我可以迅速查看是否可以在我的大量预计算的非对称公钥列表中找到您的公钥和关联的密码。
- en: '*Third idea:* This is where the main trick of OPAQUE comes in! We can use the
    OPRF protocol with Alice’s password in order to derive the asymmetric private
    key. If the server uses a different key per user, that’s as good as having salts
    (attacks can only target one user at a time). This way, an attacker that wants
    to precompute asymmetric private keys based on guesses of our password has to
    perform *online* queries (preventing offline brute force attacks). Online queries
    are good because they can be rate-limited (preventing more than 10 sign-in attempts
    per hour, for example) in order to prevent these kinds of online brute force attacks.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*第三个想法：* 这就是 OPAQUE 的主要技巧所在！我们可以使用 OPRF 协议和 Alice 的密码来派生非对称私钥。如果服务器为每个用户使用不同的密钥，那么这就等同于有盐（攻击只能针对一个用户）。这样，想要基于我们密码的猜测预先计算非对称私钥的攻击者必须执行*在线*查询（防止离线暴力攻击）。在线查询很好，因为它们可以进行速率限制（例如，每小时不超过
    10 次登录尝试），以防止这种类型的在线暴力攻击。'
- en: 'Note that this is actually not how OPAQUE works: instead of having the user
    derive an asymmetric private key, OPAQUE has the user derive a symmetric key.
    The symmetric key is then used to encrypt a backup of your asymmetric key pair
    and some additional data (which can include the server’s public key, for example).
    I illustrate the algorithm in figure 11.5.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这实际上并不是 OPAQUE 的工作方式：与其让用户派生非对称私钥，OPAQUE 让用户派生对称密钥。然后，对称密钥用于加密您的非对称密钥对的备份和一些附加数据（例如可以包括服务器的公钥）。我在图
    11.5 中说明了算法。
- en: '![](../Images/11_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11_05.jpg)'
- en: Figure 11.5 To register to a server using OPAQUE, Alice generates a long-term
    key pair and sends her public key to the server, which stores it and associates
    it with Alice’s identity. She then uses the OPRF protocol to obtain a strong symmetric
    key from her password and sends an encrypted backup of her key pair to the server.
    To log in, she obtains her encrypted key pair from the server, then performs the
    OPRF protocol with her password to obtain a symmetric key capable of decrypting
    her key pair. All that’s left is to perform a mutually authenticated key exchange
    (or possibly sign a challenge) with this key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 使用 OPAQUE 注册到服务器时，Alice 生成一个长期密钥对并将其公钥发送到服务器，服务器将其存储并与 Alice 的身份关联起来。然后，她使用
    OPRF 协议从她的密码获取一个强对称密钥，并将密钥对的加密备份发送给服务器。要登录，她从服务器获取她的加密密钥对，然后使用她的密码执行 OPRF 协议以获取能够解密她的密钥对的对称密钥。现在只需使用这个密钥执行一个互认证的密钥交换（或者可能签署一个挑战）。
- en: Before going to the next section, let’s review what you’ve learned here. Figure
    11.6 illustrates this.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，让我们回顾一下你在这里学到的内容。图11.6对此进行了说明。
- en: '![](../Images/11_06.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_06.jpg)'
- en: Figure 11.6 Passwords are a handy way to authenticate users as they live in
    someone’s head and can be used on any device. On the other hand, users have trouble
    creating strong passwords, and because users tend to reuse passwords across websites,
    password breaches can be damaging. SSO allows you to connect to many services
    using one (or a few) service(s), while asymmetric (or augmented) password-authenticated
    key exchanges allow you to authenticate without the server ever learning your
    real password.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 密码是验证用户身份的方便方式，因为它们存在于某人的头脑中，并且可以在任何设备上使用。另一方面，用户很难创建强密码，因为用户往往在网站之间重复使用密码，密码泄漏可能会造成严重损失。SSO
    允许您使用一个（或几个）服务连接到多个服务，而不对称（或增强）密码验证密钥交换允许您在服务器不了解真实密码的情况下进行身份验证。
- en: '11.2.3 One-time passwords aren’t really passwords: Going passwordless with
    symmetric keys'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 一次性密码并不真的是密码：使用对称密钥实现无密码登录
- en: Alright, so far so good. You’ve learned about different protocols that applications
    can leverage to authenticate users with passwords. But, as you’ve heard, passwords
    are also not that great. They are vulnerable to brute force attacks, tend to be
    reused, stolen, and so on. What is available to us if we can afford to avoid using
    passwords?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，到目前为止一切都很好。你已经了解了应用程序可以利用的不同协议来使用密码对用户进行身份验证。但是，你可能已经听说了，密码也不是那么好。它们容易受到暴力破解攻击，往往被重复使用，被窃取等等。如果我们可以避免使用密码，我们可以使用什么？
- en: 'And the answer is—keys! And, as you know, there are two types of keys in cryptography
    and both types can be useful:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 答案就是——密钥！正如你所知，在密码学中有两种类型的密钥，而且两种类型都可能很有用：
- en: Symmetric keys
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称密钥
- en: Asymmetric keys
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不对称密钥
- en: This section goes over solutions that are based on symmetric keys, while the
    next section goes over solutions based on asymmetric keys. Let’s imagine that
    Alice registers with a service using a symmetric key (often generated by the server
    and communicated to you via a QR code). A naive way to authenticate Alice later
    would be to simply ask her to send the symmetric key. This is, of course, not
    great, as a compromise of her secret would give an attacker unlimited access to
    her account. Instead, Alice can derive what are called *one-time passwords* (OTPs)
    from the symmetric key and send those in place of the longer-term symmetric key.
    Even though an OTP is not a password, the name indicates that an OTP can be used
    in place of a password and warns that it should never be reused.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍基于对称密钥的解决方案，而下一节介绍基于不对称密钥的解决方案。让我们想象一下，Alice 使用对称密钥（通常由服务器生成并通过 QR 码传输给你）注册了一个服务。后来验证
    Alice 的一个天真的方法是简单地要求她发送对称密钥。当然，这并不好，因为她的秘密泄漏将给攻击者无限制的访问权限。相反，Alice 可以从对称密钥中派生出所谓的*一次性密码*（OTPs），并在长期对称密钥的位置发送这些
    OTP。尽管 OTP 不是密码，但其名称表明 OTP 可以代替密码使用，并警告不应重复使用。
- en: 'The idea behind OTP-based user authentication is straightforward: your security
    comes from the knowledge of a (usually) 16- to 32-byte uniformly random symmetric
    key instead of a low-entropy password. This symmetric key allows you to generate
    OTPs on demand as figure 11.7 illustrates.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 OTP 的用户身份验证背后的想法很简单：你的安全性来自于一个（通常是）16到32字节的均匀随机对称密钥的知识，而不是一个低熵密码。这个对称密钥允许你按需生成
    OTP，如图11.7所示。
- en: '![](../Images/11_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_07.jpg)'
- en: Figure 11.7 A one-time password (OTP) algorithm allows you to create as many
    one-time passwords as you want from a symmetric key and some additional data.
    The additional data is different, depending on the OTP algorithm.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 一次性密码（OTP）算法允许您从对称密钥和一些附加数据创建任意数量的一次性密码。附加数据不同，取决于OTP算法。
- en: 'OTP-based authentication is most often implemented in mobile applications (see
    figure 11.8 for a popular example) or in security keys (a small device that you
    can plug in the USB port of your computer). There are two main schemes that one
    can use to produce OTPs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: OTP身份验证通常在移动应用程序中实现（请参见图11.8中的一个热门示例）或安全密钥中（这是一个可以插入计算机USB端口的小设备）。可以使用两种主要方案来生成OTP：
- en: The HMAC-based one-time password (HOTP) algorithm, standardized in RFC 4226,
    which is an OTP algorithm where the additional data is a counter.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于HMAC的一次性密码（HOTP）算法，标准化在RFC 4226中，这是一种额外数据为计数器的OTP算法。
- en: The time-based one-time password (TOTP) algorithm, standardized in RFC 6238,
    which is an OTP algorithm where the additional data is the time.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的一次性密码（TOTP）算法，标准化在RFC 6238中，这是一种额外数据为时间的OTP算法。
- en: Most applications nowadays use TOTP because HOTP requires both the client and
    the server to store a state (a counter). Storing a state can lead to issues if
    one side falls out of synchrony and cannot produce (or validate) legitimate OTPs
    anymore.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序现在使用TOTP，因为HOTP需要客户端和服务器都存储状态（计数器）。如果一方失去同步，无法再生成（或验证）合法的OTP，存储状态可能会导致问题。
- en: '![](../Images/11_08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11_08.jpg)'
- en: Figure 11.8 A screenshot of the Google Authenticator mobile app. The application
    allows you to store unique per-application symmetric keys that can then be used
    with the TOTP scheme to generate 6-digit, one-time passwords (OTPs), valid only
    for 30 seconds.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 Google Authenticator移动应用程序的屏幕截图。该应用程序允许您存储唯一的应用程序专用对称密钥，然后可与TOTP方案一起使用生成6位数的一次性密码（OTP），仅有效30秒。
- en: 'In most cases, this is how TOTP works:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这就是TOTP的工作方式：
- en: '*When registering, the service communicates a symmetric key to the user (perhaps
    using a QR code).* The user then adds this key to a TOTP application.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在注册时，服务向用户通信一个对称密钥（也许使用QR码）。* 然后，用户将此密钥添加到TOTP应用程序中。'
- en: '*When logging in, the user can use the TOTP application to compute a one-time
    password.* This is done by computing *HMAC*(*symmetric_key*, *time*), where *time*
    represents the current time (rounded to the minute in order to make a one-time
    password valid for 60 seconds). Then'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在登录时，用户可以使用TOTP应用程序计算一次性密码。* 这是通过计算*HMAC*（*symmetric_key*，*time*）来完成的，其中*time*表示当前时间（四舍五入到分钟，以使一次性密码在60秒内有效）。然后'
- en: a) The TOTP application displays to the user the derived one-time password,
    truncated and in a human-readable base (for example, reduced to 6 characters in
    base 10 to make it all digits).
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) TOTP应用程序向用户显示派生的一次性密码，截断并以人类可读的基数显示（例如，缩减为10进制的6个字符，使其全部为数字）。
- en: b) The user either copies or types the one-time password into the relevant application.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 用户将一次性密码复制或键入到相关应用程序中。
- en: c) The application retrieves the user’s associated symmetric key and computes
    the one-time password in the same way as the user did. If the result matches the
    received one-time password, the user is successfully authenticated.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 应用程序检索用户关联的对称密钥，并以与用户相同的方式计算一次性密码。如果结果与接收到的一次性密码匹配，则用户成功验证身份。
- en: Of course, the comparison between the user’s OTP and the one computed on the
    server must be done in constant time. This is similar to MAC authentication tag
    checks. I demonstrate this flow in figure 11.9.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，用户的一次性密码（OTP）与服务器计算的密码必须在恒定时间内进行比较。这类似于MAC身份验证标签检查。我在图11.9中展示了这个流程。
- en: '![](../Images/11_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11_09.jpg)'
- en: Figure 11.9 Alice registers with example.com using TOTP as authentication. She
    imports a symmetric key from the website into her TOTP application. Later, she
    can ask the application to compute a one-time password for example.com and use
    it to authenticate with the website. The website, example.com, fetches the symmetric
    key associated with Alice and computes the one-time password using HMAC and the
    current time. The website next compares the one-time password in constant time
    with what Alice sends.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 Alice 使用 TOTP 作为认证在 example.com 上注册。她将网站的对称密钥导入到她的 TOTP 应用程序中。稍后，她可以要求应用程序为
    example.com 计算一次性密码，并将其用于与网站进行身份验证。网站 example.com 获取与 Alice 关联的对称密钥，并使用 HMAC 和当前时间计算一次性密码。网站接下来以常量时间比较
    Alice 发送的一次性密码。
- en: 'This TOTP-based authentication flow is not ideal, though. There are a number
    of things that could be improved, for example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于 TOTP 的身份验证流程并不理想。有许多可以改进的地方，例如：
- en: The authentication can be faked by the server as it also owns the symmetric
    key.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务器也拥有对称密钥，认证可以被伪造。
- en: You can be social-engineered out of your one-time password.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以被社会工程学方式获得您的一次性密码。
- en: For this reason, symmetric keys are yet another *not-perfect replacement* for
    passwords. Next, let’s see how using asymmetric keys can address these downsides.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对称密钥是另一种*不完美的密码替代方案*。接下来，让我们看看如何使用非对称密钥来解决这些缺点。
- en: Phishing
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 钓鱼
- en: Phishing (or *social engineering*) is an attack that does not target vulnerabilities
    in the software but rather vulnerabilities in human beings. Imagine that an application
    requires you to enter a one-time password to authenticate. What an attacker could
    do in this case is to attempt to log in the application as you, and when prompted
    with a one-time password request, give you a call to ask you for a valid one (pretending
    that they work for the application).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 钓鱼（或*社会工程学*）是一种不针对软件漏洞而是针对人的漏洞的攻击。想象一下，一个应用程序要求您输入一次性密码进行身份验证。在这种情况下，攻击者可能会尝试以您的身份登录应用程序，并在提示输入一次性密码时，给您打电话要求您提供有效的密码（假装他们为该应用程序工作）。
- en: You’re telling me you wouldn’t fall for it! Good social engineers are superior
    at spinning believable stories and fabricating a sense of urgency that would make
    the best of us spill the beans. If you think about it, all the protocols that
    we’ve talked about previously are vulnerable to these types of attacks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你在告诉我你不会上当吗！优秀的社会工程师擅长编织可信度很高的故事，并制造出一种紧迫感，使我们中的大多数人都会不假思索地泄露秘密。如果你仔细想想，我们之前谈论过的所有协议都容易受到这些类型的攻击的影响。
- en: 11.2.4 Replacing passwords with asymmetric keys
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 用非对称密钥替换密码
- en: Now that we’re dealing with public key cryptography, there’s more than one way
    we can use asymmetric keys to authenticate to a server. We can
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在处理公钥密码学，有多种方法可以使用非对称密钥对服务器进行身份验证。我们可以
- en: Use our asymmetric key inside a key exchange to authenticate our side of the
    connection
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在密钥交换中使用我们的非对称密钥来验证连接的我们这一侧
- en: Use our asymmetric key in an already secured connection with an authenticated
    server
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已经获得验证的连接中使用我们的非对称密钥与认证的服务器
- en: Let’s take a look at each method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每种方法。
- en: Mutual authentication in key exchanges
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥交换中的双向认证
- en: 'You’ve already heard about the first method: using the asymmetric key inside
    a key exchange. In chapter 9, I mentioned that a TLS server can request the client
    to use a *certificate* as part of the handshake. Often, companies will provision
    their employees’ devices with a unique per-employee certificate that allows them
    to authenticate to internal services. Figure 11.10 provides an idea of what it
    looks like from a user’s perspective.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经听说过第一种方法了：使用密钥交换中的非对称密钥。在第 9 章中，我提到 TLS 服务器可以要求客户端在握手中使用*证书*。通常，公司会向其员工的设备配备唯一的员工证书，允许他们对内部服务进行身份验证。图
    11.10 从用户的角度提供了一个大致的外观。
- en: '![](../Images/11_10.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_10.jpg)'
- en: Figure 11.10 A page prompting the user’s browser for a client certificate. The
    user can then select which certificate to use from a list of locally installed
    certificates. In the TLS handshake, the client certificate’s key is then used
    to sign the handshake transcript, including the client’s ephemeral public key,
    which is used as part of the handshake.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 一页提示用户的浏览器获取客户端证书。用户然后可以从本地已安装的证书列表中选择要使用的证书。在 TLS 握手中，客户端证书的密钥用于签署握手记录，包括客户端的临时公钥，该公钥用作握手的一部分。
- en: Client-side certificates are pretty straightforward. For example, in TLS 1.3,
    a server can request the client to authenticate during the handshake by sending
    a `CertificateRequest` message. The client then responds by sending its certificate
    in a `Certificate` message, followed by a signature of all messages sent and received
    in a `CertificateVerify` message (which includes the ephemeral public key used
    in the key exchange). The client is authenticated if the server can recognize
    the certificate and successfully verify the client’s signature. Another example
    is the Secure Shell (SSH) protocol, which also has the client sign parts of the
    handshake with a public key known to the server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书相当简单。例如，在 TLS 1.3 中，服务器可以在握手期间通过发送 `CertificateRequest` 消息来请求客户端进行身份验证。然后，客户端通过在
    `Certificate` 消息中发送其证书，然后在 `CertificateVerify` 消息中对发送和接收的所有消息进行签名（其中包括用于密钥交换的临时公钥）。如果服务器能够识别证书并成功验证客户端的签名，则客户端经过身份验证。另一个例子是安全外壳（SSH）协议，该协议也要求客户端使用服务器已知的公钥对握手的部分进行签名。
- en: Note that signing is not the only way to authenticate with public key cryptography
    during the handshake phase. The Noise protocol framework (covered in chapter 9
    as well) has several handshake patterns that enable client-side authentication
    using just DH key exchanges.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在握手阶段使用公钥加密进行身份验证的方法不仅限于签名。Noise 协议框架（在第 9 章中也有介绍）有几种握手模式，可以仅使用 DH 密钥交换进行客户端身份验证。
- en: Post-handshake user authentication with FIDO2
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FIDO2 进行握手后的用户身份验证
- en: The second type of authentication with asymmetric keys uses an already *secure*
    connection where only the server is authenticated. To do this, a server can simply
    ask the client to sign a *random* challenge. This way, replay attacks are prevented.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非对称密钥的第二种身份验证类型使用已经 *安全* 的连接，仅服务器被验证。为此，服务器可以简单地要求客户端对一个 *随机* 挑战进行签名。这样，重放攻击就被防止了。
- en: 'One interesting standard in this space is the *Fast IDentity Online 2* (FIDO2).
    FIDO2 is an open standard that defines how to use asymmetric keys to authenticate
    users. The standard specifically targets phishing attacks, and for this reason,
    FIDO2 is made to work only with *hardware authenticators*. Hardware authenticators
    are simply physical components that can generate and store signing keys and can
    sign arbitrary challenges. FIDO2 is split into two specifications (figure 11.11):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域有一个有趣的标准是*快速身份在线 2*（FIDO2）。FIDO2 是一个开放标准，定义了如何使用非对称密钥对用户进行身份验证。该标准专门针对钓鱼攻击，并且为此，FIDO2
    只能与*硬件认证器*一起使用。硬件认证器只是可以生成和存储签名密钥，并能签署任意挑战的物理组件。FIDO2 分为两个规范（图 11.11）：
- en: '*Client to Authenticator Protocol* (CTAP)—CTAP specifies a protocol that *roaming
    authenticators* and *clients* can use to communicate with one another. Roaming
    authenticators are hardware authenticators that are external to your main device.
    A client in the CTAP specification is defined as the software that wants to query
    these authenticators as part of an authentication protocol. Thus, a client can
    be an operating system, a native application like a browser, and so on.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端到认证器协议*（CTAP）—CTAP 指定了漫游认证器和客户端可以使用的通信协议。漫游认证器是外部于您的主设备的硬件认证器。在 CTAP 规范中，客户端被定义为要查询这些认证器的软件的一部分，作为身份验证协议的一部分。因此，客户端可以是操作系统、本地应用程序（如浏览器）等。'
- en: '*Web Authentication* (WebAuthn)—WebAuthn is the protocol that web browsers
    and web applications can use to authenticate users with hardware authenticators.
    It, thus, must be implemented by browsers to support authenticators. If you are
    building a web application and want to support user authentication via hardware
    authenticators, WebAuthn is what you need to use.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Web 身份验证*（WebAuthn）—WebAuthn 是 Web 浏览器和 Web 应用程序可以使用的协议，用于使用硬件认证器对用户进行身份验证。因此，必须由浏览器来实现它以支持认证器。如果您正在构建一个
    Web 应用程序，并希望支持通过硬件认证器进行用户身份验证，则需要使用 WebAuthn。'
- en: '![](../Images/11_11.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_11.jpg)'
- en: 'Figure 11.11 Two types of hardware authenticators that can be used with FIDO2:
    (on the left) a Yubikey, a roaming authenticator, and (on the right) TouchID,
    a built-in authenticator.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 FIDO2 可用的两种硬件认证器类型：（左侧）Yubikey，一种漫游认证器，以及（右侧）TouchID，一种内置认证器。
- en: WebAuthn allows websites to use not only roaming authenticators but also *platform*
    authenticators. Platform authenticators are built-in authenticators provided by
    a device. They are implemented differently by various platforms and are often
    protected by biometrics (for example, a fingerprint reader, facial recognition,
    and so on).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: WebAuthn允许网站不仅使用漫游验证器，还可以使用*平台*验证器。平台验证器是设备提供的内置验证器。它们在各种平台上实现不同，并且通常受生物识别技术保护（例如，指纹识别器、面部识别等）。
- en: We are now ending the first part of this chapter. But before I do this, figure
    11.12 recaps the nonpassword-based authentication protocols I’ve talked about.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在结束了本章的第一部分。但在我这样做之前，图11.12总结了我谈论过的非基于密码的认证协议。
- en: '![](../Images/11_12.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_12.jpg)'
- en: Figure 11.12 To authenticate without using a password, applications can allow
    users to either use symmetric keys via OTP-based protocols or use asymmetric keys
    via the FIDO2 standard. FIDO2 supports different types of authenticators, roaming
    authenticators (via the CTAP standard) or built-in authenticators.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 要进行无密码认证，应用程序可以允许用户通过基于OTP的协议使用对称密钥，或者通过FIDO2标准使用非对称密钥。FIDO2支持不同类型的验证器，例如漫游验证器（通过CTAP标准）或内置验证器。
- en: Now that you have learned about many different techniques and protocols that
    exist to either improve passwords or replace them with stronger cryptographic
    solutions, you might be wondering, which one you should use? Each of these solutions
    have their own caveats, and no single solution might do it. If not, combine multiple
    ones! This idea is called *multi-factor authentication* (MFA). Actually, chances
    are that you might have already used OTPs or FIDO2 as a second authentication
    factor in addition to (and not in place of) passwords.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了许多不同的技术和协议，这些技术和协议旨在改善密码或将其替换为更强大的加密解决方案，您可能会想知道，应该使用哪一种？每种解决方案都有其自己的局限性，可能没有一种解决方案能够胜任。如果没有，那就结合多种解决方案吧！这个想法被称为*多因素认证*（MFA）。实际上，很有可能您已经在密码之外使用了OTP或FIDO2作为第二个身份验证因素。
- en: This concludes the first half of this chapter on authenticating users. Next,
    let’s take a look at how humans can help devices to authenticate each other.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本章关于用户身份验证的前半部分。接下来，让我们看看人类如何帮助设备相互认证。
- en: '11.3 User-aided authentication: Pairing devices using some human help'
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 用户辅助认证：使用人类帮助配对设备
- en: Humans help machines to authenticate one another every day—EVERY DAY! You’ve
    done it by pairing your wireless headphones with your phone, or by pairing your
    phone with your car, or by connecting some device to your home WiFi, and so on.
    And as with any pairing, what’s underneath is most probably a key exchange.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 人类每天都在帮助机器相互认证 —— 每一天！您通过将无线耳机与手机配对，或者将手机与汽车配对，或者将某个设备连接到家庭WiFi，等等来完成了这一点。而且与任何配对一样，底层很可能是密钥交换。
- en: The authentication protocols in the last section took place in already secured
    channels (perhaps with TLS), where the server was authenticated. Most of this
    section, in contrast, attempts to provide a secure channel to two devices that
    do not know how to authenticate each other. In that sense, what you’ll learn in
    this section is how humans can help to *upgrade* an insecure connection into a
    *mutually authenticated connection*. For this reason, the techniques you will
    learn about next should be reminiscent of some of the trust establishment techniques
    in the end-to-end protocols of chapter 10, except that there, two humans were
    trying to authenticate themselves to each other.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的身份验证协议是在已经安全的通道中进行的（可能是通过TLS），服务器进行了身份验证。与之相反，本节大部分内容试图为两个不知道如何相互认证的设备提供一个安全通道。在这个意义上，您将在本节中学到的内容是人类如何帮助将一个不安全的连接升级为一个*相互认证的连接*。因此，接下来您将学到的技术应该让您想起第10章端到端协议中的一些建立信任的技术，只是在那里，两个人试图相互认证。
- en: 'Nowadays, the most common insecure connections that you will run into, those
    that do not go through the internet, are protocols based on short-range radio
    frequencies like Bluetooth, WiFi, and Near Field Communication (NFC). NFC is what
    you use to pay with your phone or with your bank card’s “contactless” payment.
    Devices that use these communication protocols tend to range from low-power electronics
    to full-featured computers. This already sets some constraints for us:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，你将遇到的最常见的不安全连接（不通过互联网），都是基于短程无线电频率的协议，如蓝牙、WiFi和近场通信（NFC）。 NFC 是你用来用手机或银行卡的“非接触”支付。使用这些通信协议的设备通常从低功耗电子设备到功能齐全的计算机都有。这已经给我们设置了一些限制：
- en: '*The device you are trying to connect to might not offer a screen to display
    a key or a way to manually enter a key.* We call this *provisioning* the device.
    For example, most wireless audio headsets today only have a few buttons and that’s
    it.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您正在尝试连接的设备可能没有屏幕来显示密钥或手动输入密钥的方法。*我们称之为*配置*该设备。例如，今天大多数无线音频耳机只有几个按钮而已。'
- en: '*As a human is part of the validation process, having to type or compare long
    strings is often deemed impractical and not user-friendly.* For this reason, many
    protocols attempt to shorten security-related strings to 4- or 6-digit PINs.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*由于人类是验证过程的一部分，必须键入或比较长字符串通常被认为是不切实际和不用户友好的。*因此，许多协议试图将安全相关字符串缩短为4位或6位数字密码。'
- en: Exercise
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Imagine a protocol where you have to enter the correct 4-digit PIN to securely
    connect to a device. What are the chances to pick a correct PIN by just guessing?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种协议，你必须输入正确的4位数字密码才能安全连接到设备。只通过猜测选择正确密码的机会有多大？
- en: You’re probably thinking back at some of your device-pairing experiences and
    realizing now that a lot of them *just worked*. For example
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会回想起你的一些设备配对经历，并且意识到现在很多情况*都是自动完成的*。例如
- en: You pushed a button on a device.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你按下了设备上的一个按钮。
- en: The device entered pairing mode.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备进入配对模式。
- en: You then tried to find the device in the Bluetooth list on your phone.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你接着试图在手机的蓝牙列表中找到设备。
- en: After clicking the device icon, it successfully paired the device with your
    phone.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击设备图标后，它成功地将设备与您的手机配对。
- en: 'If you read chapter 10, this should remind you of *trust on first use* (TOFU).
    Except, this time we also have a few more cards in our hand:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过第10章，这应该让你想起了*第一次使用时信任*（TOFU）。不过，这次我们手头还有一些其他的牌：
- en: '*Proximity*—Both devices have to be close to each other, especially if using
    the NFC protocol.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接近性*——两个设备必须彼此靠近，特别是如果使用NFC协议。'
- en: '*Time*—Device pairing is often time-constrained. It is common that if, for
    example, in a 30-second window, the pairing is not successful, the process must
    be manually restarted.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间*——设备配对通常受时间限制。如果，例如，在30秒的时间窗口内，配对不成功，必须手动重新启动该过程是很常见的。'
- en: Unlike TOFU though, these real-life scenarios usually do not allow you to validate
    after the fact that you’ve connected to the right device. This is not ideal, and
    one should strive for better security if possible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与TOFU不同，这些真实场景通常不允许你事后验证你是否已连接到正确的设备。这并不理想，如果可能的话，应该努力提升安全性。
- en: 'Note By the way, this is what the Bluetooth core specification actually calls
    the TOFU-like protocol: “Just Works.” I should mention that all built-in Bluetooth
    security protocols are currently broken due to many attacks, including the latest
    KNOB attack released in 2019 ([https://knobattack.com](https://knobattack.com)).
    The techniques surveyed in this chapter are nonetheless secure—if designed and
    implemented correctly.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意顺便提一下，这就是蓝牙核心规范实际上将类似TOFU的协议称为的内容：“Just Works”。我应该提到，目前所有内置的蓝牙安全协议都因许多攻击而破坏，包括2019年发布的最新KNOB攻击（[https://knobattack.com](https://knobattack.com)）。尽管如此，本章介绍的技术如果设计和实施正确，仍然是安全的。
- en: 'What’s next in our toolkit? This is what we will see in this section: ways
    for a human to help devices to authenticate themselves. Spoiler alert:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工具箱中的下一步是什么？这就是我们将在本节中看到的内容：人类帮助设备进行身份验证的方法。剧透：
- en: You’ll see that cryptographic keys are always the most secure approach but not
    necessarily the most user-friendly.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会发现，加密密钥始终是最安全的方法，但不一定是最用户友好的。
- en: You’ll learn about symmetric PAKEs and how you can input the same password on
    two devices to connect them securely.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将了解关于对称PAKE和如何在两个设备上输入相同密码以安全连接它们的内容。
- en: You’ll learn about protocols based on short authenticated strings (SAS), which
    authenticate a key exchange after the fact by having you compare and match two
    short strings displayed by the two devices.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解基于短认证字符串（SAS）的协议，这些协议通过让你比较和匹配两个设备显示的两个短字符串来验证密钥交换的有效性。
- en: Let’s get started!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 11.3.1 Pre-shared keys
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 预共享密钥
- en: 'Naively, the first approach to connect a user to a device would be to reuse
    protocols that you learned about in chapter 9 or chapter 10 (for example, TLS
    or Noise) and to provision both devices with a symmetric shared secret or, better,
    with long-term public keys in order to provide forward secrecy to future sessions.
    This means that you need two things for each device to learn the other device’s
    public key:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 幼稚地，将用户连接到设备的第一种方法将是重用你在第9章或第10章学到的协议（例如，TLS或Noise），并向两个设备提供对称共享密钥或更好地，提供长期公钥以为将来的会话提供前向保密性。这意味着每个设备学习另一个设备的公钥需要两件事：
- en: You need a way to *export* a public key from its device.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一种方法来*导出*设备的公钥。
- en: You need a way for a device to *import* public keys.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一种方法来*导入*公钥。
- en: As we will see, this is not always straightforward or user-friendly. But remember,
    we have a human in the mix who can observe and (maybe) play with the two devices.
    This is unlike other scenarios that we’ve seen before, and we can use this to
    our advantage!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这并不总是简单或用户友好的。但请记住，我们有一个参与的人可以观察和（也许）操纵这两个设备。这与我们以前见过的其他场景不同，我们可以利用这一点！
- en: '*The Authentication Problem - One of the main issues in cryptography is the
    establishment of a secure peer-to-peer (or group) communication over an insecure
    channel. With no assumption, such as availability of an extra secure channel,
    this task is impossible. However, given some assumption(s), there exists many
    ways to set up a secure communication*.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证问题 - 密码学中的一个主要问题是在不安全的通道上建立安全的点对点（或群组）通信。在没有额外安全通道的假设下，这个任务是不可能的。但是，假设有一些前提条件，存在许多建立安全通信的方法*。'
- en: —Sylvain Pasini (“Secure Communication Using Authenticated Channels,” 2009)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: —Sylvain Pasini（《使用认证通道进行安全通信》，2009年）
- en: 'All the protocols that follow are based on the fact that you (the human in
    charge) have an additional *out-of-band* channel. This allows you to securely
    communicate some information. The addition of this out-of-band channel can be
    modeled as the two devices having access to two types of channels (illustrated
    in figure 11.13):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接下来的协议都基于这样一个事实：你（负责人类）拥有一个额外的*带外*通道。这使您可以安全地通信一些信息。添加此带外通道可以被建模为两个设备可以访问两种类型的通道（如图11.13所示）：
- en: '*An insecure channel*—Think about a Bluetooth or a WiFi connection with a device.
    By default, the user has no way of authenticating the device and can, thus, be
    MITM’d.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个不安全的通道*——想象一下与设备连接的蓝牙或WiFi连接。默认情况下，用户无法对设备进行身份验证，因此可能会受到中间人攻击（MITM）。'
- en: '*An authenticated channel*—Think about a screen on a device. The channel provides
    integrity/authenticity of the information communicated but poor confidentiality
    (someone could be looking over your shoulder).'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个经过认证的通道*——想象一下设备上的屏幕。该通道提供了所传输信息的完整性/真实性，但机密性较差（有人可能在你旁边偷看）。'
- en: '![](../Images/11_13.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_13.jpg)'
- en: 'Figure 11.13 User-aided authentication protocols that allow a human to pair
    two devices are modeled with two types of channels between the devices: an insecure
    channel (for example, NFC, Bluetooth, WiFi, and so on), which we assume is adversary-controlled,
    and an authenticated channel (for example, real life), which does not provide
    confidentiality but can be used to exchange relatively small amounts of information.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 用户辅助身份验证协议允许用户配对两个设备，这些协议模拟了设备之间的两种类型的通道：一个不安全的通道（例如，NFC、蓝牙、WiFi等），我们假设该通道由对手控制，以及一个经过认证的通道（例如，现实生活中的通道），该通道不提供机密性，但可以用于交换相对较小的信息量。
- en: As this out-of-band channel provides poor confidentiality, we usually do not
    want to use it to export secrets but rather public data. For example, a public
    key or some digest can be displayed by the device’s screen. But once you have
    exported a public key, you still need the other device to import it. For example,
    if the key is a QR code, then the other device might be able to scan it, or if
    the key is encoded in a human-readable format, then the user could manually type
    it in the other device using a keyboard. Once both devices are provisioned with
    each other’s public keys, you can use any protocols I’ve mentioned in chapter
    9 to perform a mutually authenticated key exchange with the two devices.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种带外通道提供的保密性较差，我们通常不希望使用它来导出机密信息，而是用于公共数据。例如，设备的屏幕可以显示公钥或某些摘要。但是一旦您导出了一个公钥，您仍然需要另一个设备来导入它。例如，如果密钥是一个二维码，那么另一个设备可能能够扫描它，或者如果密钥以人类可读的格式编码，那么用户可以使用键盘在另一个设备上手动输入它。一旦两个设备都配置了彼此的公钥，您可以使用我在第9章中提到的任何协议来执行两个设备之间的相互认证密钥交换。
- en: What I want you to get from this section is that using cryptographic keys in
    your protocol is always the most secure way to achieve something, but it is not
    always the most user-friendly way. Yet, real-world cryptography is full of compromise
    and trade-offs, and this is why the next two schemes not only exist, but are the
    most popular ways to authenticate devices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您从本节中了解到，在您的协议中使用加密密钥始终是实现某些目标的最安全方式，但并不总是最用户友好的方式。然而，现实世界的密码学充满了妥协和权衡，这就是为什么下面的两种方案不仅存在，而且是认证设备最流行的方式。
- en: Let’s see how we can use *passwords* to bootstrap a mutually authenticated key
    exchange in cases where you cannot export and import long public keys. Then we’ll
    look at how short *authenticated strings* can help in situations where importing
    data into one or both of the devices is just not possible.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在无法导出和导入长公钥的情况下如何使用*密码*启动双向认证密钥交换。然后我们将看看短*认证字符串*如何在无法将数据导入到一个或两个设备的情况下提供帮助。
- en: 11.3.2 Symmetric password-authenticated key exchanges with CPace
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 使用CPace进行对称密码认证密钥交换
- en: The previous solution is what you should be doing, if possible, as it relies
    on strong asymmetric keys as a root of trust. Yet, it turns out that, in practice,
    typing a long string representing a key with some cumbersome keypad manually is
    tedious. What about these dear passwords? They are so much shorter and, thus,
    easier to deal with. We love passwords right? Perhaps we don’t, but users do,
    and real-world cryptography is full of compromises. So be it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，您应该采用上述解决方案，因为它依赖于强大的非对称密钥作为信任的根源。然而，实践中发现，手动使用一串长字符串表示的密钥在一些笨重的键盘上输入是很繁琐的。那么这些亲爱的密码呢？它们要短得多，因此更容易处理。我们喜欢密码对吧？也许我们不喜欢，但用户喜欢，而现实世界的密码学充满了妥协。所以就这样吧。
- en: In the section on asymmetric password-authenticated key exchanges, I mentioned
    that a symmetric (or balanced) version exists where two peers who know a common
    password can perform a mutually authenticated key exchange. This is exactly what
    we need.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于对称密码认证密钥交换的部分中，我提到了存在一个对称（或平衡）版本，其中知道共同密码的两个对等方可以执行相互认证密钥交换。这正是我们需要的。
- en: '*Composable Password Authenticated Connection Establishment* (CPace) was proposed
    in 2008 by Björn Haase and Benoît Labrique and was chosen in early 2020 as the
    official recommendation of the CFRG (the Crypto Forum Research Group). The algorithm
    is currently being standardized as an RFC. The protocol, simplified, looks something
    like the following (figure 11.14 illustrates the algorithm):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*可组合密码认证连接建立*（CPace）于2008年由Björn Haase和Benoît Labrique提出，并于2020年初被CFRG（密码论坛研究小组）选为官方推荐。该算法目前正在作为RFC标准化。简化的协议看起来类似于以下内容（图11.14说明了该算法）：'
- en: Two devices derive a generator (for some predetermined cyclic group) based on
    a common password.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个设备基于一个共同的密码派生一个生成器（用于某个预定循环群）。
- en: Then the two devices use this generator to perform an ephemeral DH key exchange
    on top of it.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后两个设备使用这个生成器在其上执行临时DH密钥交换。
- en: '![](../Images/11_14.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_14.jpg)'
- en: Figure 11.14 The CPace PAKE works by having the two devices create a generator
    based on a password and then use it to perform as a base for the usual ephemeral
    DH key exchange.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 CPace PAKE的工作原理是让两个设备基于一个密码创建一个生成器，然后将其用作通常的临时DH密钥交换的基础。
- en: The devil is in the details, of course, and as a modern specification, CPace
    targets elliptic curve “gotchas” and defines when one must verify that a received
    point is in the right group (due to the trendy Curve25519 that, unfortunately,
    does not span a prime group). It also specifies how one derives a generator based
    on a password when in an elliptic curve group (using so-called hash-to-curve algorithms)
    and how to do this (using not only a common password but also an unique session
    ID and some additional contextual metadata like peer IP addresses and so on).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，魔鬼在细节中，作为一个现代规范，CPace 针对椭圆曲线的“陷阱”，并定义了何时必须验证接收到的点是否在正确的群中（由于时髦的 Curve25519，不幸的是，它不构成一个素数群）。它还指定了如何基于密码在椭圆曲线群中派生生成器（使用所谓的哈希到曲线算法）以及如何做到这一点（不仅使用普通密码，还使用唯一的会话
    ID 和一些附加的上下文元数据，比如对等方 IP 地址等等）。
- en: These steps are important as both peers must derive a generator *h* in a way
    that prevents them from knowing its discrete logarithm *x* such that g^x = *h*.
    Finally, the session key is derived from the DH key exchange output, the transcript
    (the ephemeral public keys), and the unique session ID.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤很重要，因为双方都必须以防止它们知道其离散对数 *x* 的方式派生生成器 *h*，使得 g^x = *h*。最后，会话密钥是从 DH 密钥交换输出、记录（临时公钥）和唯一的会话
    ID 派生的。
- en: Intuitively, you can see that impersonating one of the peers and sending a group
    element as part of the handshake means that you’re sending a public key, which
    is associated with a private key you cannot know. This means that you can never
    perform a DH key exchange if you don’t know the password. The transcript just
    looks like a normal DH key exchange, and so, no luck there (as long as DH is secure).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉上，你可以看到冒充其中一方并在握手的一部分发送一个群元素意味着你发送了一个公钥，这个公钥与你无法知道的私钥相关联。这意味着如果你不知道密码，你永远无法执行
    DH 密钥交换。记录看起来就像一个正常的 DH 密钥交换，所以，没有运气（只要 DH 是安全的）。
- en: 11.3.3 Was my key exchange MITM’d? Just check a short authenticated string (SAS)
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 我的密钥交换被 MITM 攻击了吗？只需检查一个短认证字符串（SAS）。
- en: In the second part of this chapter, you saw different protocols that allow two
    devices to be paired with the help of a human. Yet, I mentioned that some devices
    are so constrained that they cannot make use of those protocols. Let’s take a
    look at a scheme that is used when the two devices cannot import keys but can
    display some limited amount of data to the user (perhaps via a screen, or by turning
    on some LEDs, or by emitting some sounds, and so on).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分中，你看到了不同的协议，它们允许两个设备在人类的帮助下配对。然而，我提到有些设备受限制以至于无法使用这些协议。让我们来看看一种方案，当两个设备无法导入密钥但可以向用户显示一些有限的数据时使用（也许通过屏幕、或者通过打开一些
    LED、或者通过发出一些声音等等）。
- en: First, remember that in chapter 10, you learned about authenticating a session
    *post-handshake* (after the key exchange) using *fingerprints* (hashes of the
    transcript). We could use something like this as we have our out-of-band channel
    to communicate these fingerprints. If the user can successfully compare and match
    the fingerprints obtained from both devices, then the user knows that the key
    exchange was not MITM’d.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，记住在第 10 章中，你学到了如何在 *握手后*（密钥交换后）使用 *指纹*（传输的哈希）对会话进行认证。我们可以像这样使用一些东西，因为我们有我们的带外信道来传递这些指纹。如果用户能够成功比较和匹配从两台设备获取的指纹，那么用户就知道密钥交换没有被
    MITM 攻击。
- en: The problem with fingerprints is that they are long byte strings (typically,
    32 bytes long), which might be hard to display to the user. They are also cumbersome
    to compare. But for device pairing, we can use much shorter byte strings because
    we are doing the comparison in real time! We call these *short authenticated strings*
    (SAS). SAS are used a lot, notably by Bluetooth, due to them being quite user-friendly
    (see figure 11.15 for an example).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 指纹的问题在于它们是长字节串（通常为 32 个字节长），可能难以显示给用户。它们也很笨重，难以比较。但对于设备配对，我们可以使用更短的字节串，因为我们在实时进行比较！我们称这些为
    *短认证字符串*（SAS）。SAS 被广泛使用，特别是由于它们相当用户友好（请参见图 11.15 中的示例）。
- en: '![](../Images/11_15.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_15.jpg)'
- en: Figure 11.15 To pair a phone with a car via Bluetooth, the Numeric Comparison
    mode can be used to generate a short authenticated string (SAS) of the secure
    connection negotiated between the two devices. Unfortunately, as I stated earlier
    in this chapter, due to the KNOB attack, Bluetooth’s security protocols are currently
    broken (as of 2021). If you control both devices, you need to implement your own
    SAS protocol.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 要通过蓝牙将手机与汽车配对，可以使用数字比对模式生成一个短的经过身份验证的字符串（SAS），该字符串是两个设备之间协商的安全连接的一部分。不幸的是，正如我在本章早些时候所述，由于
    KNOB 攻击，蓝牙的安全协议目前已经破解（截至 2021 年）。如果你控制着这两个设备，你需要实现自己的 SAS 协议。
- en: There aren’t any standards for SAS-based schemes, but most protocols (including
    Bluetooth’s numeric comparison) implement a variant of the *Manually Authenticated
    Diffie-Hellman* (MA-DH). MA-DH is a simple key exchange with an additional trick
    that makes it hard for an attacker to actively man-in-the-middle the protocol.
    You might ask, why not just create SAS from truncating a fingerprint? Why the
    need for a trick?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: SAS-based schemes 没有任何标准，但大多数协议（包括蓝牙的数字比对）实现了一种变种的*手动认证迪菲-赫尔曼*（MA-DH）。MA-DH
    是一种简单的密钥交换协议，其附加的技巧使得攻击者很难在中间人攻击中主动干预协议。你可能会问，为什么不只是从截断的指纹中创建 SAS？为什么需要一种技巧？
- en: An SAS is typically a 6-digit number, which can be obtained by truncating a
    hash of the transcript to less than 20 bits and converting that to numbers in
    base 10\. SAS is, thus, dangerously small, which makes it much easier for an attacker
    to obtain a *second pre-image* on the truncated hash. In figure 11.16, we take
    the example of two devices (although we use Alice and Bob) performing an unauthenticated
    key exchange. An active MITM attacker can substitute Alice’s public key with their
    own public key in the first message. Once the attacker receives Bob’s public key,
    they would know what SAS Bob will compute (a truncated hash based on the attacker’s
    public key and on Bob’s public key). The attacker just has to generate many public
    keys in order to find one (*public_key*[E]2) that will make the SAS of Alice’s
    match with Bob’s.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: SAS 通常是一个 6 位数，可以通过将传输的哈希值截断为少于 20 位并将其转换为十进制数字来获得。因此，SAS 实际上非常小，这使得攻击者更容易在截断的哈希上获取*第二个前像*。在图
    11.16 中，我们以两个设备为例（尽管我们使用了 Alice 和 Bob），执行一个未经身份验证的密钥交换。一个主动的 MITM 攻击者可以在第一个消息中用他们自己的公钥替换
    Alice 的公钥。一旦攻击者收到 Bob 的公钥，他们就会知道 Bob 将计算什么样的 SAS（基于攻击者的公钥和 Bob 的公钥的截断哈希）。攻击者只需生成许多公钥，以找到一个（*public_key*[E]2），使得
    Alice 的 SAS 与 Bob 的匹配。
- en: '![](../Images/11_16.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_16.jpg)'
- en: Figure 11.16 A typical unauthenticated key exchange (on the left) can be intercepted
    by an active MITM attacker (on the right), who can then substitute the public
    keys of both Alice and Bob. A MITM attack is successful if both Alice and Bob
    generate the same short authenticated string. That is, if *HASH*(*public_key*[A]
    || *public_key*[E2]) and *HASH*(*public_key*[E2] || *public_key*[B]) match.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 典型的未经身份验证的密钥交换（左侧）可以被主动的 MITM 攻击者（右侧）拦截，后者可以替换 Alice 和 Bob 的公钥。如果 Alice
    和 Bob 都生成相同的短的经过身份验证的字符串，则 MITM 攻击成功。也就是说，如果 *HASH*(*public_key*[A] || *public_key*[E2])
    和 *HASH*(*public_key*[E2] || *public_key*[B]) 匹配。
- en: Generating a public key to make both SAS match is actually pretty easy. Imagine
    that the SAS is 20 bits, then after only 2^(20) computations, you should find
    a second pre-image that will have both Alice and Bob generate the same SAS. This
    should be pretty instant to compute, even on a cheap phone.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个公钥以使两个 SAS 匹配实际上相当容易。想象一下 SAS 是 20 位，那么只需要 2^(20) 次计算，你就应该能够找到一个第二个前像，使得
    Alice 和 Bob 都生成相同的 SAS。即使在一部廉价手机上，这也应该是相当快速的计算。
- en: The trick behind SAS-based key exchanges is to prevent the attacker from being
    able to choose their second public key, forcing the two SAS to match. To do this,
    Alice simply sends a *commitment* of her public key before seeing Bob’s public
    key (as in figure 11.17).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SAS-based key exchanges 的技巧在于防止攻击者能够选择他们的第二个公钥，从而强制两个 SAS 匹配。为了做到这一点，Alice 在看到
    Bob 的公钥之前简单地发送了她的公钥的一个*承诺*（如图 11.17 所示）。
- en: '![](../Images/11_17.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11_17.jpg)'
- en: Figure 11.17 The diagram on the left pictures a secure SAS-based protocol in
    which Alice first sends a commitment of her public key. She then only reveals
    her public key after receiving Bob’s public key. As she committed to it, she cannot
    freely choose her key pair based on Bob’s key. If the exchange is actively MITM’d
    (diagram on the right), the attacker cannot choose either key pairs to force Alice’s
    and Bob’s SAS to match.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 左侧的图示了一个安全的 SAS-based 协议，其中 Alice 首先发送她的公钥的承诺。在收到 Bob 的公钥后，她只在之后才揭示自己的公钥。因为她已经对其进行了承诺，所以她不能根据
    Bob 的密钥自由选择她的密钥对。如果交换被主动进行了 MITM 攻击（右侧的图示），攻击者将无法选择任何密钥对以强制 Alice 和 Bob 的 SAS
    匹配。
- en: As with the previous insecure scheme, the attacker’s choice of *public_key*[*E*1]
    does not give them any advantage. But now, they also cannot choose a *public_key*[*E*2]
    that helps because they do not know Bob’s SAS at this point in the protocol. They
    are forced to “shoot in the dark” and hope that Alice’s and Bob’s SAS will match.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的不安全方案一样，攻击者选择的 *public_key*[*E*1] 不会给他们任何优势。但现在，他们也不能选择一个 *public_key*[*E*2]
    来帮助，因为在协议的这一点上他们不知道 Bob 的 SAS。他们被迫“盲目射击”，希望 Alice 和 Bob 的 SAS 会匹配。
- en: If a SAS is 20 bits, that’s a probability of 1 out of 1,048,576\. An attacker
    can have more chances by running the protocol multiple times, but keep in mind
    that every instance of the protocol must have the user manually match a SAS. Effectively,
    this friction naturally prevents an attacker from getting too many lottery tickets.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SAS 是 20 位，那么概率是 1,048,576 中的 1。攻击者可以通过多次运行协议来增加机会，但请记住，协议的每个实例都必须由用户手动匹配
    SAS。实际上，这种摩擦自然地防止了攻击者获得过多的彩票。
- en: '![](../Images/11_18.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![11_18.jpg](../Images/11_18.jpg)'
- en: 'Figure 11.18 You’ve learned about three techniques to pair two devices: (1)
    a user can either help the devices obtain each other’s public keys so that they
    can perform a key exchange; (2) a user can enter the same password on two devices
    so that they can perform a symmetric password-authenticated key exchange; or (3)
    a user can verify a fingerprint of the key exchange after the fact to confirm
    that no MITM attacker intercepted the pairing.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 你学到了关于配对两台设备的三种技术：（1）用户可以帮助设备获取彼此的公钥，以便它们可以执行密钥交换；（2）用户可以在两台设备上输入相同的密码，以便它们可以执行对称密码认证密钥交换；或者（3）用户可以事后验证密钥交换的指纹，以确认没有
    MITM 攻击者拦截了配对。
- en: Story time
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 故事时间
- en: Interestingly, as I was writing chapter 10 on end-to-end encryption, I started
    looking into how users of the Matrix end-to-end encrypted chat protocol authenticated
    their communications. In order to make the verification more user-friendly, Matrix
    created their own variant of a SAS-based protocol. Unfortunately, it hashed the
    shared secret of an X25519 key exchange and did not include the public keys being
    exchanged in the hash.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当我写第 10 章关于端对端加密时，我开始研究 Matrix 端对端加密聊天协议的用户是如何验证他们的通信的。为了使验证更加用户友好，Matrix
    创建了自己的 SAS-based 协议变种。不幸的是，它对 X25519 密钥交换的共享密钥进行了哈希处理，但在哈希中没有包含要交换的公钥。
- en: In chapter 5, I mentioned that it is important to validate X25519 public keys.
    Matrix did not, and this allowed a MITM attacker to send incorrect public keys
    to users, forcing them to end up with the same predictable shared secret and,
    in turn, the same SAS. This completely broke the end-to-end encryption claim of
    the protocol and ended up being quickly fixed by Matrix.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，我提到验证 X25519 公钥是很重要的。Matrix 没有这样做，这使得 MITM 攻击者能够向用户发送不正确的公钥，迫使他们最终得到相同的可预测的共享密钥，进而得到相同的
    SAS。这完全破坏了协议的端对端加密声明，并且很快由 Matrix 进行了修复。
- en: This is it! Figure 11.18 reviews the different techniques you learned in the
    second part of this chapter. I’ll see you in chapter 12\.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容！图 11.18 回顾了本章第二部分中学到的不同技术。下次见在第 12 章。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: User authentication protocols (protocols for machines to authenticate humans)
    often take place over secure connections, where only the machine (server) has
    been authenticated. In this sense, it upgrades a one-way authenticated connection
    to a mutually authenticated connection.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户身份验证协议（机器验证人类的协议）通常在安全连接上进行，只有机器（服务器）已经通过验证。在这个意义上，它将单向验证连接升级为双向验证连接。
- en: User authentication protocols make heavy use of passwords. Passwords have proven
    to be a somewhat practical solution and one that is widely accepted by users.
    But they have also led to many issues due to poor password hygiene, low entropy,
    and password database breaches.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户认证协议大量使用密码。密码已被证明是一种相对实用的解决方案，并被用户广泛接受。但由于密码卫生不佳、熵值低和密码数据库泄露等问题，密码也导致了许多问题。
- en: 'There are two ways to avoid having users carry multiple passwords (and possibly
    reuse passwords):'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两种方法可以避免用户携带多个密码（并可能重复使用密码）：
- en: '*Password managers*—Tools that users can use to generate and manage strong
    passwords for every application they use.'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密码管理器*—用户可以使用的工具，用于为他们使用的每个应用程序生成和管理强密码。'
- en: '*Single sign-on* (SSO)—A federated protocol that allows a user to use one account
    to register and log into other services.'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单点登录*（SSO）—一种联合协议，允许用户使用一个帐户注册并登录其他服务。'
- en: A solution for servers to avoid learning about and storing their users’ passwords
    is to use an asymmetric password-authenticated key exchange (asymmetric PAKE).
    An asymmetric PAKE (like OPAQUE) allows users to authenticate to a known server
    using passwords but without having to actually reveal their passwords to the server.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器避免了解和存储其用户密码的一个解决方案是使用非对称密码认证密钥交换（非对称PAKE）。非对称PAKE（如OPAQUE）允许用户使用密码对已知服务器进行身份验证，但无需实际向服务器透露密码。
- en: Solutions to avoid passwords altogether are for users to use symmetric keys
    via one-time passwords (OTP) algorithms or to use asymmetric keys via standards
    like FIDO2.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免密码的解决方案包括用户通过一次性密码（OTP）算法使用对称密钥或通过FIDO2等标准使用非对称密钥。
- en: User-aided authentication protocols often take place over insecure connections
    (WiFi, Bluetooth, NFC) and help two devices to authenticate each other. To secure
    connections in these scenarios, user-aided protocols assume that the two participants
    possess an additional authenticated (but not confidential) channel that they can
    use (for example, a screen on the device).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户辅助认证协议通常在不安全的连接（WiFi，蓝牙，NFC）上进行，并帮助两个设备相互认证。为了在这些情景下保护连接，用户辅助协议假设两个参与者拥有一个额外的经过身份验证的（但不保密的）通道可供使用（例如，设备上的屏幕）。
- en: Exporting a device’s public key to another device could allow strongly mutually
    authenticated key exchanges to happen. These flows are, unfortunately, not user-friendly
    and sometimes not possible due to device constraints (no way to export or import
    keys, for example).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将设备的公钥导出到另一个设备可以允许进行强相互认证的密钥交换。不幸的是，这些流程不够用户友好，有时由于设备限制（例如无法导出或导入密钥）而不可能。
- en: Symmetric password-authenticated key exchanges (symmetric PAKEs) like CPace
    can decrease the burden for the user to import a long public key by only having
    to manually input a password in a device. Symmetric PAKEs are already used by
    most people to connect to their home WiFi, for example.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称密码认证密钥交换（对称PAKEs）如CPace可以通过只需用户手动输入密码而无需导入长公钥来减轻用户的负担。例如，大多数人已经使用对称PAKEs来连接到他们的家庭WiFi。
- en: Protocols based on short authenticated strings (SAS) can provide security for
    devices that cannot import keys or passwords but are able to display a short string
    after a key exchange takes place. This short string must be the same on both devices
    in order to ensure that the unauthenticated key exchange was not actively MITM’d.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于短身份验证字符串（SAS）的协议可以为无法导入密钥或密码但能够在密钥交换后显示短字符串的设备提供安全性。为了确保未经认证的密钥交换未被主动中间人攻击，这个短字符串必须在两个设备上相同。
