- en: 7 Transposition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 置换
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Route and columnar transposition
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径和列置换
- en: Random number transposition
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数置换
- en: Key transposition
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥置换
- en: Multiple anagramming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重变位词
- en: In chapters 5 and 6 we looked at substitution ciphers. The second major category
    of Secret Key encryption methods is transposition. Transposition means changing
    the order of elements in the message. These elements may be words, syllables,
    letters or the individual digits or bits that represent the letters. In this chapter
    we will deal primarily with letter transposition, but keep in mind that you can
    use the same methods for other elements, such as the word transposition in section
    7.2.2\. This chapter will cover many different types of transposition ciphers.
    You can do most of these transposition ciphers using only pencil and paper.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章和第6章，我们讨论了替换密码。秘密密钥加密方法的第二大类别是置换。置换意味着改变消息中元素的顺序。这些元素可以是单词、音节、字母或代表字母的个别数字或位。在本章中，我们将主要处理字母置换，但请记住，您可以使用相同的方法处理其他元素，例如第7.2.2节中的单词置换。本章将涵盖许多不同类型的置换密码。大多数这些置换密码只需用铅笔和纸就可以完成。
- en: 7.1 Route transposition
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 路径置换
- en: '*Route* *transposition* is the simplest, and oldest, form of transposition
    cipher. There is no key involved. The secrecy comes from the choice of routes
    or paths.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径* *置换* 是最简单、最古老的置换密码形式。没有涉及密钥。保密性来自路径或路径选择。'
- en: Route transposition is a great way to get children interested in cryptography.
    It makes a great activity for classrooms, scout troops or other clubs. The main
    caveat is that the children must write the letters uniformly in straight columns,
    otherwise the message gets garbled. This can be avoided by using graph paper with
    wide spacing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 路径置换是让孩子们对密码学感兴趣的好方法。这是一个适合课堂、童子军团或其他俱乐部的活动。主要注意事项是孩子们必须以直立的列均匀地写字母，否则消息会混乱。可以通过使用间距较宽的方格纸来避免这种情况。
- en: The basic idea is that the message is written into a rectangle using one route,
    and read out using a different route. For example, if the message has 30 characters,
    then a 5×6 rectangle is best. If the message has 29 characters, just add a null.
    Pad the message with nulls until it fits into a rectangle of suitable size. It
    is helpful to draw the outline of the rectangle before you start to fill it in.
    If the message is long, break it into blocks of a convenient size. For example,
    a message of 1000 characters might be broken into twenty 5×10 blocks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是将消息用一条路径写入矩形中，然后用另一条路径读出。例如，如果消息有30个字符，那么5×6的矩形最合适。如果消息有29个字符，只需添加一个空字符。用空字符填充消息，直到它适合合适大小的矩形。在开始填写之前，画出矩形的轮廓是有帮助的。如果消息很长，将其分成方便大小的块。例如，1000个字符的消息可以分成二十个5×10的块。
- en: We have already seen one example of a route transposition in section 4.3\. The
    message was written into the 5×5 grid horizontally from left to right across the
    rows and read out vertically top to bottom down the columns. Horizontal and vertical
    are two types of routes. Here is a fuller list.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第4.3节看到了路径置换的一个示例。消息是水平地从左到右跨行写入5×5网格中，然后垂直地从上到下沿列读出。水平和垂直是两种路径。以下是更完整的列表。
- en: Horizontally, left to right, right to left, or alternating left and right
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平方向，从左到右，从右到左，或交替左右
- en: Vertically, top to bottom, bottom to top, or alternating up and down
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直方向，从上到下，从下到上，或交替上下
- en: Diagonally, upper left to lower right, lower left to upper right, and so forth,
    or alternating
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对角线方向，从左上到右下，从左下到右上，等等，或交替
- en: Spiral, from any corner inward or from the center outward, clockwise or counterclockwise
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 螺旋，从任何一个角向内或从中心向外，顺时针或逆时针
- en: 'You can start in any corner of the rectangle, use any route to write the message
    in, and use any other route to read the message out. Here is an example of a fancy
    route:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从矩形的任何一个角开始，使用任何路径写入消息，并使用任何其他路径读出消息。这里是一个花式路径的示例：
- en: '![7-unnumb-1](../Images/7-unnumb-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-1](../Images/7-unnumb-1.png)'
- en: The message would be written into the grid in the order indicated by the numbers,
    and read out by columns, that is, 1, 36, 37, 39, 42, 2, 6, 38, ...
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 消息将按照数字指示的顺序写入网格中，并按列读出，即1、36、37、39、42、2、6、38，...
- en: For a route transposition Emily only needs to guess the route you used to read
    the message out. After Emily has filled the message into the rectangle, it can
    be read by inspection. Note that it does not matter to Emily whether you wrote
    the message horizontally into a 5×6 rectangle or vertically into a 6×5 rectangle.
    Neither does it matter whether you started at the top row and worked down or the
    bottom row and worked up. Emily cannot tell the difference.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路线置换，Emily只需要猜测您用来读取消息的路线。在Emily将消息填入矩形之后，可以通过检查来读取。请注意，对于Emily来说，您是将消息水平写入5×6矩形还是垂直写入6×5矩形都无所谓。同样，您是从顶行向下工作还是从底行向上工作也无所谓。Emily无法区分这两者之间的差异。
- en: Route transposition is rated One.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 路线置换评为一级。
- en: 7.2 Columnar transposition
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7.2 纵列置换  '
- en: '*Columnar* *transposition* is the workhorse of transposition ciphers. It has
    been used by armies, diplomats and spies since the 17th century. The method is
    first described in a 1685 book by John Falconer, *Cryptomenysis Patefacta* (Secret
    Communication Revealed). After the Glorious Revolution of 1688, John Falconer
    followed James II into exile in France, where he died before the second edition
    of the book was published in 1692 under the new title *Rules for Explaining and
    Decyphering all Manner of Secret Writing*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*纵列* *置换* 是置换密码的主力军。自17世纪以来，它一直被军队、外交官和间谍使用。该方法首次在约翰·法尔科纳（John Falconer）于1685年撰写的《密信解密》（Cryptomenysis
    Patefacta）一书中描述。1688年的光荣革命之后，约翰·法尔科纳跟随詹姆斯二世流亡到法国，在那里去世，而第二版于1692年以新标题《解释和解密各种秘密写作规则》（Rules
    for Explaining and Decyphering all Manner of Secret Writing）出版之前已经出版。  '
- en: Columnar transposition uses a key that may be a string of consecutive numbers
    in mixed order, or a keyword or keyphrase that gets turned into a numeric string
    by numbering the letters in alphabetic order. Consider the keyword SAMPLE. The
    letter A comes earliest in alphabetic order, so it gets numbered 1\. Next in alphabetic
    order is E, which gets numbered 2\. Then L, M, P and S. So SAMPLE gets converted
    into the string 6,1,4,5,3,2\. If the same letter appears more than once, the occurrences
    are numbered from left to right. For example, ANACONDA becomes 1,6,2,4,8,7,5,3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 纵列置换使用的密钥可以是混合顺序的连续数字字符串，也可以是关键字或密语，通过将字母按字母表顺序编号来将其转换为数字字符串。考虑关键字SAMPLE。字母A在字母表中最早，因此编号为1。字母E在字母表中次序排在第二，编号为2。然后是L、M、P和S。因此SAMPLE转换为字符串6,1,4,5,3,2。如果同一字母出现多次，则按从左到右的顺序编号。例如，ANACONDA变为1,6,2,4,8,7,5,3。
- en: '![7-unnumb-2](../Images/7-unnumb-2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-2](../Images/7-unnumb-2.png)'
- en: 'Write the message into a grid horizontally from left to right. The number of
    columns is the size of the key. If the key is SAMPLE there are 6 columns. If the
    key is ANACONDA there are 8 columns. Write the numeric key above the grid, like
    this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息从左到右水平写入网格。列数等于密钥的大小。如果密钥是SAMPLE，则有6列。如果密钥是ANACONDA，则有8列。像这样在网格上方写下数字密钥：
- en: '![7-unnumb-3](../Images/7-unnumb-3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-3](../Images/7-unnumb-3.png)'
- en: Read the message out vertically top to bottom, according to the numeric key,
    starting with the column numbered 1, EKFHE, then column 2, ESRAT, column 3, NROW,
    through column 8, YCYI, as shown.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数字密钥从顶部到底部垂直读取消息，从编号为1的列开始，EKFHE，然后是列2，ESRAT，列3，NROW，直至列8，YCYI，如图所示。
- en: Riva, the legitimate receiver, needs to do a little arithmetic to read this
    message. The key length is 8 letters, and the message length is 35 letters. 35
    divided by 8 is 4 with a remainder of 3\. That means that the array will contain
    4 complete rows of 8 letters, plus a short row of 3 letters. Riva should draw
    the outline of this array before she starts filling in the columns so that she
    places the correct number of characters in each.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 合法接收者Riva需要做一点算术才能阅读此消息。密钥长度为8个字母，消息长度为35个字母。35除以8等于4，余数为3。这意味着数组将包含4行完整的8个字母，加上3个字母的短行。Riva应该在开始填写列之前画出此数组的轮廓，以便将正确数量的字符放入其中。
- en: The task for Emily, the enemy, is a little harder. The technique is to write
    the letters from each column vertically onto a strip of paper, and then match
    up those strips to determine the order of the columns. She looks for pairs of
    strips where the matching letters form common bigrams. When she gets a good match,
    she tries to add a third strip either before or after those two strips. Once 3
    or 4 strips are correctly matched, short words begin to appear and the task becomes
    easy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米莉，敌人的任务有点困难。技巧是将每列的字母垂直写在一条纸条上，然后将这些条纸对齐以确定列的顺序。她寻找那些匹配字母形成常见双字母组合的条纸对。当她找到一个好的匹配时，她尝试在这两个条纸之前或之后添加第三个条纸。一旦正确匹配了3或4个条纸，短单词就开始出现，任务变得容易起来。
- en: Emily does not know the length of the keyword, so she needs to guess it. She
    might start at 5 and work up. Let’s suppose she has gotten up to 8, the correct
    length. Like Riva she divides 35 by 8\. She knows that there are 5 short columns
    of 4 letters each, and 3 long columns of 5 letters each. Emily’s problem is where
    to start and end each strip so that it contains at least one full column.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米莉不知道关键字的长度，所以她需要猜测。她可能从5开始并逐渐增加。假设她已经增加到8，正确的长度。像丽娃一样，她将35除以8。她知道有5个由4个字母组成的短列，和3个由5个字母组成的长列。艾米莉的问题是在哪里开始和结束每个条纸，以便至少包含一个完整的列。
- en: The first strip starts at the first character of the ciphertext, and must be
    5 letters long in case the first column read out of the array was a long one.
    The second strip starts at the fifth letter of the ciphertext in case the first
    column was short, and ends at the tenth letter in case both the first and second
    columns were short. Similarly for the third and fourth strips. Then Emily will
    do the opposite for the other 4 strips, working from the last letter of the ciphertext
    backward toward the center.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条纸条从密文的第一个字符开始，如果第一列读出的数组是长列，则必须是5个字母长。第二条纸条从密文的第五个字母开始，如果第一列是短列，则在第十个字母结束。对于第三和第四条纸条也是如此。然后，艾米莉将对其他4条纸条做相反的操作，从密文的最后一个字母向中心反向工作。
- en: Emily will then match up the strips, sliding them against one another to determine
    the correct alignments. All of this is done by eye, so Emily must know the frequencies
    of the most common bigrams and trigrams by heart. This can also be done by computer
    in a simple, straightforward way.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，艾米莉将匹配这些条纸，将它们相互滑动以确定正确的对齐方式。所有这些都是凭眼睛完成的，所以艾米莉必须熟记最常见的双字母组合和三字母组合的频率。这也可以通过计算机以简单直接的方式完成。
- en: The most common countermeasure to this type of matching procedure is for Sandra,
    the sender, to read out some of the columns from top to bottom, and some of them
    from bottom to top. This means that Emily will need a second set of strips reading
    backward. She will then have twice as many strips to attempt to match up.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这种匹配程序的最常见对策是，发送者桑德拉从上到下读出一些列，从下到上读出另一些列。这意味着艾米莉需要一套读取反向的第二套条纸。然后她将有两倍多的条纸来尝试匹配。
- en: With all columns reading down, columnar transposition is rated Two if the array
    is a rectangle, and Three if it is not. With columns reading in alternating directions,
    columnar transposition is rated Three if the grid is a rectangle, or if the columns
    are long, and Four otherwise.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组是矩形，则所有列向下读取时，列置换评为二，如果不是，则评为三。如果网格是矩形，或者列很长并且交替方向读取时，列置换评为三，否则为四。
- en: Columnar transposition is a tried-and-true method for adding strength to any
    type of substitution cipher. Columnar transposition combined with a well-mixed
    keyed simple substitution is rated Five. When combined with a well-mixed general
    polyalphabetic cipher it is rated Seven. The combination is strongest if the lengths
    of the two keys are coprime.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列置换是一种为任何类型的替换密码增加强度的经过验证的方法。列置换与混合良好的简单替换相结合评为五。当与混合良好的一般多表密码相结合时，评为七。如果两个密钥的长度互质，则组合最强。
- en: The most common technique for strengthening a columnar transposition is to make
    some of the rows different lengths. This makes it harder for Emily to know where
    the strips should begin and end. Four such ideas are shown. Of these, number (4)
    is the strongest since it disrupts the strips at an unpredictable point in the
    middle, rather than at the ends. More elaborate patterns of blanks could have
    2 or more blanks in some columns.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 加强柱形置换的最常见技巧是使一些行的长度不同。这样会让艾米丽难以确定条带应该从哪里开始和结束。有四种这样的想法。其中，编号（4）是最强的，因为它在中间的一个不可预测的点破坏了条带，而不是在末端。更复杂的空白模式可能在某些列中有
    2 个或更多的空白。
- en: Columnar transposition with these variations is rated Four, provided that Emily
    does not know the pattern. The rating goes up to Five for variant (4) if the key
    is long and there are a variable number of blanks in the columns. The French used
    a system like this toward the end of World War I. It is believed that the Germans
    were able to read at least some of those messages, largely because the French
    reused their keys many times.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变种的柱形置换评分为四，前提是艾米丽不知道模式。如果密钥很长，并且列中有可变数量的空格，那么变种（4）的评分将提高到五。法国人在一战结束时使用了这样的系统。据信德国人能够读取其中至少一部分消息，主要是因为法国人多次重复使用了他们的密钥。
- en: '![7-unnumb-4](../Images/7-unnumb-4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-4](../Images/7-unnumb-4.png)'
- en: Two further variations on number (3), the staircase, are (5) start from column
    1 when you reach the right edge, making a skew pattern, and (6) reverse direction
    when you reach the right edge, creating a chevron or zigzag pattern. The advantage
    of these patterns is that the number of characters is the same on every row except
    possibly the last, making it very easy for Riva to calculate the number of rows.
    Here are examples of these two variations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对数字（3）的两个进一步变种，楼梯，是（5）当你到达右边缘时从第一列开始，形成一个斜线模式，和（6）当你到达右边缘时反向，创建一个燕尾或之字形图案。这些模式的优点是每一行的字符数除了最后一行可能不同外，其他都相同，这样瑞娃很容易计算行数。以下是这两种变体的示例。
- en: '![7-unnumb-5](../Images/7-unnumb-5.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-5](../Images/7-unnumb-5.png)'
- en: You can also have two or more separate staircases of different widths, or have
    staircases in both the diagonal and anti-diagonal directions **\** and **/**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以有两个或更多不同宽度的分开的楼梯，或者在对角线和反对角线方向上有楼梯 **\** 和 **/**。
- en: When you are deciphering a message sent with any of these columnar transposition
    variants, if you have any difficulty calculating how many rows are needed, or
    how long the last row is, here’s a trick. Count the letters in the message, and
    fill in the array left to right with that number of little dots, following the
    same pattern that Sandra used to write in the letters. Then fill in the letters
    over the dots.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你解密使用任何这些柱形置换变种发送的消息时，如果你有任何难以计算需要多少行，或者最后一行有多长的困难，这里有一个技巧。数一下消息中的字母，并从左到右用那么多的小点填写数组，按照桑德拉用来书写字母的相同模式。然后在点上填写字母。
- en: 'For example, in variant (2), suppose you have agreed that you will always start
    with 7 letters on the first row. Ciphertext (2) has 38 letters, so you put 7 dots
    on the first row, 8 dots on the second row, ... until you have placed a total
    of 38 dots. Then you start filling in the letters in their proper columns, replacing
    the dots like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在变种（2）中，假设你已经同意你将始终从第一行开始使用 7 个字母。密文（2）有 38 个字母，所以你在第一行放置了 7 个点，第二行放置了 8
    个点，直到你总共放置了 38 个点。然后你开始在它们的正确列中填写字母，像这样替换点：
- en: '![7-unnumb-6](../Images/7-unnumb-6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-6](../Images/7-unnumb-6.png)'
- en: Another way to use blacked-out squares is to fill them with nulls. The nulls
    should be chosen so they form uncommon letter pairs on both sides to make matching
    the columns harder for Emily. It is better to use common letters rather than rare
    letters, which might easily be recognized as nulls. Here is an example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有黑色方块的另一种方法是用空值填充它们。空值应该选择成为不常见的字母对，以使艾米丽更难匹配列。最好使用常见的字母而不是罕见的字母，这些字母可能很容易被识别为空值。这是一个例子。
- en: '![7-unnumb-7](../Images/7-unnumb-7.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-7](../Images/7-unnumb-7.png)'
- en: Columnar transposition with nulls is rated Three. With a fixed pattern of blacked-out
    spaces, the rating is Four.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有空格的柱形置换评为三。有固定的空格模式，评分为四。
- en: 7.2.1 Cysquare
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 Cysquare
- en: 'Historical tidbit: During World War II the British used a variant of this idea,
    called *Cysquare*, invented by Brigadier John H. Tiltman in 1941\. Cysquare was
    a columnar transposition cipher with lots of blackouts. The British issued pads
    of 26×26 grids with about 60% of the squares blacked out in a random pattern.
    Each page had a different pattern. The message was written into the white squares
    going across the rows, and then read out vertically in some order. The grid was
    square, so it could be used in any orientation.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 历史趣闻：在第二次世界大战期间，英国使用了这个想法的一个变体，称为*Cysquare*，由约翰·H·蒂尔特曼准将于1941年发明。Cysquare是一个具有大量涂黑的列置换密码。英国发行了26×26网格的填充物，大约60%的方块以随机模式涂黑。每页有不同的模式。消息被写入横跨行的白方块中，然后以某种顺序垂直读出。网格是正方形的，因此可以以任何方向使用。
- en: The key was the page number in the pad, the orientation, and the starting and
    ending positions within the grid. The cipher clerk would draw lines on the page
    to mark the message area. Using different areas allowed pages to be used for multiple
    messages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是填充物中的页码、方向以及网格内的起始和结束位置。密码员会在页面上画线标记消息区域。使用不同的区域可以让页面用于多条消息。
- en: The drawback was the need to distribute so many pads. To minimize the number
    of pads, the British used each page for a full day, for perhaps as many as 50
    messages. This meant writing faintly and erasing many times. The pages became
    unreadable, and eventually the cipher clerks refused to use them. Cysquare was
    abandoned in 1944.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点在于需要分发如此多的填充物。为了最小化填充物的数量，英国人每天将每页用于可能多达50条消息。这意味着要写得很淡并且擦拭多次。页面变得难以阅读，最终密码员拒绝使用它们。Cysquare在1944年被放弃了。
- en: After the Germans captured some of these pads, along with the instructions,
    they started using the system themselves, from 1944 until the end of the war.
    They called it *Rasterschlüssel*, meaning *Grid Key*. The Germans, however, did
    a poor job of selecting the black and white squares. They used too many adjacent
    white squares, so the British could identify bigrams and trigrams when they matched
    up the strips. These messages became a valuable source of intelligence for the
    British. Cysquare is rated Seven. Rasterschlüssel is rated Four.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 德国人在战争结束前从1944年开始使用这些填充物之一，连同说明书一起。他们开始自己使用这个系统，直到战争结束。他们称之为*Rasterschlüssel*，意思是*网格密钥*。然而，德国人在选择黑白方块时做得不好。他们使用了太多相邻的白方块，因此当他们将条带匹配时，英国人可以识别出二元组和三元组。这些消息成为英国情报的宝贵来源。Cysquare评分为七分。Rasterschlüssel评分为四分。
- en: It should be noted that in the computer era, the black and white squares could
    be transmitted as a pattern of bits, the grid could be any size, and the grid
    could be changed for every message. I suggest 65% to 75% black squares. Done this
    way, cysquare would be rated Eight.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在计算机时代，黑白方块可以作为比特模式传输，网格可以是任意大小，并且网格可以针对每条消息进行更改。我建议使用65%到75%的黑方块。这样做，cysquare将被评为八分。
- en: There is a simplified version of cysquare for hand use that does not require
    printed grids, and that allows you to use a numeric key to specify which squares
    are blacked out. Here are two variations of the *Blackout* transposition cipher,
    a left-right alternating version and a stairstep version. Both use the numeric
    key 3174255 for the blackouts. The blackout key can be a repeating key, or it
    could be generated by a pseudorandom number generator. You would use a separate
    key to specify the order for reading out the columns.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简化版本的cysquare可供手动使用，不需要印刷网格，并且允许您使用数字密钥指定哪些方块被涂黑。这里有两种*Blackout*置换密码的变体，一种是左右交替版本，另一种是阶梯版本。两者都使用数字密钥3174255进行涂黑。涂黑密钥可以是重复的密钥，或者可以由伪随机数生成器生成。您将使用单独的密钥指定读取列的顺序。
- en: '![7-unnumb-8](../Images/7-unnumb-8.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-8](../Images/7-unnumb-8.png)'
- en: Another method for strengthening columnar transposition is to break the text
    into blocks of irregular size. For instance, if the message length is 150 you
    could break it into blocks of 37, 71 and 42 letters. This method is rated Four.
    If you use a different key for each block, the rating increases to Five.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 加强列置换的另一种方法是将文本分成不规则大小的块。例如，如果消息长度为150，您可以将其分成37、71和42个字母的块。这种方法被评为四分。如果您为每个块使用不同的密钥，评分将提高到五分。
- en: Combining a columnar transposition with any type of substitution cipher greatly
    enhances its security. Even combined with a simple substitution the rating increases
    to Five because matching the strips is much harder. It makes no difference which
    one is done first. Combining a general polyalphabetic cipher with a columnar transposition
    of at least 12 columns increases the rating to Seven, even if the period of the
    polyalphabetic is as little as 3\. This is because you have essentially removed
    the possibility of matching the strips.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将栏式置换与任何类型的替换密码结合在一起会极大增强其安全性。即使与简单的替换结合，等级也会提高到五级，因为匹配条变得更加困难。哪个先做都没有关系。将通用多表密码与至少12列的栏式置换结合会将等级提高到七级，即使多表密码的周期只有3。这是因为您基本上消除了匹配条的可能性。
- en: 7.2.2 Word transposition
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 单词置换
- en: '*Word* *transposition* is a historically important columnar transposition based
    on words rather than letters. It is the main method used by the Union Army during
    the American Civil War. The idea came from Anson Stager, a Union telegrapher who
    later founded the Western Union telegraph company. Union Army communications were
    hampered by a high rate of transmission errors. In many cases commanding officers
    would forego the telegraph and simply send a messenger on foot or horseback. Stager
    realized that sending words instead of individual letters would cut the rate of
    errors, and reduce the need for retransmitting the messages.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*Word* *transposition* 是一个基于单词而不是字母的具有历史重要性的栏式置换。这是美国内战期间联邦军队使用的主要方法。这个想法来自安森·斯泰格（Anson
    Stager），一个后来创立了西联电报公司的联邦电报员。联邦军队的通信受到高传输错误率的影响。在许多情况下，指挥官们会放弃电报，而只是派遣步行或骑马的信使。斯泰格意识到，发送单词而不是单个字母将减少错误率，并减少重发消息的需要。'
- en: Union cipher clerks wrote the messages word by word from left to right in a
    rectangular array, and then read them out using a variety of routes, such as alternately
    going up and down the columns, or alternately taking columns from the left and
    right halves of the array. Null words were used liberally. Here is an example.
    Notice that the third row is nulls. The columns are read out in the order 1,3,5,2,4.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦密码员将消息逐字从左到右写成矩形数组，然后使用各种路线读出，例如交替上下读取列，或者交替从数组的左半部分和右半部分取列。空单词被大量使用。这里是一个例子。请注意第三行是空的。列按顺序读取为1,3,5,2,4。
- en: '![7-unnumb-9](../Images/7-unnumb-9.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-9](../Images/7-unnumb-9.png)'
- en: 7.3 Double columnar transposition
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 双栏式置换
- en: As the name implies, *double columnar transposition* means doing two columnar
    transpositions in succession, preferably with two different keys. This eliminates
    the possibility of matching strips. Remarkably, a general solution was found in
    1934 by Solomon Kullback and published by the Signals Intelligence Service. The
    31-page book was declassified in 1980 and published by Aegean Park Press. Aegean
    Park Press was for many years an invaluable resource for books on cryptography.
    It went out of business some time after 2001 when Wayne G. Barker, its founder,
    died, and the books became unavailable. I am happy to say that [www.openlibrary.org](http://www.openlibrary.org/)
    now has these books (accessed July 2019).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，*双栏式置换* 意味着连续进行两次栏式置换，最好使用两个不同的密钥。这消除了匹配条的可能性。值得注意的是，1934年，所罗门·库尔巴克（Solomon
    Kullback）找到了一个通用解决方案，并由信号情报局发布。这本31页的书在1980年解密，并由爱琴海公园出版社出版。爱琴海公园出版社多年来一直是密码学书籍的宝贵资源。在其创始人韦恩·G·巴克（Wayne
    G. Barker）去世后的2001年后不久，该公司停业，书籍不再可用。我很高兴地说，[www.openlibrary.org](http://www.openlibrary.org/)
    现在有这些书籍（2019年7月访问）。
- en: I will not repeat Kullback’s analysis here, except to say that it is based on
    determining where each plaintext letter will occur in the ciphertext. Instead,
    I will discuss 3 methods for defeating Kullback’s solution. (BTW, Kullback went
    to the same high school as my father, but 6 years earlier.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里重复库尔巴克的分析，除了说它是基于确定每个明文字母在密文中出现的位置。相反，我将讨论3种打败库尔巴克解决方案的方法。（顺便说一句，库尔巴克和我父亲上了同一所高中，只是早了6年。）
- en: 'One simple method is to change the shape of the grid by blacking out a few
    squares. These squares could form a rectangle, or some other shape, in one of
    the corners, or even in the middle of the grid. Here are some examples:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是通过涂黑几个方块来改变网格的形状。这些方块可以形成一个矩形，或者在一个角落，甚至在网格的中间形成其他形状。这里有一些例子：
- en: '![7-unnumb-10](../Images/7-unnumb-10.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-10](../Images/7-unnumb-10.png)'
- en: The blacked-out sections can have different sizes, shapes or locations for each
    of the two transposition steps. The size, shape and location of the blacked-out
    section(s) can be appended to the key, so that a different blackout is used for
    each message. Double columnar transposition is rated Four. Double columnar transposition
    with blackouts is rated Five.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 黑掉的部分在两个置换步骤中可以具有不同的大小、形状或位置。黑掉的部分的大小、形状和位置可以附加到密钥中，以便为每个消息使用不同的黑掉。具有黑掉的双栏置换等级为Five。
- en: The opposite method, called *NullBlock*, is also effective. You can insert a
    block of null characters into the intermediate ciphertext or the final ciphertext,
    or both. It is not helpful to add the null block to the plaintext. The size and
    location of the block can be specified by a numeric key. These should be varied
    from message to message.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的方法称为*NullBlock*，也很有效。您可以将一块空字符块插入中间密文或最终密文，或两者都插入。将空块添加到明文中并不有助于加密。块的大小和位置可以由数字密钥指定。这些应该在消息之间变化。
- en: Combining any transposition cipher with any substitution cipher strengthens
    both. Double columnar transposition combined with simple substitution is rated
    Six. Double columnar transposition combined with a general polyalphabetic substitution
    is rated Eight.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何置换密码与任何替换密码结合使用会增强两者的安全性。双栏置换与简单替换的组合等级为Six。双栏置换与通用多表替换的组合等级为Eight。
- en: 7.4 Cycling columnar transposition
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 循环栏置换
- en: Another variation on columnar transposition is *Cycling Columnar Transposition*.
    It comes in two flavors, horizontal cycling and vertical cycling. Horizontal cycling
    requires two keys, one for cycling the rows, and one to determine the column order.
    Begin by writing the message into a rectangular block left to right across the
    rows. Next write the cycling key vertically to the left of the rows. If there
    are more rows than the length of this key, repeat the key as many times as needed.
    If the cycling key is a word or phrase, convert it to numbers in the usual way
    using alphabetic order.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 栏置换的另一种变体是*循环栏置换*。它有两种变体，水平循环和垂直循环。水平循环需要两个密钥，一个用于循环行，一个用于确定列顺序。首先，从左到右将消息写入矩形块的行。接下来，在行的左侧写入循环密钥。如果行数多于此密钥的长度，则根据需要重复使用该密钥。如果循环密钥是一个词或短语，请使用字母顺序将其转换为数字。
- en: Once the cycling key is in numeric form, cycle each row left by the number of
    positions indicated. Then read out the letters vertically in the order specified
    by the column key. Here is an example using the cycling key CYCLES and the column
    key PAULREVERE.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将循环密钥转换为数字形式后，将每行向左循环移动所指定的位置数。然后按列密钥指定的顺序垂直读出字母。以下是使用循环密钥CYCLES和列密钥PAULREVERE的示例。
- en: '![7-unnumb-11](../Images/7-unnumb-11.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-11](../Images/7-unnumb-11.png)'
- en: The same method of matching up paper strips that was used to solve the columnar
    transposition still works for the cycling columnar transposition. It is only slightly
    harder because the last letter on each row is adjacent to the first letter, potentially
    forming a low-frequency bigram. This is at most a minor impediment to Emily. Columnar
    transposition with horizontal cycling is rated Three.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 解决栏置换所使用的匹配纸条方法也适用于循环栏置换。这只是稍微困难一点，因为每行的最后一个字母与第一个字母相邻，可能形成低频的二元组。这对Emily来说最多只是一个轻微的阻碍。具有水平循环的栏置换等级为Three。
- en: Vertical cycling is similar. Instead of cycling the rows of the block left,
    you cycle the columns of the block upward. Here is an example using the keyword
    CYCLE for cycling the columns and the keyphrase PAULREVERE for selecting the order
    in which the columns are read out.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直循环类似。不是将块的行向左循环移动，而是将块的列向上循环移动。以下是使用关键字CYCLE来循环列和使用密钥短语PAULREVERE来选择列读取顺序的示例。
- en: '![7-unnumb-12](../Images/7-unnumb-12.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-12](../Images/7-unnumb-12.png)'
- en: This cipher can still be solved by matching up paper strips, the same as a regular
    columnar transposition, but Emily will need two strips for each column, one for
    the top section and one for the bottom. When each column is cycled, some of the
    characters from the top of the column are moved to the bottom, and become the
    new bottom section. The remaining letters move upward and become the new top section.
    In the example, the left column **ODYTEL** moves up 1 position, so **DYTEL** becomes
    the new top section, and **O** becomes the new bottom section. These sections
    need to be on separate strips because Emily does not know whether these letters
    came from a long column or a short column. This makes the matching process considerably
    harder. Columnar transposition with vertical cycling is rated Four.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种密码仍然可以通过匹配纸条来解决，就像普通的栏置换一样，但 Emily 需要为每个列使用两条纸条，一条用于顶部部分，一条用于底部部分。当每列循环时，某些字符从列的顶部移动到底部，并成为新的底部部分。剩下的字母向上移动，并成为新的顶部部分。在例子中，左列
    **ODYTEL** 向上移动 1 个位置，所以 **DYTEL** 成为新的顶部部分，**O** 成为新的底部部分。这些部分需要放在不同的纸条上，因为 Emily
    不知道这些字母是来自长列还是短列。这使得匹配过程变得相当困难。带有垂直循环的栏置换被评为 Four。
- en: It is feasible to perform both vertical and horizontal cycling on the block.
    This is comparable in strength to double columnar transposition. Remember, though,
    that the more complex you make your cipher the more time it takes, and the more
    difficult it is both to encipher and to decipher accurately. *Double cycling columnar
    transposition* is rated Five.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个区块上可以执行垂直和水平循环。这与双栏置换的强度相当。但请记住，你的密码越复杂，花费的时间就越长，而且正确地加密和解密也就越困难。*双循环栏置换*
    被评为 Five。
- en: 7.5 Random number transposition
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 随机数置换
- en: Let’s look at an entirely different type of transposition. This transposition
    does not involve any sort of array or grid. Instead, it simply numbers the letters
    in the message randomly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个完全不同类型的置换。这种置换不涉及任何形式的数组或网格。相反，它只是随机对消息中的字母进行编号。
- en: 'You can use any random number generator. There are several presented in chapter
    13\. The only random number generator I have described so far is the chained digit
    generator in section 4.5.1, so let’s use that generator to illustrate. Generate
    one random digit for each letter of the message, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何随机数生成器。第 13 章中介绍了几种随机数生成器。到目前为止，我只描述了第 4.5.1 节中的链式数字生成器，所以让我们使用那个生成器来说明。为消息的每个字母生成一个随机数字，像这样：
- en: '![7-unnumb-13](../Images/7-unnumb-13.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-13](../Images/7-unnumb-13.png)'
- en: First take all of the letters numbered 1, going left to right. These are C,
    V and I.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先取所有从左到右编号为 1 的字母。这些是 C、V 和 I。
- en: '![7-unnumb-14](../Images/7-unnumb-14.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-14](../Images/7-unnumb-14.png)'
- en: Next take all of the letters numbered 2\. These are A, O and L.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来取所有编号为 2 的字母。这些是 A、O 和 L。
- en: '![7-unnumb-15](../Images/7-unnumb-15.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-15](../Images/7-unnumb-15.png)'
- en: Then take all of the letters numbered 3, namely N, E, E and M.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后取所有编号为 3 的字母，即 N、E、E 和 M。
- en: '![7-unnumb-16](../Images/7-unnumb-16.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-16](../Images/7-unnumb-16.png)'
- en: Continue this way until all of the letters have been taken.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 持续这样做，直到所有的字母都被取走。
- en: 'To decipher this message, Riva would first generate the random digits. There
    are three 1’s, so she would write the first 3 letters of the ciphertext, **CVI**,
    under the three 1’s, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密这条消息，Riva 首先会生成随机数字。有三个 1，所以她会在三个 1 下面写下密文的前 3 个字母 **CVI**，像这样：
- en: '![7-unnumb-17](../Images/7-unnumb-17.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-17](../Images/7-unnumb-17.png)'
- en: 'Riva would write the next 3 letters of the ciphertext, **AOL**, under the 2’s,
    like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Riva 会将密文的下一个 3 个字母 **AOL** 写在 2 下面，像这样：
- en: '![7-unnumb-18](../Images/7-unnumb-18.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-18](../Images/7-unnumb-18.png)'
- en: and so forth.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推。
- en: Random number transposition is rated Four. It can be broken by trying all possible
    seeds for the random number generator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数置换被评为 Four。可以通过尝试所有可能的随机数生成器种子来破解它。
- en: The cipher can be strengthened by using a longer seed, or by selecting letters
    from the plaintext using the 10 digits in an order other than 1, 2, 3, ... This
    is equivalent to applying a simple substitution to the outputs of the random number
    generator. For example, if you wanted to start with the letters marked 4, then
    you would change all the 4’s into 1’s. If you next wanted to take all of the letters
    marked 7, you would change all 7’s into 2’s, and so forth. Then you proceed as
    described. This increases the number of possible keys by a factor of 10!, or 3,628,800.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用更长的种子或通过以1、2、3、...以外的顺序选择明文中的字母来增强密码。 这相当于对随机数生成器的输出应用简单的替换。 例如，如果您想从标记为4的字母开始，那么您将把所有的4改为1。
    如果接下来想要取出所有标记为7的字母，那么您将把所有的7改为2，依此类推。 然后按照描述的方式进行。 这将使可能的密钥数量增加到10！，即3,628,800。
- en: With this improvement, chained digit transposition is rated Five. For a computer
    version, where the random number generator produces random bytes, the method is
    rated Seven because there are so many possible orders for rearranging the 256
    different bytes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种改进，链式数字置换评级为五。 对于计算机版本，其中随机数生成器产生随机字节，该方法评级为七，因为重新排列256个不同字节的可能顺序太多。
- en: 7.6 Selector transposition
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 选择器置换
- en: Since we are looking at random numbers, let’s look at a different transposition
    cipher based on random numbers, namely a *Selector Transposition*. The idea is
    to break the message into roughly equal pieces, and then to merge those pieces
    using the random number sequence.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在研究随机数，让我们看看基于随机数的另一种置换密码，即*选择器置换*。 思路是将消息分成大致相等的部分，然后使用随机数序列合并这些部分。
- en: Suppose the plaintext has 100 characters, and you want to split it into 3 parts.
    Assume you have a random number generator that produces the digits 0, 1 and 2
    with equal probability, and that you have chosen a seed, which acts as the key
    for the transposition. You need to know how big to make each part of the message.
    This is easily done. Just generate the first 100 random digits, and count how
    many of each digit are produced. Say there are 36 zeros, 25 ones and 39 twos.
    You would slice the message into 3 pieces, P0 with 36 letters, P1 with 25 letters
    and P2 with 39 letters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设明文有100个字符，你想将其分成3部分。 假设你有一个随机数生成器，以相等的概率产生数字0、1和2，并且你已经选择了一个种子，它作为置换的密钥。 你需要知道如何将消息的每个部分做多大。
    这很容易做到。 只需生成前100个随机数字，并计算产生的每个数字的数量。 假设有36个零，25个一和39个二。 你将消息切成3部分，P0有36个字母，P1有25个字母，P2有39个字母。
- en: Enciphering is easy. Each time the generator produces a 0, take the next letter
    from P0\. Each time the generator produces a 1, take the next letter from P1\.
    Each time the generator produces a 2, take the next letter from P2\. Deciphering
    is even easier, because Riva does not need to know how large each piece had been.
    Each time she gets a 0, she puts the next letter into P0\. Each time she gets
    a 1, she puts the next letter into P1\. Each time she gets a 2, she puts the next
    letter into P2\. Then she concatenates the 3 pieces, or she simply reads the message
    ignoring the line breaks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 加密很容易。 每当生成器产生一个0时，从P0中取下一个字母。 每当生成器产生一个1时，从P1中取下一个字母。 每当生成器产生一个2时，从P2中取下一个字母。
    解密甚至更容易，因为Riva不需要知道每个部分有多大。 每当她得到一个0时，她将下一个字母放入P0中。 每当她得到一个1时，她将下一个字母放入P1中。 每当她得到一个2时，她将下一个字母放入P2中。
    然后她连接这3个部分，或者简单地忽略换行符读取消息。
- en: When this is done with only 2 pieces, it is trivial for Emily to reconstruct
    the message. The rating is One. With 3 pieces it is a bit harder, and the rating
    is Two. With 20 or more pieces, the rating is Five.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当只用2部分完成时，Emily可以轻松重构消息。 评级为一。 用3部分时稍微困难，评级为二。 用20个或更多部分时，评级为五。
- en: 7.7 Key transposition
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 密钥置换
- en: Sometimes it is preferable to transpose a message one block at a time. The best
    choice for transposing blocks is a *key transposition*. Write the numerical key
    above the characters of the message, then move each character to the position
    indicated by its key number. In this example, the block size is 8, and the numeric
    key is 41278563\. The key number for the first letter, **R**, is 4, so move the
    **R** to the fourth position in the block. The key number for the second letter,
    **U**, is 1, so move the **U** to the first position in the block, and so forth.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，逐块移位消息是首选。用于置换块的最佳选择是 *主要置换*。在消息的字符上方写下数字密钥，然后将每个字符移动到其密钥编号指示的位置。在此示例中，块大小为
    8，数字密钥为 41278563。第一个字母 **R** 的密钥编号为 4，因此将 **R** 移动到块中的第四个位置。第二个字母 **U** 的密钥编号为
    1，因此将 **U** 移动到块中的第一个位置，依此类推。
- en: '![7-unnumb-19](../Images/7-unnumb-19.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-19](../Images/7-unnumb-19.png)'
- en: The key transposition may be used on the plaintext, the ciphertext or both.
    A key transposition by itself is weak. Key transposition is rated One to Three
    depending on the block size.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 主要置换可以用于明文、密文或两者。仅使用主要置换是弱的。根据块大小，主要置换的等级从一到三。
- en: '*****Let’s take a deeper look at transpositions. In mathematics, transpositions
    are called *permutations*. Here is an example. I have used the hexadecimal digits
    A, B and C to denote the numbers 10, 11 and 12\. In a cipher, these numbers will
    represent the bits, letters or other units that are being permuted.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*****让我们深入了解置换。在数学中，置换被称为 *排列*。这里有一个例子。我用十六进制数字 A、B 和 C 来表示数字 10、11 和 12。在密码中，这些数字将代表被置换的位、字母或其他单元。'
- en: '![7-unnumb-20](../Images/7-unnumb-20.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-20](../Images/7-unnumb-20.png)'
- en: The top line is standard. It represents the original order, before the permutation.
    The second line is the permuted order. Later in this section, the second line
    will be used to describe permutations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 顶行是标准的。它表示置换之前的原始顺序。第二行是置换后的顺序。在本节的后面，第二行将用于描述置换。
- en: In this permutation, the number in position 1 moves to position 4, the number
    in position 4 moves to position 7, the number in position 7 moves to position
    12, the number in position 12 moves to position 3, and the number in position
    3 moves to position 1, completing the cycle **1****➔****4****➔****7****➔****C****➔****3****➔****1**.
    The cycle can be represented as (1,4,7,12,3).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此置换中，位置 1 的数字移动到位置 4，位置 4 的数字移动到位置 7，位置 7 的数字移动到位置 12，位置 12 的数字移动到位置 3，位置 3
    的数字移动到位置 1，完成循环 **1****➔****4****➔****7****➔****C****➔****3****➔****1**。循环可以表示为
    (1,4,7,12,3)。
- en: The first number that is not in this cycle is 2\. Starting from position 2 we
    find the cycle **2****➔****A****➔****6****➔****9****➔****B****➔****8****➔****5****➔****2**,
    which can be represented as (2,10,6,9,11,8,5). The whole permutation can then
    be expressed as (1,4,7,12,3) (2,10,6,9,11,8,5).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不在此循环中的第一个数字是 2。从位置 2 开始，我们找到循环 **2****➔****A****➔****6****➔****9****➔****B****➔****8****➔****5****➔****2**，可以表示为
    (2,10,6,9,11,8,5)。整个置换可以表示为 (1,4,7,12,3) (2,10,6,9,11,8,5)。
- en: These two cycles have periods of 5 and 7, respectively, so this permutation
    has a period of 35\. That is, if you kept applying this transposition to a block
    of 12 letters, it would produce 35 different permutations of the letters, and
    the 36th permutation would be the same as the original plaintext.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个循环的周期分别为 5 和 7，因此此置换的周期为 35。也就是说，如果你将此置换一直应用到一个由 12 个字母组成的块上，它将产生 35 种不同的字母置换，而第
    36 种置换将与原始明文相同。
- en: Suppose that you wanted to produce a strong block transposition cipher, one
    where every block has a different transposition. Applying the previous transposition
    a different number of times for each block would not be adequate because it repeats
    every 35 cycles. This problem can be overcome by using two different permutations
    and alternating.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要生成一个强大的块置换密码，其中每个块都有不同的置换。对于每个块分别应用先前的置换不足够，因为它每 35 个周期就重复一次。可以通过使用两个不同的置换并交替使用来解决这个问题。
- en: Let the two transpositions be A and B. If A and B are suitably chosen, then
    you can generate a huge number of transpositions A, B, AA, AB, BA, BB, AAA, AAB,
    ABA, ... that are all different.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让两个置换分别是 A 和 B。如果 A 和 B 被适当选择，那么你可以生成大量不同的置换 A、B、AA、AB、BA、BB、AAA、AAB、ABA，...。
- en: This is where understanding the cycle structure of the permutations becomes
    important. Suppose that you chose the permutations (1,4,7,12,3) (2,10,6,9,11,8,5)
    and (1,4,3,12,7) (2,10,9,6,5,11,8). These two permutations partition the block
    of 12 units the same way, namely [1,3,4,7,12] and [2,5,6,8,9,10,11]. When you
    alternate the two permutations repeatedly, the [1,3,4,7,12] partition will get
    permuted separately from the [2,5,6,8,9,10,11] partition. That is, there is no
    interaction between the two sets of numbers. To get a long period, each cycle
    of the second permutation should overlap each cycle of the first permutation as
    much as possible. Here is a suitable set of permutations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 理解排列的循环结构变得很重要。假设你选择了排列 (1,4,7,12,3) (2,10,6,9,11,8,5) 和 (1,4,3,12,7) (2,10,9,6,5,11,8)。这两个排列以相同的方式划分了
    12 个单位的块，即 [1,3,4,7,12] 和 [2,5,6,8,9,10,11]。当你交替使用这两个排列时，[1,3,4,7,12] 的分区将与 [2,5,6,8,9,10,11]
    的分区分别排列。也就是说，这两组数字之间没有相互作用。为了获得长周期，第二个排列的每个循环应尽可能与第一个排列的每个循环重叠。下面是一组适合的排列。
- en: (1,4,7,12,3) (2,10,6,9,11,8,5)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: (1,4,7,12,3) (2,10,6,9,11,8,5)
- en: (1,10,8) (4,6,5,12) (2,11,9,7,3)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (1,10,8) (4,6,5,12) (2,11,9,7,3)
- en: This transposition cipher is rated Three. It can be solved simply by trying
    all of the 12! possible permutations for the first block. This is only 4.79×10⁸.
    For each permutation that produces reasonable text for the first block, Emily
    can try each of the 12! permutations for the second block. In practice this takes
    far fewer than (12!)² = 2.29×10^(17) tries because just looking at the first 3
    or 4 characters of the block can eliminate many implausible combinations. In fact,
    it is feasible to solve this cipher by hand methods. The difficulty increases
    slowly with larger block sizes.******
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转位密码被评为三。它可以通过尝试所有 12! 种可能的排列来简单解决第一个块。这只有 4.79×10⁸。对于为第一个块生成合理文本的每个排列，艾米莉可以尝试第二个块的
    12! 种排列。实际上，这并不需要 (12!)² = 2.29×10^(17) 次尝试，因为仅查看块的前 3 或 4 个字符就可以消除许多不合理的组合。事实上，通过手工方法解决这个密码是可行的。随着块大小的增加，难度增加得很慢。
- en: There are several ways to increase the security of a key transposition. One
    way is to overlap the blocks. If the block size is 16, for example, instead of
    starting the blocks at positions 1, 17, 33, ... in the message, start the blocks
    at positions 1, 9, 17, 25, 33, ... . That way, each block overlaps 8 units with
    the block before, and 8 units with the block after. The last 8 units of the message
    may be combined with the first 8 units to form a wraparound block. This cipher
    is rated Four.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种增加密钥置换安全性的方法。一种方法是重叠块。例如，如果块大小为 16，则在消息中不是从位置 1、17、33、... 开始块，而是从位置 1、9、17、25、33、...
    开始块。这样，每个块与前一个块重叠 8 个单位，并且与后一个块重叠 8 个单位。消息的最后 8 个单位可以与前 8 个单位组合成一个环绕块。这个密码被评为四。
- en: The amount of overlap can be variable. If the current block starts at position
    P, and the block length is L, the next block can begin anywhere from position
    P+1 to position P+L. This cipher is rated Five. If two different transpositions
    are used, and chosen randomly, the rating increases to Seven.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重叠量可以是可变的。如果当前块从位置 P 开始，块长度为 L，则下一个块可以从位置 P+1 到位置 P+L 的任何位置开始。这个密码被评为五。如果使用两个不同的转位，并随机选择，评分将提高到七。
- en: '*****A second way to strengthen a block transposition cipher is by composing
    the permutations. If T and U are transpositions, then the composition of T and
    U, denoted TU, is formed by first performing transposition U and then performing
    T. The resulting transposition is the same as using T to transpose U and then
    transposing the text using the resulting transposition. Let’s try an example.
    Suppose T is **419628573** and U is **385917462**. Since U is a block of 10 characters,
    you can use T to transpose U the same way you would use T to transpose a 10-letter
    word. Write T on the top line to use as the transposition key, and write U on
    the second line as the text being transposed. The first digit of the result is
    the number below the digit 1 in the key, namely **8** (see shading). The second
    digit of the result is the digit below 2 in the key, namely **1**, and so forth.
    Using T to permute U gives **812349675**.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*****加强块置换密码的第二种方法是通过组合置换。如果T和U是转置，则T和U的组合，表示为TU，是通过首先执行转置U然后执行T而形成的。结果的转置与使用T转置U然后使用结果的转置转置文本相同。让我们试试一个例子。假设T是**419628573**，U是**385917462**。由于U是一个包含10个字符的块，您可以使用T来转置U，就像您使用T来转置一个10字母的单词一样。将T写在顶行上用作置换键，并将U写在第二行上作为被转置的文本。结果的第一个数字是键中数字1下面的数字，即**8**（见阴影）。结果的第二个数字是键中数字2下面的数字，即**1**，依此类推。使用T来排列U得到**812349675**。'
- en: '![7-unnumb-21](../Images/7-unnumb-21.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-21](../Images/7-unnumb-21.png)'
- en: Composing transpositions this way lets you generate a sequence of transpositions,
    U, TU, TTU, TTTU, ... . The period of this sequence is the same as the period
    of T. For a block size of 12, the longest possible period occurs when the lengths
    of the cycles are 3, 4 and 5, namely 3×4×5 = 60\. If your messages are longer
    than 60 blocks, you may want a longer period. This can be done by permuting the
    transposition with either U or T in some repeating or random pattern, say U, TU,
    TTU, UTTU, UUTTU, ... This can generate a very large set of distinct transpositions,
    provided that T and U individually have long periods, and the cycles of T overlap
    the cycles of U, as described earlier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式组合转置，您可以生成一个转置序列，U，TU，TTU，TTTU，... 。此序列的周期与T的周期相同。对于块大小为12，当循环的长度为3、4和5时，最长可能的周期为3×4×5
    = 60\. 如果您的消息长于60个块，则可能需要更长的周期。这可以通过以某种重复或随机模式排列转置与U或T之一来完成，例如U，TU，TTU，UTTU，UUTTU，...
    这可以生成一个非常大的不同转置集合，前提是T和U各自具有较长的周期，并且T的循环重叠U的循环，如前文所述。
- en: You can test whether the cycles overlap sufficiently by using the *accretion
    test*. Start with any one of the cycles of T or U. This forms a set containing
    just that one cycle. Add to this set any other cycle of T or U that has elements
    in common with it. Now add to this larger set any other cycle of T or U that has
    elements in common with the cycles you have already chosen. Continue this way
    until there are no more elements in common. If the set of cycles now contains
    all of the cycles of both T and U, then you have good overlap. If you decide to
    use more than two transpositions, say T, U and V, then T and U should overlap,
    T and V should overlap, and U and V should also overlap.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*累积测试*来测试循环是否重叠足够。从T或U的任何一个循环开始。这形成一个只包含该循环的集合。将与其具有共同元素的T或U的任何其他循环添加到该集合中。现在将具有与您已选择的循环具有共同元素的T或U的任何其他循环添加到此较大的集合中。继续这样做，直到没有更多的共同元素为止。如果循环集现在包含T和U的所有循环，则具有很好的重叠。如果您决定使用超过两个转置，比如T，U和V，则T和U应该重叠，T和V应该重叠，U和V也应该重叠。
- en: Here is an example using some transpositions from earlier in this section, T
    = (1,4,7,12,3) (2,10,6,9,11,8,5) and U = (1,10,8) (4,6,5,12) (2,11,9,7,3). Start
    with the cycle (1,4,7,12,3).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，使用本节早些时候的一些转置，T = (1,4,7,12,3) (2,10,6,9,11,8,5)，U = (1,10,8) (4,6,5,12)
    (2,11,9,7,3)。从循环(1,4,7,12,3)开始。
- en: (1,4,7,12,3)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (1,4,7,12,3)
- en: This has the element 1 in common with the cycle (1,10,8) of U, so add that cycle
    to the set.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个与循环U的(1,10,8)共有元素1，因此将该循环添加到集合中。
- en: (1,4,7,12,3) (1,10,8)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (1,4,7,12,3) (1,10,8)
- en: This has the element 4 in common with the cycle (4,6,5,12) of U, so add that
    cycle to the set.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个与循环U的(4,6,5,12)共有元素4，因此将该循环添加到集合中。
- en: (1,4,7,12,3) (1,10,8) (4,6,5,12)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: (1,4,7,12,3) (1,10,8) (4,6,5,12)
- en: And so forth. Since this will include all of the cycles of T and U, they are
    a good overlapping pair of transpositions, and will generate a very large family
    of transpositions when they are composed.******
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。因为这将包括T和U的所有循环，它们是很好的重叠对，当它们组合时会产生非常庞大的转置家族。******
- en: 7.8 Halving transposition
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 分半置换
- en: '*Halving* *transposition* is a computer technique I invented that uses a binary
    key to swap units that may be either bits or bytes, or possibly hex digits. IBM
    published this in the company’s Invention Disclosure Bulletin, and it was considered
    for possible inclusion in the Data Encryption Standard (DES). Halving transposition
    operates on a block whose size is some power of 2, typically 32 or 64 units. For
    a block of n units, the key will have n-1 bits.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*分半* *置换* 是我发明的一种计算机技术，使用二进制密钥交换可能是位或字节，或者可能是十六进制数字的单元。IBM在公司的发明披露公告中发布了这一技术，并考虑将其纳入数据加密标准（DES）中。分半置换作用于块的大小为2的某个幂次方，通常为32或64个单元。对于n个单元的块，密钥将有n-1位。'
- en: Let’s use a block size of 16 characters as an example. The plaintext is GEORGE
    WASHINGTON. The transposition will use a 15-bit key. The first bit of the key
    determines whether the left and right 8-unit halves of the block are swapped.
    A 0 means no swap, a 1 means swap the halves. The next 2 key bits determine whether
    the 4-unit halves of those halves are swapped. If bit 2 of the key is 1 then the
    first quarter of the block is swapped with the second quarter. If bit 3 of the
    key is 1 then the third quarter of the block is swapped with the fourth quarter.
    The next 4 bits of the key determine whether the halves of those quarters get
    swapped. For example, if the fourth bit of the key is 1 then the first eighth
    of the block is swapped with the second eighth. The final 8 bits control whether
    the sixteenths of the block get swapped. For example, if the last bit of the key
    is 1 then the last 2 units, the 15th and 16th units of the block, letters O and
    N, are swapped.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以16个字符的块大小为例。明文是乔治·华盛顿。置换将使用一个15位的密钥。密钥的第一位确定了块的左右8单元半部分是否交换。0表示不交换，1表示交换两部分。接下来的2位密钥位确定了这些半部分的4单元是否交换。如果密钥的第2位是1，则块的第一季度与第二季度交换。如果密钥的第3位是1，则块的第三季度与第四季度交换。密钥的接下来的4位确定了这些季度的半部分是否交换。例如，如果密钥的第四位是1，则块的第一八分之一与第二八分之一交换。最后的8位控制了块的16分之一是否交换。例如，如果密钥的最后一位是1，则块的最后2个单元，第15和第16个单元，字母O和N被交换。
- en: '![7-unnumb-22](../Images/7-unnumb-22.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-22](../Images/7-unnumb-22.png)'
- en: To decipher this transposition the steps must be done in the reverse order.
    That is, the individual units should be swapped first, then the pairs, foursomes,
    and so forth.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密这个置换，步骤必须按相反顺序进行。也就是说，首先应该交换单元，然后是对、四个一组等。
- en: 7.9 Multiple anagramming
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9 多次变位
- en: A general technique for solving transposition ciphers, one that works with many
    types of transpositions, even when the type is unknown, is *multiple anagramming*.
    To use the technique, you need to intercept several messages of the same length.
    If these messages have been transposed with the same key, then the first letters
    of each message will end up in the same position in all of the ciphertexts, the
    second letters will end up in the same position in all of the ciphertexts, and
    so forth.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 解决置换密码的一般技术，适用于许多类型的置换，即使类型未知，也是*多次变位*。要使用这种技术，您需要拦截几条相同长度的消息。如果这些消息使用相同的密钥进行置换，那么每条消息的第一个字母将在所有密码文本中的相同位置，第二个字母将在所有密码文本中的相同位置，依此类推。
- en: We can exploit this fact. Make paper strip 1 with all of the first letters in
    the ciphertexts. Make paper strip 2 with all of the second letters in the ciphertexts,
    and so forth. Make as many strips as the length of each ciphertext. These strips
    can be matched up just the way we did when we solved a columnar transposition.
    The more messages that are available, the longer the strips will be, and the greater
    the chance of success. It is generally felt that a minimum of 3 messages are required.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一事实。用所有密码文本中的第一个字母制作纸条1。用所有密码文本中的第二个字母制作纸条2，依此类推。制作与每个密码文本长度相同的纸条。这些纸条可以像解决列置换时那样匹配。可用的消息越多，纸条就越长，成功的机会就越大。通常认为需要至少3条消息。
- en: 'Let’s look at an example. Suppose we have these 3 cipher messages:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。假设我们有这3个密码消息：
- en: '![7-unnumb-23](../Images/7-unnumb-23.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-23](../Images/7-unnumb-23.png)'
- en: The message length is 12\. The 12 strips are shown to the right.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 消息长度为12。右侧显示了12条条带。
- en: Message (1) contains a K. Some likely letters to precede that K are C and N.
    Message (1) contains one of each. Message (2) contains a D. A likely letter to
    precede the D is N. Message (2) contains one N. Let’s check that these are plausible
    choices. We have
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 消息（1）包含一个K。可能在K之前的字母有C和N。消息（1）各包含一个。消息（2）包含一个D。在D之前可能的字母是N。消息（2）包含一个N。让我们检查这些是否是合理的选择。我们有
- en: '![7-unnumb-24](../Images/7-unnumb-24.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-24](../Images/7-unnumb-24.png)'
- en: 'In message (2) the most likely letter to precede **ND** is **A** or **E**.
    This gives 3 possibilities:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息（2）中，最有可能在**ND**之前的字母是**A**或**E**。这给出3种可能性：
- en: '![7-unnumb-25](../Images/7-unnumb-25.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-25](../Images/7-unnumb-25.png)'
- en: Matching each of these 3 choices with the remaining 9 strips, the best match
    is with strip 4.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将这3个选择与剩下的9条纸条进行匹配，最佳匹配是与第4条纸条。
- en: '![7-unnumb-26](../Images/7-unnumb-26.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-26](../Images/7-unnumb-26.png)'
- en: This matches up well with columns 5 and 10, which we had already combined previously.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前已经组合的第5列和第10列非常匹配。
- en: '![7-unnumb-27](../Images/7-unnumb-27.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![7-unnumb-27](../Images/7-unnumb-27.png)'
- en: The 3 messages are now easily completed, (1) ATTACK AT DAWN, (2) SEND MORE AMMO,
    and (3) MEET ME AT ONCE.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这3条消息很容易完成，（1）黎明时攻击，（2）发送更多弹药，和（3）立即见我。
