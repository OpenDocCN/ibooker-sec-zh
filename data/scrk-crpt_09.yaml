- en: 9 Fractionation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 分数化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The Polybius square
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Polybius方阵
- en: Splitting a letter into smaller parts, such as bits or hexadecimal digits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一封信拆分成较小的部分，如比特或十六进制数字
- en: Mixing and recombining those parts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合和重新组合这些部分
- en: The first two basic tools of cryptography are substitution and transposition,
    which are covered in chapters 5 through 8\. The third fundamental element of cryptography
    is fractionation. This means breaking the normal units of language, letters, syllables
    and words into smaller units and operating on those units. The smaller units are
    commonly bits, decimal digits, hexadecimal digits, or digits in other number bases.
    This chapter covers fractionation using digits in bases 2, 3, 5, 6, and 16, plus
    some other forms of fractionation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学的前两个基本工具是替换和置换，这些内容涵盖在第5至8章。密码学的第三个基本元素是分数化。这意味着将语言的正常单位，即字母、音节和单词，拆分为较小的单位并对这些单位进行操作。较小的单位通常是比特、十进制数字、十六进制数字或其他进制的数字。本章涵盖了使用2、3、5、6和16进制的数字进行分数化，以及其他形式的分数化。
- en: 9.1 Polybius square
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 Polybius方阵
- en: Possibly the oldest method for representing letters as smaller units is the
    *Polybius Square*, which we saw in section 4.4\. Here each letter is represented
    by two base-5 digits, making 25 possible 2-digit combinations. (The Greeks did
    not have a representation for 0, so their digits started at 1.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是将字母表示为较小单位的最古老方法是*Polybius方阵*，我们在第4.4节中看到过。在这里，每个字母由两个基数5位数字表示，共有25种可能的2位数字组合。（希腊人没有0的表示，因此他们的数字从1开始。）
- en: Here is the Polybius square from section 4.4\. Each letter is represented by
    its *coordinates* in the square, that is, by its row and column numbers. For example,
    the letter P is on row 2 in column 5, so it is represented as 25\. When needed
    for clarity this can also be written as 2,5.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第4.4节的Polybius方阵。每个字母都用方阵中的*坐标*表示，即通过其行号和列号表示。例如，字母P在第2行第5列，因此表示为25。需要时，为了清晰起见，也可以写成2,5。
- en: '![9-unnumb-1](../Images/9-unnumb-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-1](../Images/9-unnumb-1.png)'
- en: A Polybius square by itself can produce a number of different ciphers. For example,
    it can produce a simple substitution by replacing each letter in a message by
    the letter to the right in the square (U becomes **V**), or below (U becomes **Z**),
    or below and to the right (U becomes **S**) or left (U becomes **P**), and so
    forth. This idea can be extended to a polyalphabetic cipher by changing directions,
    say right, left, down, right, left, down, etc. You can also go 2 letters away
    or use knight moves, as in chess.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Polybius方阵本身可以产生多种不同的密码。例如，它可以通过用方阵中右边的字母（U变成**V**）、下面的字母（U变成**Z**）、下面和右边的字母（U变成**S**）或左边的字母（U变成**P**）等方式产生简单的替换。这个想法可以通过改变方向来扩展为多表密码，比如向右、向左、向下、向右、向左、向下等。你也可以走2个字母的距离或使用象棋中的骑士走法。
- en: A Polybius square can also be used to produce a *Polybius Ripple* cipher. Begin
    by replacing each letter of the message by its coordinates, simply written out
    in one line. Starting with the second number in this list, add the previous number
    to the current number. If the sum is more than 5, subtract 5 to keep the numbers
    in the range 1 to 5\. Then turn these numbers back into letters using the Polybius
    square again.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Polybius方阵也可以用于生成*Polybius Ripple*密码。首先，将消息中的每个字母替换为其坐标，简单地写在一行中。从此列表中的第二个数字开始，将前一个数字加到当前数字上。如果总和超过5，减去5以保持数字在1到5的范围内。然后再次使用Polybius方阵将这些数字转换回字母。
- en: '![9-unnumb-2](../Images/9-unnumb-2.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-2](../Images/9-unnumb-2.png)'
- en: The Polybius ripple cipher is rated Three. The cipher can be strengthened by
    using a different Polybius square for converting the coordinates back to letters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Polybius涟漪密码评级为三。通过使用不同的Polybius方阵将坐标转换回字母，可以加强密码。
- en: Let’s look at a few hand ciphers from the 1800s based on the Polybius square
    in sections 9.2 to 9.7\. I cover some additional hand methods in sections 9.8
    to 9.11\. Then I discuss some computer methods in the rest of the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下基于Polybius方阵的几种手写密码，涵盖在第9.2至9.7节。我在第9.8至9.11节中介绍了一些额外的手写方法。然后我在本章的其余部分讨论了一些计算机方法。
- en: 9.2 Playfair
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 Playfair
- en: The *Playfair* cipher was invented by Charles Wheatstone (pronounced WHIT-stun)
    in 1854\. Wheatstone is well-known among electrical engineers as the inventor
    of the Wheatstone bridge, which measures electrical resistance. Wheatstone and
    William Cooke invented the needle telegraph several years before Samuel Morse
    invented his key telegraph. Cooke commercialized the needle telegraph in England
    years before Morse began his telegraph company in the US.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*普莱费尔*密码是由查尔斯·维特斯通（发音为WHIT-stun）于1854年发明的。维特斯通在电气工程师中以发明维特斯通电桥而闻名，该电桥用于测量电阻。维特斯通和威廉·库克在塞缪尔·摩尔斯发明他的键式电报几年前就发明了指针电报。库克在英格兰商业化了指针电报，比摩尔斯在美国成立电报公司早了几年。'
- en: Wheatstone’s cipher is called the Playfair cipher because it was Wheatstone’s
    look-alike friend Baron Lyon Playfair (both had bright red hair and stood about
    5'2'') who advocated for its use and convinced the British Foreign Office to use
    the cipher for diplomatic communications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 维特斯通的密码被称为普莱费尔密码，因为维特斯通的长相类似的朋友利昂·普莱费尔男爵（两人都有红头发，身高约5'2''）主张使用它，并说服英国外交部在外交通信中使用该密码。
- en: Historical aside
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 历史插曲
- en: Since this cipher was not called the Wheatstone cipher, that left the Wheatstone
    name available for a second cipher that Wheatstone invented circa 1860 and exhibited
    at the Paris Exposition Universelle in 1867\. The Wheatstone Cryptograph, which
    resembled a large pocket watch, consisted of two stationary concentric rings made
    of stiff cardboard and two moveable clock hands connected by a simple clockwork
    mechanism. The inner ring was erasable, and could be changed for each message.
    This ring had the 26-letter alphabet in scrambled order, while the outer ring
    had the standard 26-letter alphabet plus a blank, making 27 positions. You move
    the long clock hand to indicate the plaintext letter on the outer ring, and the
    short hand moves to indicate the ciphertext letter on the inner ring. When the
    long clock hand completes one revolution of 27 positions, the short hand also
    moves 27 positions, which is 1 complete revolution plus 1 extra letter position.
    So the short hand starts from a different point on each revolution. An equivalent
    device with moveable rings and no hands had been produced by Col. Decius Wadsworth,
    chief of ordnance, in 1817, based on plans made by Thomas Jefferson in 1790, but
    it is Wheatstone’s name that is forever associated with this concept.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个密码并不被称为维特斯通密码，这使得维特斯通的名字可以用于他大约在1860年发明并在1867年巴黎世界博览会上展示的第二个密码。维特斯通密码机看起来像一个大口袋手表，由两个固定的硬纸板同心圆环和两个可移动的时钟指针组成，通过简单的钟表机制连接。内环可擦拭，每条消息都可以更改。这个环上有乱序的26个字母表，而外环有标准的26个字母表加一个空格，共27个位置。您将长时钟指针移动到外环上的明文字母位置，短指针移动到内环上的密文字母位置。当长时钟指针完成27个位置的一次旋转时，短指针也会移动27个位置，即完成一次完整的旋转再加上1个额外的字母位置。因此，短指针在每次旋转时都从不同的位置开始。相当于具有可移动环而没有指针的设备于1817年由军械长德西厄斯·沃兹沃斯制造，该设备基于托马斯·杰斐逊于1790年制定的计划，但维特斯通的名字永远与这个概念联系在一起。
- en: Photo provided by Ralph Simpson. The inscription reads
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由拉尔夫·辛普森提供。铭文如下
- en: “The Cryptograph. C. Wheatstone Inv^r.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “密码学。C.维特斯通Inv^r。”
- en: '![9-unnumb-3](../Images/9-unnumb-3.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-3](../Images/9-unnumb-3.png)'
- en: The Playfair cipher is based on the Polybius square, and enciphers two letters
    at a time. That is, it enciphers bigrams. The square can be prepared by mixing
    the alphabet using any of the methods of section 5.2\. One low-frequency letter
    of the alphabet such as J, Q or Z is omitted to make the alphabet fit into a 5×5
    square. (In French, J, Q and Z are common, so omit W. In German, omit Q, X or
    Y.) When the omitted letter occurs in the message, some other letter is chosen
    to replace it. In our case each J is replaced by an **I**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 普莱费尔密码基于波利比奥斯方阵，每次加密两个字母。也就是说，它加密的是双字母组。方阵可以通过使用第5.2节中的任何方法混合字母来准备。为了使字母适应5×5方阵，会省略一个低频字母，如J、Q或Z。（在法语中，J、Q和Z很常见，所以省略W。在德语中，省略Q、X或Y。）当省略的字母出现在消息中时，会选择其他字母替换它。在我们的例子中，每个J都被**I**替换。
- en: The next step is to divide the message into bigrams, for example ME ET ME TO
    MO RR OW. If a bigram is a double letter, this should be broken up, typically
    by inserting an X in the middle. (This is a good reason not to omit X from the
    square.) Also, if the message contains an odd number of letters, an X is added
    at the end. The message becomes ME ET ME TO MO RX RO WX. Now we are ready to encipher
    it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将信息分成二元素，例如ME ET ME TO MO RR OW。如果一个二元素是双字母的，则应该将其分开，通常是通过在中间插入一个X来实现。（这是不应该从方块中省略X的一个很好的理由。）另外，如果消息包含奇数个字母，则在末尾添加一个X。消息变为ME
    ET ME TO MO RX RO WX。现在我们准备好加密它了。
- en: 'Playfair has 3 rules: (1) if the two letters are on the same row, each letter
    is replaced by the letter to its right; (2) if the letters are in the same column,
    each letter is replaced by the letter below it; (3) for all other letters, each
    letter is replaced by the letter in the same row, but in the column of the other
    letter of the bigram. It is understood that the square wraps around, so in the
    square in section 9.1, the letter to the right of Y is U, and the letter below
    Q is W.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 普莱菲尔有3条规则：（1）如果两个字母位于同一行，则每个字母都被其右侧的字母替换；（2）如果字母位于同一列，则每个字母都被其下方的字母替换；（3）对于所有其他字母，每个字母都被二元素的另一个字母所在的同一行中的字母替换。理解方块环绕，因此在第9.1节的方块中，Y的右侧字母是U，Q下方的字母是W。
- en: These rules can be restated in terms of the coordinates. Let the bigram we wish
    to encipher be r1c1 r2c2, so that the first letter is on row r1 in column c1 and
    the second letter is on row r2 in column c2\. Now the 3 rules become
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则可以用坐标来重新表述。让我们要加密的二元素是r1c1 r2c2，因此第一个字母在第r1行第c1列，第二个字母在第r2行第c2列。现在这3条规则变为
- en: If r1 = r2 then substitute r1,c1+1 r2,c2+1.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果r1 = r2，那么将替换为r1，c1+1 r2，c2+1。
- en: If c1 = c2 then substitute r1+1,c1 r2+1,c2.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果c1 = c2，那么将替换为r1+1，c1 r2+1，c2。
- en: Otherwise substitute r1,c2 r2,c1.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则替换为r1，c2 r2，c1。
- en: Let’s encipher our sample message ME ET ME TO MO RX RO WX and see how these
    rules work. The first bigram is ME. M and E are in different rows and different
    columns so Rule 3 applies. M is in row 2 column 4 and E is in row 3 column 2\.
    So M gets replaced by the letter in the same row, namely row 2, in the same column
    as the letter E, namely column 2\. The letter in row 2 column 2 is S, so M is
    replaced by **S**. Likewise, E is replaced by the letter in row 3 column 4, namely
    **C**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的样本信息ME ET ME TO MO RX RO WX进行加密，看看这些规则是如何起作用的。第一个二元素是ME。M和E位于不同的行和不同的列，因此适用规则3。M位于第2行第4列，E位于第3行第2列。因此，M被替换为同一行的字母，即第2行，与字母E相同的列，即第2列。第2行第2列的字母是S，所以M被替换为**S**。同样，E被替换为第3行第4列的字母，即**C**。
- en: In the same way ET is replaced by **DO**, and the second ME is replaced by **SC**.
    The letters T and O are in the same row, so Rule 1 applies. They are replaced
    by the letters to their right. T gets replaced by **N** and O gets replaced by
    **Q**. So TO is replaced by **NQ**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，ET被**DO**替换，第二个ME被**SC**替换。字母T和O位于同一行，因此适用规则1。它们被替换为其右侧的字母。T被**N**替换，O被**Q**替换。所以TO被替换为**NQ**。
- en: MO goes by Rule 3\. It is replaced by **SR**. R and X are in the same column
    so Rule 2 applies. RX is replaced by **XM**. RO and WX both use Rule 1 and are
    replaced by **TQ** and **XY**. The entire message thus becomes **SC DO SC NQ SR
    XM TQ XY**, which is **SCDOS CNQSR XMTQX Y** after regrouping.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MO按照规则3进行。它被替换为**SR**。R和X位于同一列，因此适用规则2。RX被替换为**XM**。RO和WX都使用规则1，被替换为**TQ**和**XY**。因此整个消息变为**SC
    DO SC NQ SR XM TQ XY**，在重新分组后变为**SCDOS CNQSR XMTQX Y**。
- en: Here are some diagrams to help you visualize how the bigrams LY, TO and RX are
    enciphered.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些图表可以帮助你形象化地理解大二元素LY、TO和RX是如何被加密的。
- en: '![9-unnumb-4](../Images/9-unnumb-4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-4](../Images/9-unnumb-4.png)'
- en: The Playfair cipher remained in military and diplomatic use until at least 1960\.
    Next, let’s take a brief look at how a Playfair cipher can be solved.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 普莱菲尔密码一直被军事和外交用途使用，至少持续到1960年。接下来，让我们简要地看一下普莱菲尔密码如何被解密。
- en: 9.2.1 Solving a Playfair cipher
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 解密普莱菲尔密码
- en: Notice that each letter can be enciphered by only 5 possible substitutes, namely
    the 4 other letters on its row and the letter immediately below it. For each letter
    there are 24 other letters in the grid. Of these, only the 4 letters in its own
    column will cause the letter to be replaced by the letter below it. So the chance
    of a letter being replaced by the letter below is 4/24, or 1/6\. The chance that
    it is replaced by another letter on its row is therefore 5/6.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个字母只能由其所在行上的其他 4 个字母和其下方的字母替换。对于每个字母，在网格中有其他 24 个字母。其中，只有其所在列中的 4 个字母会导致该字母被其下方的字母替换。因此，被下方字母替换的概率为
    4/24，或 1/6。因此，它被其所在行上的另一个字母替换的概率为 5/6。
- en: Since there are 5 rows in the square and 9 English letters with frequencies
    over 5% there must be several rows that contain at least 2 high-frequency letters.
    If there are fewer than 4 such rows, then there must be at least one row with
    3 high-frequency letters. The other letters on these rows will appear more frequently
    in the ciphertext than any other letters. If you have sufficient ciphertext there
    is a good chance that the 3 to 5 most frequent letters in the ciphertext appear
    on the same row in the square.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方格中有 5 行，而英语字母中频率超过 5% 的有 9 个字母，因此至少有几行包含至少 2 个高频字母。如果这样的行少于 4 行，则必须至少有一行包含
    3 个高频字母。这些行中的其他字母在密文中将比任何其他字母更频繁地出现。如果您有足够的密文，那么密文中出现频率最高的 3 到 5 个字母很可能在方格的同一行上。
- en: If we remove all of the bigrams containing these letters, the 3 to 5 most frequent
    letters in the remaining bigrams are likely to be on the same row of the square.
    Knowing the high-frequency letters on 2 out of the 5 rows is enough to get started
    in the reconstruction of the square. The next step would be to try to place some
    probable words.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们去除包含这些字母的所有双字母组合，那么剩余双字母组合中出现频率最高的 3 到 5 个字母很可能在方格的同一行上。知道了 5 行中的 2 行上的高频字母就足以开始重建方格了。下一步是尝试放置一些可能的单词。
- en: The Playfair cipher is rated Three. There are several ways to increase the strength
    of the Playfair cipher. Let me mention just a few.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair 密码的评级为三。有几种方法可以增强 Playfair 密码的强度。我就提几种。
- en: 9.2.2 Strengthening a Playfair cipher
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 强化 Playfair 密码
- en: Here are several stronger variants of the Playfair cipher.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几种更强的 Playfair 密码变体。
- en: Nullfair or nofair
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Nullfair 或 nofair
- en: 'Nulls can be added to the ciphertext at repeating intervals, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在密文中可以按照重复的间隔添加空值，就像这样：
- en: '![9-unnumb-5](../Images/9-unnumb-5.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-5](../Images/9-unnumb-5.png)'
- en: Nullfair is rated Five.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Nullfair 的评级为五。
- en: Playfair+1
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair+1
- en: This super-simple enhancement adds a repeating binary key to the Playfair ciphertext.
    Wherever there is a 1 bit, the next letter of the alphabet is used. Playfair+1
    is stronger if the binary key has an odd length.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种超级简单的增强方式在 Playfair 密文中添加了重复的二进制密钥。在有 1 位的地方，使用字母表的下一个字母。如果二进制密钥的长度为奇数，则 Playfair+1
    更强大。
- en: '![9-unnumb-6](../Images/9-unnumb-6.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-6](../Images/9-unnumb-6.png)'
- en: Playfair+1 is rated Five. Playfair+1 can also be done with ternary numbers.
    The digits in the additive key are kept small so the addition can be done in your
    head, without needing a tableau.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair+1 的评级为五。 Playfair+1 也可以用三进制数完成。加法密钥中的数字保持较小，因此可以在脑中进行加法，而不需要表格。
- en: Double Playfair
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 双 Playfair
- en: The Playfair cipher can be strengthened by applying it twice. On the second
    round, the pairs should straddle the bigrams created in the first round. (1) Encipher
    the message with a Playfair cipher. (2) Either move the first letter to the end,
    move the last letter to the beginning, or add a null at both ends. (3) Apply another
    round of Playfair. This is strongest if a different mixed alphabet is used for
    the second Playfair cipher. Double Playfair is rated Six.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair 密码可以通过两次应用来加强。在第二轮中，成对字母应跨越第一轮创建的双字母组合。 (1) 使用 Playfair 密码对消息进行加密。
    (2) 将第一个字母移到末尾，将最后一个字母移到开头，或在两端都添加一个空值。 (3) 应用另一轮 Playfair。如果第二个 Playfair 密码使用了不同的混合字母表，则这是最强的。双
    Playfair 的评级为六。
- en: Playfair ripple
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair 涟漪
- en: This is a variant of double Playfair that takes only one pass through the message,
    and needs only one Polybius square. Let the plaintext be P[1]P[2]P[3]P[4] ...
    Start at the left end and encipher plaintext bigram P[1]P[2] using Playfair, producing
    ciphertext bigram C[1]C[2]. Then encipher C[2]P[3] as the second bigram, getting
    D[2]C[3]. Notice that D[2] has been enciphered twice. Next you encipher C[3]P[4],
    to get D[3]C[4], and so forth, moving one character to the right at each step.
    Playfair ripple is rated Six.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是双 Playfair 的一种变体，只需通过消息进行一次传递，而且只需要一个 Polybius 方块。让明文为 P[1]P[2]P[3]P[4] ...
    从左端开始，使用 Playfair 对明文二元组 P[1]P[2] 进行加密，产生密文二元组 C[1]C[2]。然后将 C[2]P[3] 作为第二个二元组进行加密，得到
    D[2]C[3]。注意，D[2] 已经加密了两次。接下来，你将 C[3]P[4] 进行加密，得到 D[3]C[4]，依此类推，每一步向右移动一个字符。Playfair
    波动被评为 Six。
- en: Since the first letter C[1] and the last letter C[n] of the ciphertext have
    been enciphered only once, you may wish to encipher them as a bigram to complete
    the cycle.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密文的第一个字母 C[1] 和最后一个字母 C[n] 仅加密了一次，因此你可能希望将它们作为一个二元组加密以完成循环。
- en: '![9-unnumb-7](../Images/9-unnumb-7.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-7](../Images/9-unnumb-7.png)'
- en: PolyPlayfair
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: PolyPlayfair
- en: 'Use two different Polybius squares and alternate between them by using a repeating
    key. For example, a key of 11212 means that on each cycle of 5 bigrams the first,
    second and fourth bigrams would be enciphered with Square 1, while the third and
    fifth bigrams would be enciphered with Square 2\. This can be extended to three
    or more squares, with a correspondingly longer setup time. Using two squares and
    a key of not more than 10 digits PolyPlayfair is rated Five. If the key is generated
    by the Chained Digit algorithm, using the first square when the digit is 0 to
    4, and the second square when the digit is 5 to 9, the rating increases to Six.
    (Note: using the parity of the chained digit sequence has a much shorter period,
    so it is far weaker.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个不同的 Polybius 方块，并通过使用重复密钥在它们之间交替。例如，密钥为 11212 意味着在每个 5 个二元组的周期中，第一个、第二个和第四个二元组将使用方块
    1 进行加密，而第三个和第五个二元组将使用方块 2 进行加密。这可以扩展到三个或更多方块，相应的设置时间会更长。使用两个方块和不超过 10 位数字的密钥，PolyPlayfair
    的评级为 Five。如果密钥是由 Chained Digit 算法生成的，当数字为 0 到 4 时使用第一个方块，当数字为 5 到 9 时使用第二个方块，评级会增加到
    Six。（注意：使用链式数字序列的奇偶性具有更短的周期，因此它更弱。）
- en: Transposition
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 转位
- en: After the plaintext has been enciphered with the Playfair cipher the resulting
    ciphertext can be transposed. The transposition can be as elaborate as the columnar
    transposition of section 7.2, or as simple as the piecewise reversal of the Bazeries
    Type 4 cipher in section 4.6.1\. With columnar transposition the Playfair is rated
    Seven. With piecewise reversal the Playfair is rated Five.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Playfair 密码对明文进行加密后，可以对结果的密文进行转置。转置可以像第 7.2 节的栏转置那样复杂，也可以像第 4.6.1 节的 Bazeries
    类型 4 密码那样简单。使用栏转置，Playfair 评为 Seven。使用分段反转，Playfair 评为 Five。
- en: 9.3 Two Square
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 双方块
- en: The *Two Square* cipher, sometimes called *Double Playfair*, is an improved
    version of the Playfair cipher. It was invented by French amateur cryptographer
    Félix-Marie Delastelle and described in his 1902 book *Traité Élémentaire de Cryptographie*.
    As the name implies, it uses two Polybius squares instead of one, so that there
    are two mixed alphabets instead of one. The two squares may be placed side-by-side
    horizontally, or bottom-to-top vertically. The horizontal version is illustrated.
    In this example the two squares were mixed using the keywords FIRST and SECOND,
    and the letter Q was omitted to fit the 5×5 grids.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*Two Square* 密码，有时称为 *双 Playfair*，是 Playfair 密码的改进版本。它是由法国业余密码学家费利克斯·玛丽·德拉斯泰尔（Félix-Marie
    Delastelle）发明的，并在他的 1902 年著作 *Traité Élémentaire de Cryptographie* 中描述。顾名思义，它使用两个
    Polybius 方块而不是一个，因此有两个混合字母表而不是一个。这两个方块可以水平并排放置，也可以垂直从底部到顶部放置。水平版本如图所示。在此示例中，使用关键词
    FIRST 和 SECOND 混合了两个方块，并且省略了字母 Q 以适应 5×5 网格。'
- en: '![9-unnumb-8](../Images/9-unnumb-8.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-8](../Images/9-unnumb-8.png)'
- en: Like the Playfair, the message is enciphered 2 letters at a time. That is, Two
    Square enciphers bigrams. To encipher the bigram SO we find the S in the left
    square and the O in the right square. The substitute for S is the letter in the
    right square in the same row as S and the same column as O, namely **T**. The
    substitute for O is the letter in the left square in the same row as O and the
    same column as S, namely **K**. Thus the bigram SO becomes **TK**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Playfair 一样，消息每次加密 2 个字母。也就是说，Two Square 加密双字母组。要加密双字母组 SO，我们在左方块中找到 S，在右方块中找到
    O。S 的替代字母是右方块中与 S 同一行且与 O 同一列的字母，即**T**。O 的替代字母是左方块中与 O 同一行且与 S 同一列的字母，即**K**。因此，双字母组
    SO 变成了**TK**。
- en: Unlike the Playfair, there is no need to break up double letters. The two letters
    could be on different rows in the two squares. For example, SS becomes **MK**.
    In most cases, a double letter in the ciphertext will not correspond to a double
    letter in the plaintext.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Playfair 不同，不需要分开双字母。两个字母可以在两个方块的不同行上。例如，SS 变成**MK**。在大多数情况下，密文中的双��母不会对应于明文中的双字母。
- en: Here is the substitution process visually.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是替换过程的可视化展示。
- en: '![9-unnumb-9](../Images/9-unnumb-9.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-9](../Images/9-unnumb-9.png)'
- en: An important weakness of the Two Square cipher is that when the two letters
    of a bigram fall on the same row in the grid the substitute is simply those letters
    in reverse. For instance, ST would become **TS**. This weakness, called a *transparency*,
    sometimes allows an entire word to leak through. For example, SU ND AY would become
    **US DN YA**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Two Square 密码的一个重要弱点是，当一个双字母组的两个字母在网格中的同一行时，替代字母就是这两个字母的反向。例如，ST 会变成**TS**。这种弱点被称为*透明性*，有时会导致整个单词泄露出来。例如，SU
    ND AY 会变成**US DN YA**。
- en: 'To prevent this, I propose this *Same Row Rule*: when the two letters are on
    the same row, they are replaced by the letters immediately below them, wrapping
    to the top row when necessary. For example, ST would now become **DY**, and VI
    would become **FP**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，我提出了这个*相同行规则*：当两个字母在同一行上时，它们被它们下面的字母替换，必要时回到顶行。例如，ST 现在会变成**DY**，VI
    会变成**FP**。
- en: With the Same Row Rule, Two Square is rated Four. Call this variation *Two Square
    B*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同行规则，Two Square 评级为四。将这种变体称为*Two Square B*。
- en: The Germans took the name Double Playfair literally. They enciphered each bigram
    using the Two Square cipher, and then enciphered that bigram again, using Two
    Square with the same two squares. The result is essentially a general bigram substitution
    (section 6.5).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 德国人字面上采用了“双 Playfair”这个名称。他们使用了 Two Square 密码对每个双字母组进行加密，然后再次使用相同的两个方块进行加密。结果基本上是一个通用的双字母替换（第
    6.5 节）。
- en: The same methods that were used to strengthen the Playfair cipher may also be
    used to strengthen the Two Square cipher, such as *TwoSquare+1* and *Two Square
    Ripple*, with the same ratings. Here is an additional variant.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 加强 Playfair 密码所使用的方法也可以用于加强 Two Square 密码，比如*TwoSquare+1*和*Two Square Ripple*，评级相同。这里是一个额外的变体。
- en: Playfair TwoSquare
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair TwoSquare
- en: The Two Square cipher uses two Polybius squares. Either of these squares could
    be used for a Playfair cipher. This suggests a hybrid method that mixes Playfair
    and Two Square. Again, we will use a numerical key to control how each successive
    bigram is enciphered. A 1 means encipher the bigram using Playfair in the left
    square, a 2 means encipher the bigram using Playfair in the right square, and
    a 3 means encipher the bigram using Two Square or Two Square B. It is best if
    the numeric key contains at least one of each digit. Since Two Square is stronger
    than Playfair, 3 should occur more often than 1 or 2 in the key. About 50% would
    be suitable. *Playfair TwoSquare* is rated Six.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Two Square 密码使用了两个 Polybius 方块。这两个方块中的任何一个都可以用于 Playfair 密码。这提示了一种混合方法，将 Playfair
    和 Two Square 结合起来。同样，我们将使用一个数字密钥来控制每个连续双字母组的加密。1 表示使用左方块中的 Playfair 加密双字母组，2 表示使用右方块中的
    Playfair 加密双字母组，3 表示使用 Two Square 或 Two Square B 加密双字母组。最好是数字密钥至少包含每个数字。由于 Two
    Square 比 Playfair 更强大，3 应该比 1 或 2 在密钥中更频繁出现。大约 50% 是合适的。*Playfair TwoSquare* 评级为六。
- en: 9.4 Three Square
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 三方块
- en: '*Three Square* is my own idea. Otherwise, it has no special merit. I include
    it here simply because one of the books I read while researching for this book
    said that Two Square could not be extended to more than two squares. I love a
    challenge.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*Three Square* 是我的独创想法。否则，它没有特别的优点。我在这里包括它只是因为我在为这本书做研究时阅读的一本书说 Two Square
    不能扩展到超过两个方块。我喜欢挑战。'
- en: As the name suggests, Three Square uses three Polybius squares. These squares
    should be well-mixed with independent keys. Three Square enciphers 3 letters at
    a time, that is, it enciphers trigrams. This makes it stronger than Two Square.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，Three Square 使用三个 Polybius 方格。这些方格应该与独立的密钥混合得很好。Three Square 每次加密 3 个字母，也就是加密三字母组合。这比
    Two Square 更强大。
- en: '![9-unnumb-10](../Images/9-unnumb-10.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-10](../Images/9-unnumb-10.png)'
- en: The basic idea is that each letter is replaced by a letter in the square to
    its right. The replacement letter is in the same row, but in the column containing
    the next letter of the trigram.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，每个字母都被其右侧方格中的一个字母替换。替换字母与原字母在同一行，但在下一个三字母组合中的列中。
- en: Suppose we wish to encipher the trigram THE. The first letter is T, the second
    letter is H, and the third letter is E. We encipher using the T in the first square,
    the H in the second square and the E in the third square, like this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望加密三字母组合THE。第一个字母是T，第二个字母是H，第三个字母是E。我们使用第一个方格中的T，第二个方格中的H和第三个方格中的E进行加密，就像这样。
- en: '![9-unnumb-11](../Images/9-unnumb-11.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-11](../Images/9-unnumb-11.png)'
- en: The substitute for T is on the row containing the T, and in the column in the
    second square containing the H, so T is replaced by **V**. The substitute for
    H is on the same row as the H in the same column as the E in the third square,
    so H is replaced by **R**. The substitute for E is on the same row as the E in
    the column in the first square containing the T, so E is replaced by **Z**. Thus,
    THE becomes **VRZ**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: T 的替代字母位于包含 T 的行，以及第二个方格中包含 H 的列，所以 T 被替换为**V**。H 的替代字母与第三个方格中包含 E 的列上的 H 在同一行，所以
    H 被替换为**R**。E 的替代字母与第一个方格中包含 T 的列上的 E 在同一行，所以 E 被替换为**Z**。因此，THE 变成了**VRZ**。
- en: 'This can be seen pictorially as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以如下图所示：
- en: '![9-unnumb-12](../Images/9-unnumb-12.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-12](../Images/9-unnumb-12.png)'
- en: 'The decipherment goes in the opposite direction. Since the first letter of
    the ciphertext trigram **VRZ** came from the second square, we begin deciphering
    in the second square, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解密是相反的过程。由于密文三字母组合**VRZ**的第一个字母来自第二个方格，我们从第二个方格开始解密，像这样：
- en: '![9-unnumb-13](../Images/9-unnumb-13.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-13](../Images/9-unnumb-13.png)'
- en: Three Square has a worse problem than Two Square with letters falling on the
    same row. In a trigram such as XYZ, it is possible that X and Y could fall on
    the same row, Y and Z could fall on the same row, or Z and X could fall on the
    same row. This requires two extra rules to prevent a transparency where a letter
    represents itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Three Square 比 Two Square 更容易出现字母位于同一行的问题。在 XYZ 这样的三字母组合中，可能出现 X 和 Y 在同一行，Y
    和 Z 在同一行，或者 Z 和 X 在同一行。这需要额外的两条规则来防止透明度，其中一个字母表示它自己。
- en: '*Rule 1:* If two consecutive letters in the trigram fall on the same row, the
    first of these two letters is enciphered as the letter to the right of the second
    of the letters, wrapping to the left column, if needed. For example, in the trigram
    SUB the S is on the top row of the first square, and the U is on the top row of
    the second square. Therefore S is replaced by **V** instead of by **U**. Similarly,
    in the trigram LET, the T is on the third row of the third square, and the L is
    on the third row of the first square. So T is replaced by **G** instead of **L**.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*规则 1：* 如果三字母组合中连续的两个字母位于同一行，则这两个字母中的第一个被加密为第二个字母的右侧字母，如果需要则绕到左侧列。例如，在三字母组合
    SUB 中，S 在第一个方格的顶行，而 U 在第二个方格的顶行。因此 S 被替换为**V**而不是**U**。类似地，在三字母组合 LET 中，T 在第三个方格的第三行，而
    L 在第一个方格的第三行。所以 T 被替换为**G**而不是**L**。'
- en: This diagram illustrates Rule 1\. Without Rule 1, in the trigram SUB the S would
    be replaced by **U**. Instead, it is replaced by the letter to the right of U
    in the middle square, namely **V**. Without Rule 1, in the trigram LET the T would
    be replaced by **L**. Instead, it is replaced by the letter to the right of L
    in the left square. This wraps from column 5 to column 1, which has the letter
    **G**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图示说明了规则 1。没有规则 1，在三字母组合 SUB 中，S 将被**U**替换。相反，它被中间方格中 U 右侧的字母替换，即**V**。没有规则
    1，在三字母组合 LET 中，T 将被**L**替换。相反，它被左方格中 L 右侧的字母替换。这从第 5 列绕到第 1 列，其中有字母**G**。
- en: '![9-unnumb-14](../Images/9-unnumb-14.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-14](../Images/9-unnumb-14.png)'
- en: '*Rule 2:* If all three letters in the trigram fall on the same row, each letter
    will be replaced by the letter immediately below it, wrapping to the top row,
    if needed. Thus FUN would be replaced by **AZV**, and WRE would be replaced by
    **IXL**.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*规则 2：* 如果三元组中的所有三个字母都在同一行上，那么每个字母将被其下方的字母替换，如果需要，将回到顶行。因此，FUN 将被替换为**AZV**，而
    WRE 将被替换为**IXL**。'
- en: With these rules Three Square is rated Five.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，三方格被评为五。
- en: Playfair ThreeSquare
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair ThreeSquare
- en: The Three Square cipher uses three Polybius squares. Any of these squares could
    be used for a Playfair cipher. This suggests a hybrid method that mixes the Playfair
    and Three Square ciphers. You can use a numerical key such as 1,4,1,3,4,2,4 to
    control how each successive bigram or trigram is enciphered. A 1 means encipher
    the next 2 letters as a bigram using Playfair in the first square. A 2 means encipher
    the next 2 letters as a bigram using Playfair in the second square. A 3 means
    encipher the next 2 letters as a bigram using Playfair in the third square. A
    4 means encipher the next 3 letters as a trigram using Three Square. It is best
    if the numeric key contains at least one of each digit. Since Three Square is
    much stronger than Playfair, the digit 4 should occur more often than 1, 2 or
    3 in the numeric key. About 50% would be suitable. That is, 4 should occur as
    often as 1, 2 and 3 combined. Equivalently, generate random numbers from 1 to
    6, and use Three Square with 4, 5 or 6.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 三方格密码使用三个波利比斯方格。这些方格中的任何一个都可以用于 Playfair 密码。这表明了一种混合方法，将 Playfair 和三方格密码混合在一起。您可以使用数字密钥，例如
    1,4,1,3,4,2,4 来控制每个连续的二元组或三元组的加密方式。1 表示使用第一个方格中的 Playfair 将下一个 2 个字母加密为二元组。2 表示使用第二个方格中的
    Playfair 将下一个 2 个字母加密为二元组。3 表示使用第三个方格中的 Playfair 将下一个 2 个字母加密为二元组。4 表示使用三方格将下一个
    3 个字母加密为三元组。最好是数字密钥至少包含每个数字。由于三方格比 Playfair 更强大，数字 4 应该比数字 1、2 或 3 更频繁地出现在数字密钥中。大约
    50% 的频率是合适的。也就是说，4 应该与 1、2 和 3 的总和一样频繁出现。同样，生成从 1 到 6 的随机数，并使用 4、5 或 6 进行三方格加密。
- en: Since Playfair ThreeSquare mixes bigrams and trigrams, about half of the bigrams
    and two-thirds of the trigrams will not fall on even boundaries. This means the
    increase in strength is greater than the increase for Playfair TwoSquare. Playfair
    ThreeSquare is rated Seven.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Playfair ThreeSquare 混合了二元组和三元组，大约一半的二元组和三分之二的三元组不会落在偶数边界上。这意味着强度的增加比 Playfair
    TwoSquare 的增加更大。Playfair ThreeSquare 被评为七。
- en: It is possible to combine Playfair, Two Square and Three Square into an even
    more complex cipher, no doubt with greater strength, but Playfair ThreeSquare
    is already pushing the limits of what a human code clerk can do. Both speed and
    accuracy would suffer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 Playfair、Two Square 和 Three Square 结合成一个更复杂的密码，毫无疑问具有更强的强度，但是 Playfair ThreeSquare
    已经在推动人类代码员的极限。速度和准确性都会受到影响。
- en: There is an opposite approach, which I call a *Straddling Three Square*. Group
    the plaintext into rows containing four blocks of 3 characters each. Encipher
    each of the blocks using the Three Square cipher. Now take the last letter of
    block 1 and the first letter of block 2 and encipher that bigram using the Playfair
    cipher with the first Polybius square. Take the last letter of block 2 and the
    first letter of block 3 and encipher that bigram using the Playfair cipher with
    the second Polybius square. Take the last letter of block 3 and the first letter
    of block 4 and encipher that bigram with the third Polybius square. This improves
    the strength of the Three Square cipher without adding much complexity, or much
    time. Use the Same Row Rule throughout.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种相反的方法，我称之为*跨三方格*。将明文分组成包含每行四个 3 个字符块的行。使用三方格密码对每个块进行加密。现在，取第一个块的最后一个字母和第二个块的第一个字母，并使用第一个波利比斯方格的
    Playfair 密码对该二元组进行加密。取第二个块的最后一个字母和第三个块的第一个字母，并使用第二个波利比斯方格的 Playfair 密码对该二元组进行加密。取第三个块的最后一个字母和第四个块的第一个字母，并使用第三个波利比斯方格的
    Playfair 密码对该二元组进行加密。这样可以提高三方格密码的强度，而不会增加太多复杂性或时间。始终使用相同行规则。
- en: 9.5 Four Square
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 四方格
- en: The *Four Square* cipher was invented by Félix-Marie Delastelle circa 1890,
    and described in his book *Traité Élémentaire de Cryptographie*, published 3 months
    after his death in 1902\. Delastelle invented the Two Square cipher after the
    Four Square cipher as a simplified and slightly less secure version. However,
    with the Same Row Rule described in section 9.3 the two ciphers can be considered
    equal in strength.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*四方密码*是由 Félix-Marie Delastelle 大约于 1890 年发明的，并在他于 1902 年去世后的 3 个月出版的书籍*Traité
    Élémentaire de Cryptographie*中描述。Delastelle 在四方密码之后发明了双方密码，作为简化且稍微不那么安全的版本。然而，使用第
    9.3 节中描述的同行规则，可以认为这两种密码的强度相等。'
- en: As the name implies, the Four Square cipher utilizes four Polybius squares.
    Two of the squares contain the standard alphabet, and the other two squares contain
    alphabets mixed using independent keys. The message is enciphered two letters
    at a time, that is, Four Square enciphers bigrams.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，四方密码利用四个 Polybius 方块。其中两个方块包含标准字母表，另外两个方块包含使用独立密钥混合的字母表。消息以两个字母为一组进行加密，即四方加密二元组。
- en: Here is a sample arrangement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例排列。
- en: '![9-unnumb-15](../Images/9-unnumb-15.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-15](../Images/9-unnumb-15.png)'
- en: 'Enciphering uses the familiar rectangular scheme. You locate the two plaintext
    letters in the standard alphabets and replace them with the letters at the opposite
    corners of the rectangle, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 加密使用熟悉的矩形方案。您在标准字母表中定位两个明文字母，并将它们替换为矩形对角线上的字母，如下所示：
- en: '![9-unnumb-16](../Images/9-unnumb-16.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-16](../Images/9-unnumb-16.png)'
- en: Since the two plaintext letters can never be in the same row or the same column
    of the 10×10 grid there is no need for special rules, or for separating double
    letters. The only need for a null character is for completing the last bigram.
    Four Square is rated Five.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个明文字母永远不可能在 10×10 网格的同一行或同一列中，因此无需特殊规则或分隔双字母。唯一需要空字符的情况是为了完成最后一个双字母组合。四方加密的评级为五。
- en: Cycling method
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 循环方法
- en: 'To get a little more strength you can use a simple transposition similar to
    the piecewise reversal in section 4.6.1\. This transposition uses a repeating
    numeric key such as 1,3,1,4,2,6\. Divide the ciphertext into blocks of 7 characters,
    or any other odd length. Write the successive key digits above each block. Then
    cycle each block left the number of positions indicated by its key digit. For
    example, if the key digit is 4 you would move the leftmost 4 digits to the right
    end of the block. Here is an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得更大的强度，您可以使用类似于第 4.6.1 节中的分段反转的简单换位。此换位使用重复的数字密钥，例如 1、3、1、4、2、6。将密文分成 7 个字符或任何其他奇数长度的块。在每个块的上方写下连续的密钥数字。然后将每个块左移其密钥数字指示的位置数。例如，如果密钥数字是
    4，则将最左边的 4 位数字移动到块的右端。这是一个例子：
- en: '![9-unnumb-17](../Images/9-unnumb-17.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-17](../Images/9-unnumb-17.png)'
- en: Four Square using the cycling method is rated Six.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环方法的四方加密的评级为六。
- en: Halving method
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分半方法
- en: Another approach to strengthening Four Square is to transpose the message beforehand.
    Suppose the message is AMBASSADOR WILKINS ASSASSINATED KABUL TODAY. This has 39
    letters. Dividing 39 by 2 and rounding up gives 20\. Write the message in two
    rows of 20 letters each, and read off the bigrams reading vertically. Encipher
    these bigrams using Four Square.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 加强四方加密的另一种方法是事先转置消息。假设消息是AMBASSADOR WILKINS ASSASSINATED KABUL TODAY。这有 39 个字母。将
    39 除以 2 并四舍五入得到 20。将消息写成两行，每行 20 个字母，并从垂直方向读取双字母组合。使用四方进行这些双字母组合的加密。
- en: '![9-unnumb-18](../Images/9-unnumb-18.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-18](../Images/9-unnumb-18.png)'
- en: These bigrams no longer have the normal bigram frequencies, or the normal contact
    frequencies, for English bigrams. Four Square using the halving method is rated
    Seven.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些双字母组合不再具有正常的双字母组合频率或英语双字母组合的正常联系频率。使用分半方法的四方加密的评级为七。
- en: 9.6 Bifid
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 双分
- en: Let’s look at one more historical hand cipher based on the 5×5 Polybius square.
    This is the *Bifid* cipher, also invented by Félix-Marie Delastelle in the 1890s.
    Bifid is a 3-step cipher where (1) the letters are converted into their Polybius
    coordinates, (2) those coordinates are rearranged, and (3) the coordinates are
    then converted back into letters. Originally, Delastelle wrote out the entire
    message with the coordinates written vertically under each letter, then he combined
    the pairs of coordinates reading horizontally, first across the top row and then
    across the bottom row.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个基于5×5波利比乌斯方阵的历史手工密码。这是*双重*密码，也是在19世纪90年代由菲利克斯·玛丽·德拉斯特尔发明的。双重是一个3步密码，其中(1)字母被转换为它们的波利比乌斯坐标，(2)这些坐标被重新排列，(3)然后坐标被转换回字母。最初，德拉斯特尔将整个消息写出，坐标垂直写在每个字母下面，然后他将坐标对水平地读出，先横穿顶行，然后横穿底行。
- en: The modern method is to break the message into blocks of a fixed size. The block
    size should be an odd number, such as 5, 7 or 9\. If the block size is an even
    number, then Emily can separate the blocks into bigrams.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现代方法是将消息分成固定大小的块。块大小应该是奇数，如5、7或9。如果块大小是偶数，则艾米莉可以将块分成二元组。
- en: 'The first step is to convert the letters into their coordinates in the Polybius
    square. Suppose the block length is 5\. The 5 plaintext letters can be represented
    as X1, X2, X3, X4 and X5\. Their row and column coordinates can be represented
    as R1C1, R2C2, R3C3, R4C4 and R5C5\. Each of these R and C symbols is a number
    from 1 to 5, with the row coordinate first and the column coordinate second. These
    pairs of coordinates are written vertically below each letter in the block, like
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将字母转换为波利比乌斯方阵中的坐标。假设块长度为5。5个明文字母可以表示为X1、X2、X3、X4和X5。它们的行和列坐标可以表示为R1C1、R2C2、R3C3、R4C4和R5C5。这些R和C符号各自是从1到5的数字，先是行坐标，然后是列坐标。这些坐标对是垂直地写在每个块的每个字母下面，像这样：
- en: '![9-unnumb-19](../Images/9-unnumb-19.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-19](../Images/9-unnumb-19.png)'
- en: Then they are read out going across the rows in the order R1R2, R3R4, R5C1,
    C2C3, C4C5\. Here is an example. The word MAJOR is enciphered using a Polybius
    square that was mixed using the keyword SAMPLE.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照R1R2、R3R4、R5C1、C2C3、C4C5的顺序读取。这里是一个例子。使用关键词SAMPLE混合的波利比乌斯方阵对单词MAJOR进行了加密。
- en: '![9-unnumb-20](../Images/9-unnumb-20.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-20](../Images/9-unnumb-20.png)'
- en: Notice that the third set of letter coordinates in the ciphertext, **R5C1**,
    is a row/column pair. This means that the third ciphertext letter will come from
    the same row, **R5**, in the Polybius square as the fifth plaintext letter, and
    from the same column, **C1**, as the first plaintext letter. This concurrence
    of both row coordinate and column coordinate is called a *natural*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，密文中的第三组字母坐标，**R5C1**，是一个行/列对。这意味着第三个密文字母将来自与第五个明文字母相同的行，**R5**，以及与第一个明文字母相同的列，**C1**。这个同时出现行坐标和列坐标的情况被称为*自然*。
- en: Since there are 5 letters in each row and 5 letters in each column in the square,
    there is a 1 in 5 chance that the third ciphertext letter is the same as the fifth
    plaintext letter, and a 1 in 5 chance that the third ciphertext letter is the
    same as the first plaintext letter. That is, there is a 20% chance that **R5C1**
    is the same as **R5C5**, and a 20% chance that **R5C1** is the same as **R1C1**.
    In this example, that is exactly what happened. The fifth plaintext letter is
    R and the third ciphertext letter is also **R**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方阵中每行有5个字母，每列有5个字母，所以第三个密文字母与第五个明文字母相同的概率为1/5，第三个密文字母与第一个明文字母相同的概率也是1/5。也就是说，**R5C1**与**R5C5**相同的概率是20%，而**R5C1**与**R1C1**相同的概率也是20%。在这个例子中，确实发生了这种情况。第五个明文字母是R，第三个密文字母也是**R**。
- en: Now look at the first ciphertext letter, **R1R2**. This is a row/row pair, not
    a row/column pair. Here only the first coordinate, **R1**, is in the correct place
    for a row/ column pair. The other coordinate, **R2**, is a row coordinate in the
    column position. Such a single placement is called a *half-natural*. It means
    that the first ciphertext letter comes from the same row in the Polybius square
    as the first plaintext letter. So there is a 20% chance that the first ciphertext
    letter is the same as the first plaintext letter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看第一个密文字母**R1R2**。这是一个行/行对，而不是一个行/列对。在这里，只有第一个坐标**R1**处于正确的位置，形成了一个行/列对。另一个坐标**R2**是列位置上的行坐标。这样的单一放置被称为*半自然*。它意味着第一个密文字母来自波利比奥斯方阵的与第一个明文字母相同的行。因此，第一个密文字母与第一个明文字母相同的机会为20%。
- en: This also happens with the second, fourth and fifth ciphertext letters. Each
    one of them falls in either the same row or the same column as one of the plaintext
    letters. Thus each of them has a 20% chance of being the same as that plaintext
    letter. This happened in the example, where the second ciphertext letter, **J**,
    is the same as the third plaintext letter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二、第四和第五个密文字母也是如此。它们中的每一个都落在明文字母的同一行或同一列中的一个。因此，它们每一个有20%的机会与该明文字母相同。在这个例子中发生了这种情况，第二个密文字母**J**与第三个明文字母相同。
- en: This is a serious weakness in the bifid cipher which makes it easy for Emily
    to guess at and place probable words. On the other hand, if the plaintext and
    ciphertext letters are different, then you know that they are in the same row
    or column. In the example, the first plaintext letter **R1C1** is M, and the first
    ciphertext letter **R1R2** is **S**. This means that M and S must be in the same
    row of the Polybius square. When Emily deduces or guesses a word, that provides
    several of these equivalences. This, in turn, makes it easier to place additional
    words. When enough of these letter pairs have been accumulated, Emily can reconstruct
    the square.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是bifid密码的一个严重弱点，使得Emily能够猜测并放置可能的单词。另一方面，如果明文和密文字母不同，则知道它们位于同一行或列中。在本例中，第一个明文字母**R1C1**是M，第一个密文字母**R1R2**是**S**。这意味着M和S必须在波利比奥斯方阵的同一行中。当Emily推断或猜测一个单词时，这提供了几个这样的等价物。这反过来又使得放置其他单词变得更容易。当积累了足够多的这些字母对时，Emily可以重构方阵。
- en: Due to these weaknesses, the bifid cipher is rated Three.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些弱点，bifid密码评分为三。
- en: 9.6.1 Conjugated matrix bifid
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 共轭矩阵bifid
- en: These problems can be eliminated by using a different Polybius square to convert
    the coordinates back to letters. For example, Square 2 yields the ciphertext **VBJEF**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以通过使用不同的Polybius方阵将坐标转换回字母来消除。例如，方阵2产生的密文是**VBJEF**。
- en: '![9-unnumb-21](../Images/9-unnumb-21.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-21](../Images/9-unnumb-21.png)'
- en: Bifid with two separate Polybius squares is called by the highfalutin name *Conjugated
    Matrix Bifid*. In this context, a matrix simply means a rectangular array of letters
    or characters. The conjugated matrix bifid cipher is rated Five.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单独的波利比奥斯方阵组成的双重Polybius方阵被称为*共轭矩阵Bifid*。在这个上下文中，矩阵只是指一个字母或字符的矩形数组。共轭矩阵bifid密码评分为五。
- en: There are several ways to boost the strength of the bifid cipher. One way is
    to vary the block length using a repeating numeric key such as 5, 11, 7\. The
    block lengths would be a cyclic repetition of this key, namely 5, 11, 7, 5, 11,
    7, 5, ... If you prefer, you can generate the block lengths by using the chained
    digit generator and translating the digits to odd block lengths. One possibility
    is
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以增强bifid密码的强度。一种方法是使用重复的数字密钥来改变块长度，例如5、11、7。块长度将是该密钥的循环重复，即5、11、7、5、11、7、5、...
    如果您愿意，您可以通过使用链式数字生成器生成块长度，并将数字翻译为奇数块长度。一种可能性是
- en: '![9-unnumb-22](../Images/9-unnumb-22.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-22](../Images/9-unnumb-22.png)'
- en: So, if the generator produced digits 3, 6, 2, 7, ... , then the block lengths
    would be 11, 7, 9, 9, ...
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果生成器生成数字3、6、2、7，...，那么块长度将为11、7、9、9、...
- en: Using a short repeating key and conjugated matrices the cipher is rated Six.
    With a long repeating key or generating the block lengths using a random number
    generator the cipher is rated Seven.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短重复密钥和共轭矩阵的密码评分为六。使用长重复密钥或使用随机数生成器生成块长度的密码评分为七。
- en: 'A similar idea is to read out the coordinates starting from a different point
    in each block. You could use a numeric key to specify the sequence of starting
    points. If the block length is L, each number in the key may be anywhere from
    1 to 2L. A number from 1 to L would indicate a starting position on the top row
    of coordinates, while a number from L+1 to 2L would indicate a starting position
    on the bottom row, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的想法是从每个块的不同起点开始读出坐标。你可以使用一个数字密钥来指定起点的顺序。如果块的长度为L，密钥中的每个数字可以是从1到2L的任何位置。从1到L的数字表示坐标顶行的起始位置，而从L+1到2L的数字表示底行的起始位置，就像这样：
- en: '![9-unnumb-23](../Images/9-unnumb-23.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-23](../Images/9-unnumb-23.png)'
- en: The coordinates would be taken out in pairs reading from left to right. Here
    is the order for reading out the coordinates using the numeric key 4, 9\. The
    starting positions 4 and 9 are shaded.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标将成对地从左到右读取。这是使用数字密钥4、9读取坐标的顺序。起始位置4和9已经阴影化。
- en: '![9-unnumb-24](../Images/9-unnumb-24.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-24](../Images/9-unnumb-24.png)'
- en: This method increases the rating to Six.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将评级提高到六。
- en: Another way to strengthen the bifid cipher is to use a stronger transposition
    to mix the coordinates. The standard bifid using a block of length L takes the
    2L coordinates and writes them into a 2×L block. The coordinates are written into
    the block vertically and read out horizontally. We recognize this as a very simple
    route transposition, described in section 7.1\. There are several stronger transpositions
    covered in chapter 7, notably columnar transposition. One example of this type
    of cipher is the *ADFGVX* cipher invented by intelligence officer Lt. Fritz Nebel
    and used by the Germans in World War I. In the ADFGVX cipher, the coordinates,
    represented by the letters A,D,F,G,V,X, are mixed using a columnar transposition,
    and then transmitted as a string of those letters. This cipher is rated Five.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 加强双重栅栏密码的另一种方法是使用更强的置换来混合坐标。使用长度为L的标准双重栅栏将2L个坐标写入2×L块中。坐标被垂直写入块中，水平读出。我们将其识别为一个非常简单的路径置换，描述在第7.1节。在第7章中涵盖了几种更强的置换，尤其是列置换。这种密码的一个例子是由情报官尼布尔中尉发明并由德国人在第一次世界大战中使用的*ADFGVX*密码。在ADFGVX密码中，由字母A、D、F、G、V、X表示的坐标通过列置换混合，然后作为这些字母的字符串传输。这种密码的评级为五。
- en: If you used longer blocks, say 20 characters, that would give you 40 coordinates.
    (With this method the block lengths may be either even or odd.) This is enough
    to use columnar transposition effectively to mix the coordinates. Or, you could
    go back to Delastelle’s original concept and take the coordinates for the entire
    message as a single block. Either way, using conjugated matrices this cipher is
    rated Eight. Using a double columnar transposition the cipher is rated Ten. Assuming
    four long independent keys and well-mixed alphabets, this is an unbreakable paper
    and pencil cipher. Call it *Double Columnar Bifid*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用更长的块，比如20个字符，那么将会得到40个坐标。（使用这种方法，块的长度可以是偶数也可以是奇数。）这足以有效地使用列置换来混合坐标。或者，你可以回到德拉斯泰尔的原始概念，并将整个消息的坐标作为单个块。无论哪种方式，使用共轭矩阵，此密码的评级为八。使用双列置换，密码的评级为十。假设有四个长的独立密钥和混合良好的字母表，这是一种无法破解的纸笔密码。称之为*双列置换双重栅栏*。
- en: 9.7 Diagonal bifid
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 对角双重栅栏
- en: A variation on the bifid cipher is to write the Polybius coordinates vertically
    under each letter, as usual, but to read them out diagonally, going from lower
    left to upper right (or southwest to northeast). This is called a *left diagonal*
    or an *antidiagonal*. (On a heraldic crest it is called *bar sinister*, and indicates
    out-of-wedlock birth.) For the last letter, you wrap to the first column (the
    shaded digit 1). The advantage of this is that there are no naturals or half-naturals
    to help Emily guess words. Here is an example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对双重栅栏密码的变种是将波利比斯坐标垂直地写在每个字母下面，然后沿对角线从左下到右上（或从西南到东北）读取它们。这被称为*左对角线*或*反对角线*。（在纹章的冠上，它被称为*邪恶的酒吧*，并表示非婚生的出生。）对于最后一个字母，你会回到第一列（阴影部分的数字1）。这样做的好处是没有自然数或半自然数可以帮助艾米莉猜测单词。这是一个例子。
- en: '![9-unnumb-25](../Images/9-unnumb-25.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-25](../Images/9-unnumb-25.png)'
- en: Diagonal bifid is rated Four. With conjugated matrices it is rated Five. With
    conjugated matrices and periodically varying block sizes it is rated Six. Unlike
    classical bifid, both odd and even block sizes can be used with diagonal bifid.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对角 bifid 被评为 Four。与共轭矩阵一起，它被评为 Five。与共轭矩阵和定期变化的块大小一起，它被评为 Six。与古典 bifid 不同，对角
    bifid 可以使用奇数和偶数块大小。
- en: 9.8 6×6 squares
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 6×6 方阵
- en: If your messages contain a lot of numbers, it may be advantageous to use a 6×6
    Polybius square instead of a 5×5 square. A 6×6 square allows you to have the full
    26-letter alphabet plus the numerals from 0 to 9\. There is no need to omit J
    or Q from the alphabet. If you are enciphering by hand, this requires taking extra
    care to distinguish the letters O, I, Z, S and G from the digits 0, 1, 2, 5 and
    6\. Some people adopt special conventions, such as underlining all digits. I find
    this cumbersome and error-prone. I usually just exaggerate the characteristics
    that distinguish each of these characters from its mate, such as writing the letter
    I with extra-wide serifs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的消息包含很多数字，使用 6×6 的 Polybius 方阵而不是 5×5 方阵可能会更有优势。6×6 方阵允许您使用完整的 26 个字母表以及从
    0 到 9 的数字。不需要从字母表中省略 J 或 Q。如果你正在手动加密，这就需要额外小心地区分字母 O、I、Z、S 和 G 与数字 0、1、2、5 和 6。一些人采用特殊的惯例，例如在所有数字下划线。我觉得这样很麻烦且容易出错。我通常只是夸大区分这些字符与它们的同伴的特征，例如用额外宽的衬线写字母
    I。
- en: All of the methods from the preceding 5 sections, namely Playfair, Two Square,
    Three Square, Four Square and Bifid, can be used with 6×6 squares, along with
    all of their variations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面 5 节中的所有方法，即 Playfair、Two Square、Three Square、Four Square 和 Bifid，都可以与 6×6
    方阵一起使用，以及它们的所有变体。
- en: 9.9 Trifid
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9 三重置
- en: If you like squares, how about cubes? Another fractionation method, also invented
    by Félix-Marie Delastelle in the 1890s, is the *Trifid* cipher. Instead of representing
    each letter of the alphabet by two digits in base 5 (quinary numbers), each letter
    is represented by three base-3 digits (ternary numbers). This gives 3×3×3, or
    3³, different 3-digit combinations. This is enough for all 26 letters of the alphabet
    plus one extra character. Delastelle used a + plus sign for the 27th character.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢方阵，那么立方体呢？另一种分数方法，也是在 1890 年代由 Félix-Marie Delastelle 发明的，是 *Trifid* 密码。与通过在基数
    5（五进制数）中的两位数字来代表字母不同，每个字母由三位基数为 3 的数字（三进制数）表示。这给出了 3×3×3，或 3³，不同的 3 位数字组合。这足以表示字母表中的所有
    26 个字母加上一个额外的字符。Delastelle 使用了一个 + 加号表示第 27 个字符。
- en: The extra character + might be used as a form of punctuation, or it might be
    a signal that the following plaintext letter should be interpreted as a digit.
    The correspondence +A = 1, +B = 2, ... , +J = 0 could be used. The rest of the
    alphabet could also be used as special characters. For example, +K could mean
    period, +L could mean comma, and so forth.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的字符 + 可以用作标点符号的形式，或者它可能是一个信号，表示接下来的明文字母应该被解释为一个数字。对应关系 +A = 1, +B = 2, ...
    , +J = 0 可以被使用。字母表的其余部分也可以被用作特殊字符。例如，+K 可以表示句号，+L 可以表示逗号，等等。
- en: Just as the 2-digit combinations can be displayed as a 5×5 letter square, the
    3-digit combinations can be displayed as a 3×3×3 letter cube. The 3 digits in
    each triple can be interpreted as the coordinates in the cube where that letter
    is located. These coordinates are commonly called the layer, the row and the column.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 2 位数字组合可以显示为 5×5 字母方阵一样，3 位数字组合可以显示为 3×3×3 字母立方体。每个三元组中的 3 位数字可以被解释为该字母位于的立方体中的坐标。这些坐标通常称为层、行和列。
- en: Here are the 27 ternary combinations, in order, with letter equivalents weakly
    mixed by using the keyword EXAMPLE and alternating columns. For instance, the
    letter N is represented by the triple 102, so it would be located on layer 1,
    row 0 and column 2 of the 3×3×3 letter cube.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 27 个三元组合，按顺序排列，字母等效通过使用关键词 EXAMPLE 弱混合，并交替列。例如，字母 N 由三元组 102 表示，因此它将位于 3×3×3
    字母立方体的第 1 层、第 0 行和第 2 列。
- en: '![9-unnumb-26](../Images/9-unnumb-26.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-26](../Images/9-unnumb-26.png)'
- en: The trifid cipher works similarly to the bifid cipher. The plaintext is written
    in blocks of some fixed size. The size may be any number that is not a multiple
    of 3\. The 3 digits are written vertically beneath each letter of the message,
    and then read out horizontally in groups of 3\. Then they are converted back into
    letters using the same equivalences. Here is an example with the plaintext SEND
    HELP and block size 4.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 三方加密器的工作原理与双重加密器类似。明文按固定大小的块写入。大小可以是任何不是 3 的倍数的数字。将这 3 位数字垂直写在每个消息字母下面，然后水平分组读取。然后使用相同的等价关系将它们转换回字母。这里有一个明文为
    SEND HELP，块大小为 4 的示例。
- en: '![9-unnumb-27](../Images/9-unnumb-27.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-27](../Images/9-unnumb-27.png)'
- en: The same analysis and techniques that were used for bifid can also be applied
    to trifid, and they have the same ratings. You can use two separate substitution
    tables for converting the letters to digits and the digits back to letters. You
    can vary the block sizes. You can start reading out the digits from different
    places in each block. You can use a strong transposition to mix the ternary digits.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 用于双重加密器的相同分析和技术也可以应用于 trifid，并且具有相同的评级。您可以使用两个单独的替换表将字母转换为数字，然后将数字转换回字母。您可以变化块的大小。您可以从每个块的不同位置开始读取数字。您可以使用强大的置换来混合三进制数字。
- en: A natural question is whether there is a diagonal version of the trifid cipher
    analogous to diagonal bifid. The advantage of diagonal bifid over the original
    bifid is that the diagonal version does not give rise to the half-naturals that
    weaken the original version. In the analogous diagonal trifid the middle digit
    of every group would be a third-natural, so the advantage is lost. The problem
    of naturals disappears, though, if you use two different mixed alphabets, one
    for writing in the digits and another for reading them out. Diagonal trifid with
    two alphabets is rated Five.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自然的问题是是否有与对角双重加密器类似的对角 trifid 加密器。对角双重加密器比原始双重加密器的优势在于，对角版本不会产生削弱原始版本的半自然数。在类似的对角
    trifid 中，每组的中间数字将是第三自然数，因此失去了优势。然而，如果您使用两个不同的混合字母表，一个用于数字的书写，另一个用于读取它们，则自然问题会消失。带有两个字母表的对角
    trifid 的评分为五。
- en: 9.10 Three Cube
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.10 三方加密器
- en: As I was typing the preceding paragraph about the trifid cipher, I realized
    that the 3×3×3 cubic arrangement lends itself to a 3-dimensional analogue to the
    Two Square cipher described in section 9.3\. It is easy to visualize the Two Square
    cipher in two dimensions, but much harder to visualize a cube in three dimensions,
    so I am going to describe the new cipher solely in terms of the coordinates. Let’s
    call this cipher *Three Cube*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在打前面关于 trifid 加密器的段落时，我意识到 3×3×3 的立方排列非常适合于描述第 9.3 节中描述的双重加密器的三维类比。在两个维度中很容易想象双重加密器，但在三个维度中很难想象一个立方体，因此我将仅根据坐标描述新的加密器。让我们将此加密器称为
    *三方加密器*。
- en: Two Square enciphers two letters at a time using two substitution tables, ergo
    Three Cube will encipher three letters at a time using three substitution tables.
    Here is a set of three tables well-mixed using the keywords COLUMBIA, STANFORD
    and HOPKINS. These three substitution tables are designated S, T and U. That’s
    S for Substitution, T for Table, and U for the next letter in the alphabet.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 两方加密器一次加密两个字母，使用两个替换表，因此三方加密器会一次使用三个替换表加密三个字母。这里是使用关键字 COLUMBIA、STANFORD 和 HOPKINS
    很好地混合了的三个表。这三个替换表分别标记为 S、T 和 U。这里的 S 表示替换（Substitution），T 表示表（Table），U 表示字母表中的下一个字母。
- en: The substitution tables correspond the 26 letters of the alphabet and the character
    + with the 27 ternary triplets.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 替换表对应字母表的 26 个字母和字符 + 与 27 个三元组。
- en: '![9-unnumb-28](../Images/9-unnumb-28.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-28](../Images/9-unnumb-28.png)'
- en: Like trifid, Three Cube begins by writing the 3-digit triplet for each letter
    vertically beneath it. The 3 digits for the first letter are taken from substitution
    table S, the 3 digits for the second letter are taken from table T, and the 3
    digits for the third letter are taken from U. The pattern is shown here and illustrated
    by the trigram FLY.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与 trifid 类似，三方加密器首先将每个字母的 3 位数字三元组垂直写在其下方。第一个字母的 3 位数字来自替换表 S，第二个字母的 3 位数字来自表
    T，第三个字母的 3 位数字来自 U。该模式在此处显示，并由三元组 FLY 进行说明。
- en: '![9-unnumb-29](../Images/9-unnumb-29.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-29](../Images/9-unnumb-29.png)'
- en: Then the digits are read out left to right, and these horizontal triplets are
    converted back to letters. It would seem natural to use table S for converting
    the top row, table T for the middle row and table U for the bottom row. However,
    that would lead to a 1 in 9 chance that the top row would be identical to the
    left column, so that the first plaintext letter would be replaced by itself. That
    is, there is 1 chance in 9 that S1S2S3 is the same as S1T1U1\. The same is true
    for the middle and bottom rows. Let’s call this situation, where one digit is
    the same, a *part natural*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从左到右读出数字，并将这些水平三元组转换回字母。使用表S转换顶行，表T转换中行，表U转换底行似乎很自然。然而，这会导致顶行与左列相同的概率为9分之1，因此第一个明文字母将被自身替换。也就是说，S1S2S3与S1T1U1相同的可能性为9分之1。中行和底行也是如此。让我们将这种情况称为*部分自然*。
- en: For this reason, substitution table S is used for the second row, table T is
    used for the third row, and table U is used for the top row. This eliminates the
    naturals. Here is the pattern.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，第二行使用替换表S，第三行使用表T，顶行使用表U。这样就消除了自然性。以下是模式。
- en: '![9-unnumb-30](../Images/9-unnumb-30.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-30](../Images/9-unnumb-30.png)'
- en: Since this is hard to keep straight when you are enciphering by hand, I suggest
    writing the choice of substitution table over each triplet of digits. This is
    similar to writing the key letter over each plaintext letter when using the Belaso
    cipher (section 5.5). Here is an example of Three Cube using the plaintext message
    FLY TO ROME.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于手动加密时很难保持清晰，我建议在每个数字三元组上面写上替换表的选择。这类似于使用贝拉索密码（第5.5节）时在每个明文字母上写上密钥字母。以下是使用明文消息FLY
    TO ROME的三方块加密的示例。
- en: '![9-unnumb-31](../Images/9-unnumb-31.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-31](../Images/9-unnumb-31.png)'
- en: The Three Cube cipher is rated Seven.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 三方块密码的评级为七。
- en: There is a simple way to strengthen the Three Cube cipher. Instead of converting
    the triplets back to letters using the three substitution tables in strict rotation
    as we just did, use a key to set the order of the read-out tables. The key would
    consist of the letters S, T and U in some scrambled order, for example SUTUTTUUSTS.
    The length of this key should not be a multiple of 3\. I call this variant *Three
    Cube Plus*. Here is how FLY TO ROME would be enciphered using this read-out key.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种简单的方法可以加强三方块密码。不再像刚才那样使用三个替换表严格轮换地将三元组转换回字母，而是使用一个密钥来设置读出表的顺序。该密钥将由字母S、T和U以某种打乱的顺序组成，例如SUTUTTUUSTS。这个密钥的长度不应该是3的倍数。我将这个变种称为*三方块加密*。以下是使用这个读出密钥对FLY
    TO ROME进行加密的方法。
- en: '![9-unnumb-32](../Images/9-unnumb-32.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-32](../Images/9-unnumb-32.png)'
- en: Using Three Cube Plus about 1/3 of the letters will have part naturals. That
    is, one of the 3 write-in digits will be the same as one of the read-out digits.
    However, Emily will not know which letters have this defect, and will not be able
    to exploit it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三方块加密，大约有三分之一的字母会有部分自然性。也就是说，三个填写数字中的一个将与三个读出数字中的一个相同。然而，艾米丽不会知道哪些字母有这种缺陷，也无法利用它。
- en: Three Cube Plus is rated Nine.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 三方块加密的评级为九。
- en: So, you might well be saying, is it possible to nudge the rating up to Ten without
    making the cipher too complex for hand use? Thank you for asking. First off, let’s
    increase the number of substitution tables from 3 to 6\. Let’s call them S, T,
    U, V, W and X. Instead of writing in the triplets using a strict rotation STU,
    STU, STU, ... we will use another letter key consisting of those 6 letters in
    some scrambled order. The write-in key could be TWXUSTTVWV, and the read-out key
    could be VWTXXSUSVTU. Ideally, the lengths of these keys would be mutually prime,
    and neither length would be divisible by 3\. Here the lengths are 10 and 11\.
    Let’s call this cipher *Three Cube Super*. This is an example of Three Cube Super
    using the plaintext FLY TO NEW YORK.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能会说，是否可能将评级提高到十，而不使密码对手工使用过于复杂？感谢你的提问。首先，让我们将替换表的数量从3增加到6。让我们称它们为S、T、U、V、W和X。我们将不再使用严格的STU、STU、STU...轮换写入三元组，而是使用另一个字母密钥，该密钥由这6个字母以某种打乱的顺序组成。填写密钥可以是TWXUSTTVWV，读出密钥可以是VWTXXSUSVTU。理想情况下，这些密钥的长度应该是互质的，并且两者的长度都不可被3整除。在这里，长度分别为10和11。我们将这个密码称为*三方块超级密码*。这是一个使用明文FLY
    TO NEW YORK的三方块超级密码的示例。
- en: '![9-unnumb-33](../Images/9-unnumb-33.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-33](../Images/9-unnumb-33.png)'
- en: Three Cube Super is rated Ten. This is another unbreakable hand cipher.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 三方块超级密码的评级为十。这是另一种不可破解的手工加密。
- en: 9.11 Rectangular grids
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.11 矩形网格
- en: Up to now we have discussed only square and cubic arrays of letters. There is
    no restriction in cryptography that requires all of the dimensions of a letter
    grid to be the same. It is basically a historical accident that the English alphabet
    has 26 letters, and 26 is very close to 5×5\. If we used the 33-letter Russian
    alphabet we might choose a 4×8 or 5×7 rectangle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了字母的方形和立方体阵列。在密码学中，没有要求字母网格的所有维度都相同的限制。英文字母表有26个字母基本上是历史的偶然。如果我们使用33个字母的俄语字母表，我们可能会选择4×8或5×7的矩形。
- en: If we want to have all 26 letters of the alphabet, then a 3×9 or 4×7 rectangle
    might be preferable. These give you the full 26-letter alphabet plus one or two
    extra characters. We have discussed the use of such extra characters earlier,
    for example for switching between letters and numerals. Most of the ciphers based
    on Polybius squares work just as well with 3×9 or 4×7 rectangles as they do with
    5×5 squares, assuming all of the rectangles are oriented in the same direction.
    These are the Playfair, the Two Square, the Three Square, the Four Square, and
    the diagonal bifid ciphers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要所有26个字母的字母表，那么3×9或4×7的矩形可能更可取。这些给您提供了完整的26个字母的字母表，再加上一个或两个额外字符。我们之前已经讨论过这些额外字符的使用，例如用于在字母和数字之间切换。基于波利比奥斯方格的大多数密码与5×5方格一样适用于3×9或4×7的矩形，假设所有矩形都以相同的方向排列。这些是Playfair、Two
    Square、Three Square、Four Square和对角线bifid密码。
- en: In fact, these 5 ciphers may be stronger when used with those rectangles because
    each letter of the alphabet has more possible substitutes. The downside, when
    using Playfair or Two Square, is that there is a higher probability that the two
    letters are on the same row, and therefore are replaced with the letters below
    them or to their right.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当与那些矩形一起使用时，这5种密码可能更强大，因为字母表中的每个字母都有更多可能的替代字符。使用Playfair或Two Square时的缺点是，两个字母在同一行的概率较高，因此它们将被其下方或右侧的字母替换。
- en: 'Here is an example of a Playfair cipher done with a 3×9 rectangle:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用3×9矩形进行Playfair密码的示例：
- en: '![9-unnumb-34](../Images/9-unnumb-34.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-34](../Images/9-unnumb-34.png)'
- en: 9.12 Hexadecimal fractionation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.12 十六进制分数
- en: So far this chapter has focused solely on hand methods. This meant small arrays
    using only the uppercase alphabet. For computer use you usually want the full
    alphabet, uppercase and lowercase, numbers, punctuation, special symbols, diacritics,
    and perhaps multiple alphabets. In short you may want the full text capabilities
    of the computer. The simplest way to do this is to represent each character by
    an 8-bit byte using one of the standard computer codes such as UTF-8 or UTF-16.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章仅专注于手动方法。这意味着仅使用大写字母的小数组。对于计算机使用，通常希望使用完整的字母表，包括大写和小写字母、数字、标点符号、特殊符号、音标，以及可能是多个字母表。简而言之，您可能希望拥有计算机的完整文本功能。做到这一点的最简单方法是使用标准计算机代码之一，如UTF-8或UTF-16，将每个字符表示为一个8位字节。
- en: A natural way to fractionate an 8-bit byte is to split it into two 4-bit hexadecimal
    digits, or hex digits. All of the fractionation methods that are based on Polybius
    squares also work for 16×16 squares, namely Playfair, Two Square, Three Square,
    Four Square, and bifid. If the 16×16 square is well-mixed using a large key, these
    methods are stronger than the same methods used with 5×5 squares. This is because
    there are vastly more arrangements of 256 characters than of 25 characters, namely
    8.58×10^(506) versus 1.55×10^(25).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将8位字节分数化的一种自然方式是将其拆分为两个4位十六进制数字，或十六进制数字。所有基于波利比奥斯方格的分数化方法也适用于16×16方格，即Playfair、Two
    Square、Three Square、Four Square和bifid。如果16×16方格使用大密钥混合得很好，那么这些方法比使用5×5方格的同一方法更强大。这是因为256个字符的排列方式远远多于25个字符的排列方式，即8.58×10^(506)与1.55×10^(25)。
- en: A simple method for using hexadecimal fractionation is to (1) convert the characters
    of the message to hexadecimal digits by using a well-mixed keyed substitution
    table, (2) scramble those digits using some transposition cipher, and then (3)
    convert the pairs of hex digits back to bytes using a second well-mixed keyed
    substitution table.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制分数化的简单方法是：(1)通过使用混合得很好的密钥替换表将消息的字符转换为十六进制数字，(2)使用一些置换密码对这些数字进行混淆，然后(3)使用第二个混合得很好的密钥替换表将十六进制数字的对转换回字节。
- en: The simplest transposition is just moving the first hex digit to the end, so
    that 12 34 56 78 would become 23 45 67 81\. This might be called *Cycle Hex*.
    It is essentially diagonal bifid (section 9.7) done in base 16 instead of base
    5\. Cycle hex is rated Five. You could also use the piecewise reversal transposition
    described in section 4.6.1 to scramble the letter order. This might be called
    *Piecewise Hex*. It is also rated Five. A stronger method would be to scramble
    the hex digits using a columnar transposition cipher. This could be called *Columnar
    Hex*. It is rated Seven. With a double columnar transposition the rating increases
    to Ten.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的转位法就是将第一个十六进制数字移到末尾，这样 `12 34 56 78` 就会变成 `23 45 67 81`。这可能被称为 *Cycle Hex*。它本质上是对角线的二重置位（第
    9.7 节），只不过是在基数为 16 而不是基数为 5 下进行的。Cycle hex 评级为 Five。你也可以使用第 4.6.1 节描述的逐段反转置换来打乱字母顺序。这可能被称为
    *Piecewise Hex*。它也评级为 Five。一种更强大的方法是使用列转位密码来打乱十六进制数字。这可以称为 *Columnar Hex*。它评级为
    Seven。使用双列转位置换后，评级增至 Ten。
- en: These methods can be used to encipher any computer file. However, if the files
    are pure text, the methods can be further enhanced. Pure text will normally use
    fewer than 100 of the 256 possible byte values. The remaining character codes
    can be used for nulls, bigrams, trigrams and other purposes described in section
    6.4\. If done well, this raises the ratings to cycle hex Six, piecewise hex Six,
    and columnar hex Eight.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以用于对任何计算机文件进行加密。但是，如果文件是纯文本，则可以进一步增强这些方法。纯文本通常会使用少于 256 个可能的字节值中的 100 个以下。其余的字符代码可以用于空值、双字母组、三字母组和第
    6.4 节描述的其他用途。如果做得好，这会将 cycle hex 的评级提升至 Six，piecewise hex 的评级提升至 Six，columnar
    hex 的评级提升至 Eight。
- en: 9.13 Bitwise fractionation
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.13 位级分数化
- en: Fractionation can also be done with the individual bits that represent the characters
    in a message. The block of N characters would be represented by 8N bits. These
    can be formed into a rectangle in several ways, such as 2×4N, 4×2N, 8×N and N×8\.
    For example, a block of 5 letters would be represented by 40 bits, which could
    be written as 2 rows of 20 bits, 4 rows of 10 bits, 8 rows of 5 bits, or 5 rows
    of 8 bits. This is cumbersome for hand operations, but easily done with a computer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 分数化也可以用于表示消息中代表字符的各个位。长度为 N 的字符块将由 8N 位表示。这些可以以几种方式形成矩形，例如 2×4N、4×2N、8×N 和 N×8。例如，5
    个字母的块将由 40 位表示，可以写成 2 行 20 位、4 行 10 位、8 行 5 位或 5 行 8 位。这对手工操作来说很麻烦，但在计算机上很容易实现。
- en: Here is an example of how 5 characters can be written horizontally into a 5×8
    block and then read out vertically. This example uses the standard UTF-8 character
    codes. For example, uppercase letter A is represented as 01000001\. The plaintext
    is the word DELTA.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示了如何将 5 个字符水平写入一个 5×8 的块中，然后垂直读出。此示例使用标准的 UTF-8 字符代码。例如，大写字母 A 表示为 01000001。明文是单词
    DELTA。
- en: '![9-unnumb-35](../Images/9-unnumb-35.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-35](../Images/9-unnumb-35.png)'
- en: The bits are read out going down the columns. Since each column contains only
    5 bits, each byte of the ciphertext must span two or more columns. The 8 bits
    for the first ciphertext byte are found in columns 1 and 2 with medium highlighting.
    The first column contains 00000, and the first 3 bits in the second column are
    111, so the first byte of the ciphertext is 00000111, or hex 07\. This is the
    control character BELL, dating back to the teletype era, when it used to cause
    the carriage-return bell to sound. It has no graphic representation anymore. I
    will use the note **♪** to represent the bell character.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 位按列向下读取。由于每列只包含 5 位，因此每个密文字节必须跨越两列或更多列。第一个密文字节的 8 位位于列 1 和列 2 中，并用中等高亮度显示。第一列包含
    00000，第二列的前 3 位为 111，因此密文的第一个字节为 00000111，或十六进制 07。这是控制字符 BELL，可以追溯到电传打字机时代，当时会发出退格铃声。它现在已经没有图形表示。我会用符号
    **♪** 来代表铃声字符。
- en: The second ciphertext byte comes from the darker highlighted section spanning
    columns 2, 3 and 4\. The last 2 bits in column 2 are 11, column 3 contains 00000,
    and the first bit in column 4 is 0\. Combining these, the second ciphertext byte
    is 11000000\. This represents the character **À**, which is an uppercase **A**
    with a grave accent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个密文字节来自跨越列 2、3 和 4 的较暗突出部分。第二列的最后 2 位是 11，第三列包含 00000，第四列的第一位是 0。结合这些，第二个密文字节为
    11000000。这代表字符 **À**，是一个带重音符号的大写字母 **A**。
- en: Bytes 3 and 4 of the ciphertext are **“** and **x**, that is, double quote and
    lowercase x. The fifth byte comes from columns 7 and 8, namely 000 and 01001\.
    The byte 00001001 represents the **HTAB**, or horizontal tab character, which
    is invisible. I will use the arrowhead **►** to represent it. Thus the ciphertext
    is **♪À“x►**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 密文的第3和第4个字节是**“**和**x**，即双引号和小写字母x。第五个字节来自第7和第8列，即000和01001。字节00001001代表**HTAB**，或水平制表符，是看不见的。我将使用箭头头部**►**来表示它。因此密文是**♪À“x►**。
- en: This looks pretty cryptic, but the method is weak because it uses the standard
    alphabet for both the conversion of the plaintext into bits and the conversion
    from bits back to characters. It is rated One. If two independent well-mixed keyed
    alphabets are used for these steps, then this cipher is simply a binary version
    of the conjugated matrix bifid (section 9.6.1). This method could be called *Hex
    Rectangle*. It has the same rating as the conjugated matrix bifid cipher, namely
    Five.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很神秘，但这种方法很弱，因为它在将明文转换为比特和将比特转换回字符时使用了标准字母表。它被评为一。如果这些步骤使用了两个独立的混合密钥字母表，则此密码只是共轭矩阵双字母变体（9.6.1节）的二进制版本。这种方法可以称为*Hex
    Rectangle*。它与共轭矩阵双字母变体密码具有相同的评级，即五。
- en: It is natural to form eight 8-bit bytes into an 8×8 bit square. Write the 8
    bits for each character vertically into the square using a mixed alphabet, and
    read them out horizontally using a different mixed alphabet. This is just an 8×8
    square version of the hex rectangle, and has the rating Six.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地将八个8位字节形成一个8×8比特方块。使用一个混合字母表将每个字符的8位写入方块中，并使用另一个混合字母表水平地读取它们。这只是十六进制矩形的一个8×8方块版本，评级为六。
- en: 9.13.1 Cyclic 8×N
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.13.1 循环8×N
- en: It is easy to improve the strength of this cipher. For any block of N characters,
    write their 8-bit representations into an 8×N rectangle vertically. Shift each
    row cyclically to the left by some amount from 0 to N-1 bit positions. For example,
    abcdefgh cyclically shifted, or *rotated*, left by 2 positions would give cdefghab.
    Then read each 8-bit column out vertically. Here is an example using an 8×8 bit
    square. Each row is cycled left by the amount indicated to its left.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提高此密码的强度很容易。对于任何N个字符的块，垂直地将它们的8位表示写入8×N的矩形中。将每行循环地向左移动0到N-1位位置。例如，abcdefgh循环左移2个位置将得到cdefghab。然后垂直地读取每个8位列。这里有一个使用8×8比特方块的示例。每行都按其左侧指示的量向左循环。
- en: '![9-unnumb-36](../Images/9-unnumb-36.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-36](../Images/9-unnumb-36.png)'
- en: This cipher is at the limit of what can be done by hand. It requires 3 keys,
    namely 2 keys for mixing the 2 alphabets, and an 8-digit key for specifying the
    shift amounts. It can be called *Cyclic 8×N*. When N is 6 or larger it is rated
    Seven. The cipher gets stronger as the block size, N, increases.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种密码已经达到了手工操作的极限。它需要3个密钥，即两个用于混合两个字母表的密钥，以及一个用于指定位移量的8位数字密钥。它可以称为*Cyclic 8×N*。当N为6或更大时，它被评为七。随着块大小N的增加，密码变得更强大。
- en: When the rectangle is square you can rotate both the rows and columns to get
    a *Bicyclic 8×8* cipher. You should alternate directions for this. Write the bits
    in horizontally, cycle the bits vertically, cycle the bits horizontally, and read
    out the characters vertically. The Bicyclic 8×8 is rated Eight.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当矩形是正方形时，你可以同时旋转行和列，得到一个*Bicyclic 8×8*密码。你应该交替方向进行。水平写入位，垂直循环位，水平循环位，然后垂直读取字符。Bicyclic
    8×8被评为八。
- en: The cyclic 8×N cipher can be repeated to get a *Double Cyclic 8×N* cipher. This
    requires 5 keys, namely 3 keys to mix the 3 alphabets, and two 8-digit keys to
    control the 2 rounds of shifting. There are 5 steps. (1) Use the first alphabet
    to do a simple substitution. The resulting N bytes are written into the 8×N bit
    rectangle vertically. (2) Cyclically shift the rows using the first shift key.
    (3) Use the second alphabet to perform a simple substitution on the N columns.
    (4) Cyclically shift the rows using the second shift key. (5) Use the third alphabet
    to perform a final simple substitution on the vertical columns. Notice that all
    the shifts are horizontal and all the substitutions are vertical. The double cyclic
    8×N cipher is rated Nine.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 循环8×N密码可以重复以获得*双循环8×N*密码。这需要5个密钥，即3个用于混合3个字母表的密钥，以及两个用于控制2轮移位的8位密钥。共有5个步骤。（1）使用第一个字母表进行简单替换。生成的N个字节被垂直地写入8×N位的矩形中。（2）使用第一个移位密钥循环移动行。（3）使用第二个字母表对N列执行简单替换。（4）使用第二个移位密钥循环移动行。（5）使用第三个字母表对垂直列执行最终的简单替换。注意，所有的移位都是水平的，所有的替换都是垂直的。双重循环8×N密码的评级为九。
- en: This can be continued to *Triple*, *Quadruple* and beyond, if desired. All of
    these variations can be further enhanced by varying the block sizes, either periodically
    or using a random number generator.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以继续进行*三重*、*四重*等等。所有这些变化都可以通过周期性地或使用随机数发生器来变化块大小来进一步增强。
- en: 9.14 Other fractionation
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.14 其他分数
- en: In sections 9.12 and 9.13 we looked at dividing a byte into two hexadecimal
    digits or into eight individual bits. There are numerous other ways of partitioning
    8 bits, such as 3,2,3\. If the 3,2,3 bit representation of each character is written
    vertically, and then the 3 rows are cyclically shifted left by some number of
    positions, then each column will still have the 3,2,3 bit distribution, so the
    8 bits can be converted back into bytes. Here is an example. Each row is cycled
    left by the number of positions shown at the left, that is, 1 position, 3 positions
    and 2 positions, respectively.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9.12和9.13节中，我们看过将一个字节分成两个十六进制数字或分成八个单独的位。将8位分成许多其他方式，如3,2,3。如果将每个字符的3,2,3位表示垂直地写下来，然后将3行按某个位置数循环向左移动，那么每一列仍然会有3,2,3位的分布，因此8位可以被转换回字节。这里是一个例子。每一行按左边显示的位置数循环左移，即分别为1个位置，3个位置和2个位置。
- en: '![9-unnumb-37](../Images/9-unnumb-37.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-37](../Images/9-unnumb-37.png)'
- en: Here the plaintext RETREAT has been transformed into the ciphertext **@w«****θ****K_****╝**.
    Let’s call this a *BitCycle Substitution*. This method is rated Five. Like the
    cyclic 8×N cipher in section 9.13.1, this can be doubled, tripled, or more, and
    the block sizes can be varied.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里明文RETEAT已经被转换成了密文**@w«****θ****K_****╝**。我们称之为*BitCycle Substitution*。这种方法的评级为五。与第9.13.1节中的循环8×N密码一样，这可以加倍、三倍或更多，并且块大小可以变化。
- en: This basic idea can be enhanced in two powerful ways.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本思想可以以两种强大的方式进行增强。
- en: First, the bytes can be divided in several different ways, such as 1,3,2,2 or
    2,4,2\. For example, you could encipher the block first using the 3,2,3 split,
    then reencipher it using the 1,3,2,2 split, then reencipher that using the 2,4,2
    split. This would involve 7 keys and 7 steps. (1) Use the first substitution to
    produce the 3,2,3 bit representation of the message. (2) Shift the 3 rows using
    the first shift key. (3) Use the second substitution to produce the 1,3,2,2 bit
    representation of the bytes. (4) Shift the 4 rows according to the second shift
    key. (5) Use the third substitution to produce the 2,4,2 bit representation of
    the bytes. (6) Shift the 3 rows according to the third shift key. (7) Use the
    fourth substitution to produce the final ciphertext bytes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，字节可以被分成几种不同的方式，例如1,3,2,2或2,4,2。例如，你可以首先使用3,2,3的分割方式对块进行加密，然后使用1,3,2,2的分割方式重新加密，然后再使用2,4,2的分割方式重新加密。这将涉及7个密钥和7个步骤。（1）使用第一个替换产生消息的3,2,3位表示。（2）使用第一个移位密钥移动3行。（3）使用第二个替换产生字节的1,3,2,2位表示。（4）根据第二个移位密钥移动4行。（5）使用第三个替换产生字节的2,4,2位表示。（6）根据第三个移位密钥移动3行。（7）使用第四个替换产生最终的密文字节。
- en: Second, the message blocks can be divided in several different ways. Suppose
    you used long plaintext blocks of, say, 32 characters. For Step 2 in the previous
    technique you could divide the 32 bytes into groups of 6, 14 and 12 bytes. For
    Step 4 you could divide the 32 bytes into groups of 11, 8 and 13 bytes. For Step
    6 you could divide the 32 bytes into groups of 8, 17 and 7 bytes. Each group would
    be shifted independently. This division could be different for every message.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，消息区块可以以几种不同的方式划分。假设你使用长的明文区块，比如32个字符。对于前一种技术的第2步，你可以将32字节分成6、14和12字节的组。对于第4步，你可以将32字节分成11、8和13字节的组。对于第6步，你可以将32字节分成8、17和7字节的组。每个组都将独立移位。这种划分对每条消息可能是不同的。
- en: Or, you could take a more inclusive approach. For Step 2, divide the entire
    message into blocks of size X. For Step 4, divide the message into blocks of size
    Y. For Step 6, divide the message into blocks of size Z. X, Y and Z may be any
    length from 6 bytes up to the full message length.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以采取更包容的方法。对于第2步，将整个消息划分为大小为X的区块。对于第4步，将消息划分为大小为Y的区块。对于第6步，将消息划分为大小为Z的区块。X、Y和Z的长度可以是从6字节到整个消息长度的任意长度。
- en: I will not rate all of the variations of the BitCycle substitution. Suffice
    to say that the ratings may range anywhere from Five to Ten. In chapter 12 I will
    describe how you can verify that a block cipher truly deserves a rating of Ten.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会评价所有BitCycle替换的变体。可以说，评级可能从五到十不等。在第12章中，我将描述如何验证一个区块密码是否真正值得得到十分评级。
- en: 9.15 Stronger blocks
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.15 更强大的区块
- en: 'Several of the ciphers described in this chapter work on blocks of plaintext.
    There are several things that you can do to the plaintext blocks to make your
    cipher just a bit harder for Emily. Here is a short list of ideas:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的几种密码技术适用于明文区块。有几种方法可以对明文区块进行处理，使你的密码对艾米莉来说稍微困难一些。以下是一些想法的简短列表：
- en: Vary the block lengths, periodically or pseudorandomly.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期性或伪随机地改变区块长度。
- en: Reverse the first few letters of each block, periodically or pseudorandomly.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转每个区块的前几个字母，周期性或伪随机地。
- en: Reverse the last few letters of each block, periodically or pseudorandomly.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转每个区块的最后几个字母，周期性或伪随机地。
- en: Cycle each block left or right, periodically or pseudorandomly.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期性或伪随机地将每个区块向左或向右循环。
- en: Swap the last N letters of the block with the first N letters of the next block.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将区块的最后N个字母与下一个区块的前N个字母交换。
- en: 'But a word of warning: if you are enciphering and deciphering by hand, use
    these methods sparingly. If you make your cipher so complex that you cannot encipher
    and decipher accurately, then it becomes worthless.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但要警告一句：如果你手动加密和解密，请谨慎使用这些方法。如果你使你的密码变得如此复杂以至于无法准确加密和解密，那么它就变得毫无价值。
