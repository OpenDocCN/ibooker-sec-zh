- en: 16 Three pass protocol
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 三次通行协议
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Three pass protocol based on exponentiation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于指数的三次通行协议
- en: Three pass protocol based on matrix multiplication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于矩阵乘法的三次通行协议
- en: Three pass protocol based on 2-sided matrix multiplication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于双边矩阵乘法的三次通行协议
- en: Sections 2.2 and 2.3 describe how modern cryptography is divided into 3 branches,
    Secret Key, Public Key and Personal Key. Up to this point, this book has described
    only methods for Secret Key cryptography. Public Key cryptography is described
    in many books, so it will not be covered here. This chapter will discuss Personal
    Key cryptography, the lesser-known third branch of cryptography. Personal Key
    cryptography is sometimes called *keyless* cryptography, since the parties do
    not need to transmit or share any keys.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.2节和第2.3节描述了现代密码学分为3个分支，即秘密密钥、公钥和个人密钥。到目前为止，本书仅描述了秘密密钥密码学的方法。公钥密码学在许多书中有描述，因此这里不会涉及。本章将讨论个人密钥密码学，这是密码学的较不为人知的第三个分支。个人密钥密码学有时被称为*无密钥*密码学，因为各方不需要传输或共享任何密钥。
- en: The basic concept of Personal Key cryptography is that each of the two correspondents,
    Sandra and Riva, has her own personal key. This key is never transmitted or shared
    with anyone else, not even with one another, so there is no possibility that Emily
    can learn any of the personal keys through wire-tapping, intercepting broadcasts,
    or any other form of eavesdropping. The great advantage of Personal Key cryptography
    is that you don’t need to set anything up in advance. There does not need to be
    any secret, secure channel for exchanging keys. The messages can be exchanged
    on public channels. No key servers or other infrastructure are required.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 个人密钥密码学的基本概念是，两个通信者Sandra和Riva各自有自己的个人密钥。这个密钥永远不会被传输或与任何其他人共享，甚至不会与彼此共享，因此没有可能通过窃听、拦截广播或任何其他形式的窃听来了解任何个人密钥。个人密钥密码学的巨大优势是你不需要提前设置任何东西。不需要有任何秘密、安全的通道来交换密钥。消息可以在公共通道上交换。不需要密钥服务器或其他基础设施。
- en: 'Personal Key cryptography is accomplished by means of the *three pass protocol*,
    which was invented by Adi Shamir of the Weizmann Institute in Israel, about 1975\.
    To illustrate the method, I devised a little story:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 个人密钥密码学是通过*三次通行协议*实现的，该协议是由以色列魏茨曼学院的阿迪·沙米尔于大约1975年发明的。为了说明这种方法，我想出了一个小故事：
- en: There once was a King who loved the Queen of a neighboring country. To woo the
    Queen, the King wished to send her a precious gem. The King had an impervious
    strongbox and a pickproof lock. But how could he send the key? If the messenger
    had both the key and the strongbox, he could open the box and steal the gem. The
    King could send the key with a second messenger, but he feared the two messengers
    would arrange to meet up along the route and steal the gem together. The Queen
    proposed an ingenious solution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一位国王爱上了邻国的女王。为了追求女王，国王希望送她一颗珍贵的宝石。国王有一个坚固的保险箱和一个防拆锁。但是他怎么能送钥匙呢？如果信使既有钥匙又有保险箱，他就可以打开箱子并偷走宝石。国王可以用第二位信使送钥匙，但他担心两位信使会在途中相遇并一起偷走宝石。女王提出了一个巧妙的解决方案。
- en: The King would put his lock on the strongbox and send it to the Queen. She would
    then add her own lock and send the strongbox back with both locks. The King would
    then remove his lock with his key, and send the strongbox back with only the Queen’s
    lock. She could then unlock the box with her own key and get the gem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 国王会在保险箱上放上他的锁，并将其发送给王后。然后她会添加自己的锁，并带着两把锁把保险箱送回来。国王然后用自己的钥匙取下他的锁，并只带着王后的锁把保险箱送回来。然后她可以用自己的钥匙打开箱子并拿到宝石。
- en: Here the two locks are stand-ins for two encryptions, and the two keys represent
    the corresponding decryptions. The message would be encrypted with the sender’s
    encryption function, sent to the receiver, encrypted with the receiver’s encryption
    function, sent back to the sender, decrypted with the sender’s decryption function,
    sent back to the receiver and decrypted with the receiver’s decryption function.
    This means the message is sent 3 times, hence the name *three pass protocol*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两把锁代表两个加密，两把钥匙代表相应的解密。消息将使用发送者的加密函数加密，发送给接收者，使用接收者的加密函数加密，发送回发送者，使用发送者的解密函数解密，发送回接收者并使用接收者的解密函数解密。这意味着消息发送了3次，因此称为*三次通行协议*。
- en: '*****Let’s break that down. Let the message be M, let Sandra’s encryption and
    decryption functions be S and S'', and let Riva’s encryption and decryption functions
    be R and R''. On the first pass Sandra encrypts the message M with her encryption
    function S and sends SM to Riva. On the second pass, Riva encrypts that message
    SM with her own encryption function R and sends the doubly encrypted message RSM
    back to Sandra. On the third pass Sandra applies her decryption function S'' to
    the message RSM to get S''RSM. This is intended to remove the S encryption. It
    will only do that if either R and S commute, or S'' and R commute. That would
    mean S''RSM = RS''SM = RM. This lets Riva remove her encryption and read the message.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*****让我们来分解一下。假设消息是M，Sandra的加密和解密函数分别是S和S''，Riva的加密和解密函数分别是R和R''。在第一次传递中，Sandra用她的加密函数S加密消息M并将SM发送给Riva。在第二次传递中，Riva用她自己的加密函数R加密消息SM并将双重加密消息RSM发送回Sandra。在第三次传递中，Sandra将她的解密函数S''应用于消息RSM以获得S''RSM。这旨在去除S加密。只有当R和S可交换，或者S''和R可交换时，才能实现这一点。这意味着S''RSM
    = RS''SM = RM。这使得Riva可以去除她的加密并读取消息。'
- en: 'So, to get this three-pass scheme to work we need to find a commutative encryption
    function, or two encryption functions that commute with one another. I can think
    of 3 commutative encryption functions right off the top of my head: addition,
    multiplication and exclusive-OR. It is easy to imagine an encryption where there
    is a key the same length as the message, and encryption consists of adding the
    key byte by byte to the message, or multiplying the message bytes by the key bytes,
    or exclusive-ORing the message with the key. These are all simple forms of the
    one-time pad.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使这个三次传递方案起作用，我们需要找到一个可交换的加密函数，或者两个彼此可交换的加密函数。我能立刻想到3个可交换的加密函数：加法、乘法和异或。很容易想象出一种加密方式，其中密钥与消息长度相同，加密包括逐字节将密钥加到消息中，或将消息字节乘以密钥字节，或将消息与密钥进行异或。这些都是一次性密码的简单形式。
- en: None of these is secure. If Emily manages to obtain all three encrypted messages,
    she can easily remove the encryptions. If the function is addition, the 3 messages
    are M+S, M+S+R and M+R. If Emily adds the first and third messages and subtracts
    the second message, she gets (M+S)+(M+R)-(M+S+R) = M. The result is exactly M.
    The same method works when the encryption function is multiplication. The 3 messages
    are (M×S), (M×R), and (M×S×R). Taking (M×S)×(M×R)÷(M×S×R) again yields M. When
    the encryption function is exclusive-OR, finding M is even simpler, since exclusive-OR
    is its own inverse. Simply exclusive-OR the 3 encrypted messages together, and
    the result is the original message, (M⊕S)⊕(M⊕R)⊕(M⊕S⊕R) = M.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不安全。如果Emily设法获取所有三条加密消息，她可以轻松地去除加密。如果函数是加法，那么3条消息分别是M+S、M+S+R和M+R。如果Emily将第一条和第三条消息相加，然后减去第二条消息，她会得到(M+S)+(M+R)-(M+S+R)
    = M。结果正是M。当加密函数是乘法时，同样的方法也适用。3条消息分别是(M×S)、(M×R)和(M×S×R)。再次进行(M×S)×(M×R)÷(M×S×R)运算得到M。当加密函数是异或时，找到M甚至更简单，因为异或是其自身的逆运算。只需将3条加密消息进行异或运算，结果就是原始消息，(M⊕S)⊕(M⊕R)⊕(M⊕S⊕R)
    = M。
- en: Two encryption functions that commute are substitution and transposition. These
    are also insecure. Since Emily will see the message both before and after the
    transposition, she can trivially determine the transposition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可交换的两个加密函数是替换和置换。这些也是不安全的。由于Emily会看到置换前后的消息，她可以轻易确定置换。
- en: What is required, then, is a pair of encryption functions S and R that commute,
    and such that Emily cannot determine M even if she has SM, RSM and RM.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的是一对可交换的加密函数S和R，使得即使Emily拥有SM、RSM和RM，她也无法确定M。
- en: 16.1 Shamir’s method
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 Shamir的方法
- en: Shamir’s solution to this problem was to use exponentiation. Let p be a large
    prime, say in the range of 300 to 600 decimal digits. Sandra will choose an encryption
    exponent s. The corresponding decryption exponent is s' such that ss'≡1 (mod p-1).
    This follows from Fermat’s Little Theorem, if 0<a<p, then a^(p-1)≡1 (mod p). Section
    14.4.2 describes how to choose the prime p, and section 15.4 describes how to
    determine s'. In the same way, Riva chooses her encryption and decryption exponents,
    r and r'. The two encryptions commute because (M^s)^r = M^(sr) = M^(rs) = (M^r)^s.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Shamir解决这个问题的方法是使用指数。设p是一个大素数，比如在300到600位十进制数字范围内。Sandra将选择一个加密指数s。相应的解密指数是s'，使得ss'≡1
    (mod p-1)。这是根据费马小定理得出的，如果0<a<p，则a^(p-1)≡1 (mod p)。第14.4.2节描述了如何选择素数p，第15.4节描述了如何确定s'。同样，Riva选择她的加密和解密指数r和r'。这两个加密是可交换的，因为(M^s)^r
    = M^(sr) = M^(rs) = (M^r)^s。
- en: Sandra computes (M^s mod p) and sends it to Riva. Riva computes (M^(sr) mod
    p) and sends that back to Sandra. Sandra computes (M^(srs)' mod p) = (M^r mod
    p) and sends it back to Riva, who finally computes (M^(rr)' mod p) = M, which
    is the original message. The method is believed to be secure because determining
    s or r requires solving the discrete logarithm problem. As discussed in section
    14.4, this problem is known to be computationally difficult. No computationally
    feasible algorithms are known.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Sandra计算(M^s mod p)并将其发送给Riva。Riva计算(M^(sr) mod p)并将其发送回Sandra。Sandra计算(M^(srs)'
    mod p) = (M^r mod p)并将其发送回Riva，最终Riva计算(M^(rr)' mod p) = M，这就是原始消息。这种方法被认为是安全的，因为确定s或r需要解决离散对数问题。正如第14.4节所讨论的，这个问题被认为在计算上是困难的。目前没有已知的可计算的算法。
- en: This method is very slow. All these exponentiations and modulo reductions of
    large numbers take a great deal of computing. The next section describes one attempt
    at a solution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常慢。所有这些大数的指数运算和模数减少需要大量计算。下一节描述了一种解决方案的尝试。
- en: 16.2 Massey-Omura
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 Massey-Omura
- en: The *Massey-Omura* method was invented by James Massey of ETH Zurich, and Jim
    K. Omura of UCLA in 1982\. (His name is listed on the patent as Jimmy Omura. He
    was my classmate at MIT, although I do not remember him.) The Massey-Omura system
    is essentially the same as the Shamir system, except that the modulus is of the
    form 2^k. This means that the residue modulo 2^k can be computed simply by taking
    the low-order k bits of the number. This is much faster than computing the residue
    modulo p, which is done essentially by long division using these 300- to 600-digit
    numbers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Massey-Omura*方法是由ETH Zurich的James Massey和UCLA的Jim K. Omura于1982年发明的。（他的名字在专利上列为Jimmy
    Omura。他是我在MIT的同学，尽管我不记得他。）Massey-Omura系统与Shamir系统本质上相同，只是模数的形式为2^k。这意味着模2^k的余数可以通过简单地取数字的低k位来计算。这比计算模p的余数要快得多，后者基本上是通过使用这些300到600位数字进行长除法来完成的。'
- en: The question of which method is faster was hotly debated for several years in
    Association for Computing Machinery (ACM) and Institute of Electrical and Electronics
    Engineers (IEEE) publications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更快的问题在几年来一直在计算机协会（ACM）和电气电子工程师学会（IEEE）的出版物中激烈讨论。
- en: 16.3 Discrete logarithm
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 离散对数
- en: The security of Diffie-Hellman key exchange, the Shamir three pass protocol
    and the Massey-Omura method all depend on the difficulty of solving the discrete
    logarithm problem. Three popular algorithms for this problem are exhaustive enumeration,
    good up to 10^(12), Daniel Shanks’s baby-step giant-step algorithm, good up to
    10^(18), and John Pollard’s rho algorithm, good up to 10^(22). However, we need
    an algorithm suitable for 10^(300). To give some feel for how difficult the discrete
    logarithm is, let’s look at a composite method for solving it. This is not something
    you can do at home with a PC. It takes a mainframe with massive storage, or a
    network of many PCs working cooperatively. Or, you can skip this section and just
    accept that the discrete logarithm problem is hard.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie-Hellman密钥交换、Shamir三次协议和Massey-Omura方法的安全性都取决于解决离散对数问题的难度。解决这个问题的三种流行算法是穷举枚举，适用于10^(12)，Daniel
    Shanks的baby-step giant-step算法，适用于10^(18)，以及John Pollard的rho算法，适用于10^(22)。然而，我们需要一个适用于10^(300)的算法。为了让人们对离散对数问题的困难有所了解，让我们看看一个解决它的复合方法。这不是你可以在家用个人电脑完成的事情。这需要一个具有大量存储空间的大型计算机，或者一个由许多个人合作工作的网络。或者，你可以跳过这一部分，只是接受离散对数问题是困难的。
- en: 16.3.1 Logarithms
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.1 对数
- en: Start by considering how people computed ordinary logarithms back before computers.
    One method was to take a number like b = 1.000001 and laboriously take successive
    powers of it. You would find that b^(693148) was the closest power to 2, and that
    b^(2302586) was the nearest power to 10\. Then you would know that log[10](2)
    was very nearly 693148/2302586, which is .3010302\. The correct value is .3010300,
    so this method gives an excellent approximation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑在计算机出现之前人们如何计算普通对数。一种方法是取一个数字b = 1.000001，费力地计算它的连续幂。你会发现b^(693148)是最接近2的幂，而b^(2302586)是最接近10的幂。然后你会知道log[10](2)几乎是693148/2302586，即0.3010302。正确值是0.3010300，所以这种方法给出了一个很好的近似值。
- en: You can do the same thing in a ring such as integers modulo some prime p. Suppose
    Sandra sends the message 6 mod 13 and Riva returns the message 7 mod 13\. Emily
    wishes to know what exponent Riva has used for her encipherment. Instead of powers
    of 1.000001 you would use a primitive root of the modulus 13, for example 2\.
    With such a small modulus Emily can easily enumerate all the powers of 2 modulo
    13.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一个环中进行相同的操作，比如取模某个素数 p。假设桑德拉发送消息 6 模 13，里瓦返回消息 7 模 13。艾米莉想知道里瓦使用了什么指数进行加密。与其使用
    1.000001 的幂，不如使用模 13 的一个原根，比如 2。由于模数较小，艾米莉可以轻松列举出模 13 的所有 2 的幂。
- en: '![16-unnumb-1](../Images/16-unnumb-1.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![16-unnumb-1](../Images/16-unnumb-1.png)'
- en: Emily now knows that Sandra sent 2⁵ and Riva sent back 2^(11). So (2⁵)^r≡2^(5r)≡2^(11)
    (mod 13). This means 5r≡11 (mod 12). You can solve this in your head. Just think
    11+12 = 23, 23+12 = 35\. Since 35 is a multiple of 5, namely 5×7, that means r
    must be 7\. You can check it with a hand calculator, 6⁷ = 279936≡7 (mod 13). Sandra
    sent 6, Riva sent back 7, so this checks out.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在艾米莉知道桑德拉发送了 2⁵，里瓦回复了 2^(11)。所以 (2⁵)^r≡2^(5r)≡2^(11) (mod 13)。这意味着 5r≡11 (mod
    12)。您可以在脑海中解决这个问题。只需想想 11+12 = 23，23+12 = 35。由于 35 是 5 的倍数，即 5×7，这意味着 r 必须是 7。您可以用手计算器检查，6⁷
    = 279936≡7 (mod 13)。桑德拉发送了 6，里瓦回复了 7，所以这是正确的。
- en: 16.3.2 Powers of primes
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.2 素数的幂
- en: Exhaustive enumeration gives Emily one way to search, but that’s not going to
    work when p is large. Let’s try an idea from John Pollard’s *rho algorithm*. The
    first step is to generate multiple sequences of powers modulo p, and look for
    repeats. Emily can do that with several primitive roots simultaneously, one root
    per core. Now let’s double that. If b is a primitive root modulo p she can compute
    b², b³, b⁴, b⁵, ... (mod p) on one processor, and b², b⁴, b⁸, b^(16), ... (mod
    p) on another processor. That gives Emily two separate sequences of powers for
    each primitive root she uses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米莉通过穷举法可以找到一种搜索方法，但是当 p 很大时，这种方法行不通。让我们尝试约翰·波拉德的*ρ 算法*中的一个思想。第一步是生成模 p 的多个幂序列，并寻找重复项。艾米莉可以同时使用多个原根进行这样的操作，每个核心一个原根。现在我们来把它加倍。如果
    b 是模 p 的一个原根，她可以在一个处理器上计算出 b²、b³、b⁴、b⁵... (mod p)，在另一个处理器上计算出 b²、b⁴、b⁸、b^(16)...
    (mod p)。这给了艾米莉每个使用的原根两个单独的幂序列。
- en: Besides the primitive roots, Emily can also check directly. Sandra sends SM
    and Riva sends back RSM. Emily can generate the sequences (SM)², (SM)³, (SM)⁴,
    (SM)⁵, ... and (SM)², (SM)⁴, (SM)⁸, (SM)^(16), ... , and likewise for RSM. This
    gives Emily four more sequences of powers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原根，艾米莉还可以直接检查。桑德拉发送 SM，里瓦回复 RSM。艾米莉可以生成序列 (SM)²、(SM)³、(SM)⁴、(SM)⁵... 和 (SM)²、(SM)⁴、(SM)⁸、(SM)^(16)...，以及
    RSM 的类似序列。这给了艾米莉另外四个幂序列。
- en: In addition to these orderly sequences of powers, she can also generate some
    disorderly sequences. These are commonly called *random walks* or *drunk walks*.
    One way to do this is to square the last power that was generated, and then multiply
    that by one of the earlier powers. Emily can choose the early power at random,
    or she could use the middle element of the list. For example, suppose she already
    has the powers x, x², x⁴, x⁸ and x^(16). For the next power she could square x^(16)
    to get x^(32), then multiply by, say, x² to get x^(34). For the following power
    she would square x^(34) to get x^(68) and multiply that by another list element,
    say x⁸, to get x^(76). And so forth.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些有序的幂序列之外，她还可以生成一些无序的序列。这些通常被称为*随机游走*或*醉汉游走*。一种方法是对生成的最后一个幂进行平方，然后将其乘以之前的某一个幂。艾米莉可以随机选择早期的幂，或者她可以使用列表的中间元素。例如，假设她已经有了幂
    x、x²、x⁴、x⁸ 和 x^(16)。对于下一个幂，她可以对 x^(16) 进行平方得到 x^(32)，然后乘以，比如说，x² 得到 x^(34)。对于下一个幂，她会对
    x^(34) 进行平方得到 x^(68)，然后再乘以另一个列表元素，比如说 x⁸，得到 x^(76)。依此类推。
- en: Another form of random walk Emily can generate uses 2 or 3 base primes. Each
    base prime should be a primitive root. Begin with the product of these primes.
    To generate the next product, she would choose one of the primes at random and
    multiply by that. The more sequences Emily has going, the sooner she will start
    to get results.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米莉可以生成另一种随机游走，使用 2 或 3 个基本素数。每个基本素数应该是一个原根。从这些素数的乘积开始。要生成下一个乘积，她会随机选择其中一个素数并将其乘以。艾米莉拥有的序列越多，她就越快地开始得到结果。
- en: 16.3.3 Crash
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.3 崩溃
- en: Okay, now Emily has all of these sequences. Then what? She is looking for the
    same number to show up on two lists. This is called a *collision*, or *crash*.
    Say she finds 3^(172964)≡103^(4298755) (mod p). This lets her express 103 as a
    power of 3 (mod p) by solving the congruence 172964r≡4298755 (mod p-1). The method
    is described in section 15.4\. Once she accumulates enough crashes she can establish
    a chain such as RSM≡19^a, 19≡773^b, 773≡131^c, ... , 103^y≡(SM)^z. Multiply all
    of the exponents modulo p-1 and she will get RSM≡(SM)^r (mod p). That exponent
    r is Riva’s encryption function. Emily has cracked the cipher!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在艾米莉有了所有这些序列。然后呢？她在两个列表上寻找相同的数字。这被称为*碰撞*或*崩溃*。假设她发现3^(172964)≡103^(4298755)
    (mod p)。通过解决同余式172964r≡4298755 (mod p-1)，这使得她能够将103表示为3的幂（模p）。该方法在第15.4节中描述。一旦她积累了足够的崩溃，她就可以建立一个链，例如RSM≡19^a,
    19≡773^b, 773≡131^c, ... , 103^y≡(SM)^z。将所有指数模p-1相乘，她将得到RSM≡(SM)^r (mod p)。这个指数r就是瑞娃的加密函数。艾米莉破解了密码！
- en: That’s not quite as easy as it sounds. When p is a 300-digit prime, she needs
    on the order of 10^(150) of these powers before she starts seeing any crashes.
    If Emily had 1,000,000 processors cranking out these powers at a rate of 1,000,000
    per second, she could potentially generate 3×10^(19) per year. This would mean
    it would take about 10^(130) years before she started seeing any results, and
    far more than that until she could establish such a chain. Also, it would take
    some multiple of 10^(150) bytes of storage.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像听起来那么简单。当p是一个300位数素数时，她需要大约10^(150)个这样的幂才能开始看到任何崩溃。如果艾米莉有100万个处理器，每秒产生100万个这样的幂，她可能每年就可以生成3×10^(19)个。这意味着她需要大约10^(130)年才能开始看到任何结果，直到她能建立这样一个链为止。此外，它将需要10^(150)个字节的存储的倍数。
- en: 16.3.4 Factoring
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.4 因式分解
- en: Instead of searching for crashes, each time a new power is generated Emily could
    try to factor its residue modulo p. Suppose that she succeeds in factoring the
    residue of 97^a (mod p) and finds 97^a≡11^b29^c83^d (mod p). She can solve this
    congruence for 97\. Let the multiplicative inverse of a modulo p-1 be a'. Raise
    the congruence to the a' power. 97^(aa)'≡97≡(11^b29^c83^d)^a' (mod p). After multiplying
    all of the exponents and reducing them modulo p-1, the result is 97≡11^e29^f83^g
    (mod p) for some values e, f and g. (The actual values could be up to 300 digits
    each if p has 300 digits.) Once she has an expression for one of the base primes,
    in this case 97, she can substitute that value into all of the factored products,
    both the ones she already has and the ones she will find later.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不是每次生成新的幂时都要搜索崩溃，艾米莉可以尝试对其在模p下的残留进行因式分解。假设她成功地对97^a (mod p)的残余进行了因式分解，并找到了97^a≡11^b29^c83^d
    (mod p)。她可以解这个同余式得到97。设模p-1的a的乘法逆元为a'。将同余式提升至a'次幂。97^(aa)'≡97≡(11^b29^c83^d)^a'
    (mod p)。将所有指数相乘并将它们减去模p-1，结果是97≡11^e29^f83^g (mod p)，其中e、f和g是一些值。（如果p有300位数字，实际值可能长达300位数字。）一旦她得到了一个质数基的表达式，比如说97，在所有已经有和以后会找到的因式乘积中都可以替换这个值。
- en: Emily will not be able to factor the residue of every power. Factoring a 300-digit
    number is very difficult, meaning very time-consuming. The best strategy is to
    choose a fixed base set F(B) of primes, say all the primes up to B = 10⁶, or perhaps
    up to B = 10⁷. F(B) is called the *factor base*. Try to factor each power using
    only the primes in the factor base. Numbers that can be factored this way are
    called *B-smooth*. As the numbers get larger, the proportion that are B-smooth
    gets smaller and smaller. Among 300-digit numbers the B-smooth numbers are rare.
    As Emily finds each factor, the unfactored portion of the number shrinks. If she
    has tried all of the primes in the base set, and some unfactored portion of the
    number remains, she should not try to factor it any further. It is more efficient
    to discard this power and move on to the next power.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米莉将无法对每个幂的残留进行因式分解。对一个300位数进行因式分解非常困难，也就是说非常耗时。最好的策略是选择一个固定的质数基集F(B)，比如说所有小于B
    = 10⁶的质数，或者也许是所有小于B = 10⁷的质数。F(B)被称为*因子基*。尝试仅使用因子基中的质数对每个幂进行因式分解。可以用这种方式进行因式分解的数字称为*B-平滑*。随着数字变大，B-平滑数字的比例会变得越来越小。在300位数中，B-平滑数很少见。当艾米莉找到每个因子时，数字的未因式分解部分就会减少。如果她已经尝试了基础集中的所有质数，数字的一些未因式分解部分仍然存在，她就不应再尝试进一步因式分解它。放弃这个幂并继续下一个幂会更有效率。
- en: 'Here is what Emily must do: continue generating products and factoring their
    residues modulo p. Keep only the B-smooth numbers and discard the rest. Check
    for crashes among the B-smooth numbers. Each time a crash is found, solve the
    congruence for the largest prime in the product so that fewer and fewer base primes
    are needed to express each product. She may reserve one or more processors dedicated
    solely to this task.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Emily必须做的事情：继续生成产品并对它们对p取余的结果进行因式分解。仅保留B-smooth数字并丢弃其余。检查B-smooth数字中的崩溃情况。每次发现崩溃时，解决乘积中最大质数的同余式，以便需要越来越少的基本质数来表示每个乘积。她可以保留一个或多个专用于此任务的处理器。
- en: Suppose that q^n is a power of a prime, and let its residue modulo p be x. Try
    to factor x using the primes in the base set B. If x is not B-smooth, try to factor
    the numbers x+p, x+2p, x+3p, ... It is not much harder to factor a 301-digit or
    302-digit number than a 300-digit number. Set a fixed number of such trials, say
    10 trials, for each residue.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设q^n是一个质数的幂，并且其模p的剩余为x。尝试使用基本集B中的质数因式分解x。如果x不是B-smooth，则尝试因式分解数x+p，x+2p，x+3p，...。因式分解一个301位数或302位数的数并不比因式分解一个300位数的数更难。设置一个固定数量的这样的尝试，比如说，对于每个剩余设置10次尝试。
- en: When she generates these powers she needs to place special emphasis on SM and
    RSM. Remember, the goal of this exercise is to find the exponent r such that (SM)^r≡RSM
    (mod p). She can’t do that until she has expressed both SM and RSM in terms of
    powers of the base primes. To begin, she should develop numerous sequences of
    powers of SM and RSM. Once she has succeeded in finding such an expression, she
    looks for primes within the expression that have not yet been expressed in terms
    of powers of smaller primes. Place the emphasis on these primes next. Continue
    until both SM and RSM are expressed as powers of a single prime. She can now find
    r using the methods of section 15.3.2.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当她生成这些幂时，她需要特别强调SM和RSM。记住，这个练习的目标是找到指数r，使得(SM)^r≡RSM (mod p)。她在将SM和RSM都表示为基本质数的幂之前是无法做到的。首先，她应该开发出多个SM和RSM幂的序列。一旦她成功找到这样的表达式，她就会寻找表达式中尚未用较小质数的幂表示的质数。接下来重点放在这些质数上。继续直到SM和RSM都表示为单一质数的幂。她现在可以使用第15.3.2节的方法找到r。
- en: 16.3.5 Estimates
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.5 估算
- en: Suppose that she uses 10⁶ base primes, that is, primes up to B = 15,485,863\.
    To express all of these in terms of a single prime will require 10⁶ congruences.
    Storing these requires a 10⁶×10⁶ matrix of exponents. The matrix is initially
    sparse, but it grows dense as the solution progresses, so sparse-matrix techniques
    will not be beneficial. Each exponent is a 300-digit number. This requires on
    the order of 10^(15) bytes, or one *petabyte*, of storage. As of this writing
    (March 2022), the largest supercomputer in the world is the Summit computer at
    the Oak Ridge National Laboratory, which has 2.76 petabytes of addressable storage.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设她使用了10^6个基本质数，也就是说，质数达到了B = 15,485,863。要将所有这些表示为单一质数将需要10^6个同余式。存储这些需要一个10^6×10^6的指数矩阵。矩阵最初是稀疏的，但随着解决方案的进展而变得稠密，因此稀疏矩阵技术将不会有益。每个指数是一个300位数。这需要大约10^(15)字节，或1个*petabyte*的存储空间。截至撰写本文时（2022年3月），世界上最大的超级计算机是位于奥克里奇国家实验室的Summit计算机，拥有2.76
    petabytes的可寻址存储空间。
- en: The running time obviously depends on how long it takes to find B-smooth numbers.
    The density of B-smooth numbers is given by the de Bruijn function Ψ(p,B), which
    gives the number of B-smooth integers less than p. It was studied by Dutch mathematician
    Nicolaas Govert de Bruijn. The value of Ψ(x,x^(1/u)) is closely approximated by
    xρ(u), where ρ(u) is the Dickman function invented by actuary Karl Dickman. The
    Dickman function ρ(u) is approximated by u^(-u). In this case x = 10^(300) and
    x^(1/u) = 15,485,863, so u = 41.725\. Thus it will take about 41.725^(41.725)
    = 4.08×10^(67) tries to find each B-smooth number.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，运行时间取决于找到B-smooth数字需要多长时间。B-smooth数字的密度由de Bruijn函数Ψ(p,B)给出，它给出了小于p的B-smooth整数的数量。这由荷兰数学家尼古拉斯·戈弗特·德布鲁因研究过。Ψ(x,x^(1/u))的值由精算师卡尔·迪克曼发明的迪克曼函数ρ(u)近似，其中ρ(u)是迪克曼函数。迪克曼函数ρ(u)由u^(-u)近似。在这种情况下，x
    = 10^(300)和x^(1/u) = 15,485,863，所以u = 41.725。因此，大约需要大约41.725^(41.725) = 4.08×10^(67)次尝试才能找到每个B-smooth数字。
- en: Altogether it will take more than 10^(73) trials to find 10⁶ B-smooth powers.
    Factoring each number may take up to 10⁶ trial divisions, so there are 10^(79)
    total trial divisions. Since the numbers are 300 digits, each trial division will
    take some multiple of 300 operations. Call it 10^(82) operations altogether. This
    is a huge improvement over 10^(150) for the crash method, but still well out of
    reach for current computers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，将需要超过 10^(73) 次尝试来找到 10^6 个 B-平滑幂。对每个数字进行因数分解可能需要多达 10^6 次试除，因此总共需要 10^(79)
    次试除。由于数字有 300 位，每次试除将需要 300 倍的操作。总共是 10^(82) 次操作。这比崩溃法的 10^(150) 有了巨大的改进，但对于当前的计算机仍然是不可及的。
- en: This shows that 300 digits are more than sufficient for the foreseeable future,
    perhaps for the next 20 to 30 years. This may change as quantum computers develop,
    but for now 300 digits is safe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明对于可预见的未来，300 位数字已经足够了，也许可以维持 20 到 30 年。随着量子计算机的发展，这可能会改变，但目前 300 位数字是安全的。
- en: 16.4 Matrix three pass protocol
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 矩阵三次传输协议
- en: The Shamir and Massey-Omura methods for the three pass algorithm both use exponentiation.
    A different approach to the three pass algorithm is to use matrices. We have seen
    this before with the Hill cipher, section 15.1\. The message is divided into blocks.
    Each block is treated as a vector of integers modulo 256\. This vector is multiplied
    by an invertible square matrix of integers modulo 256, either on the left or on
    the right. For the three pass version, Sandra will have a matrix S for encryption
    and its inverse S' for decryption, while Riva will have encryption matrix R and
    decryption matrix R'. These matrices are not over the integers modulo 256, but
    over a ring ***R*** of 256 elements, and the characters of the message are treated
    as elements of this ring. Let the message block be M, so Sandra sends SM to Riva,
    Riva sends RSM back to Sandra, and Sandra deciphers it with S' to get S'RSM =
    RM. Now Riva can decrypt it with R', namely R'RM = M.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用于三次传递算法的 Shamir 和 Massey-Omura 方法都使用了指数运算。三次传递算法的另一种方法是使用矩阵。我们之前已经见过这种情况，比如
    Hill 密码，第 15.1 节。消息被分成块。每个块被视为模 256 的整数向量。这个向量被一个模 256 的可逆方阵左乘或右乘。对于三次传递版本，Sandra
    将有一个用于加密的矩阵 S 和其逆矩阵 S'，而 Riva 将有一个加密矩阵 R 和解密矩阵 R'。这些矩阵不是在模 256 整数上，而是在一个 256 个元素的环***R***上，消息的字符被视为该环的元素。假设消息块为
    M，所以 Sandra 发送 SM 给 Riva，Riva 将 RSM 返回给 Sandra，Sandra 使用 S' 解密以获得 S'RSM = RM。现在
    Riva 可以使用 R' 解密它，即 R'RM = M。
- en: The tricky part is making S'RSM = RM. Matrix multiplication is not commutative,
    so Sandra and Riva need to choose special matrices S and R that commute with each
    other. To be clear, S and R are not commutative matrices. If you choose a matrix
    X at random, it is nearly certain that SX ≠ XS and RX ≠ XR. This is an essential
    point, so let me repeat it, S and R are not commutative matrices. They do not
    commute with most other matrices. They commute with each other.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 棘手的部分是使 S'RSM = RM。矩阵乘法不可交换，所以 Sandra 和 Riva 需要选择彼此可交换的特殊矩阵 S 和 R。明确地说，S 和 R
    不是可交换矩阵。如果你随机选择一个矩阵 X，几乎可以肯定 SX ≠ XS 和 RX ≠ XR。这是一个重要的观点，所以让我重复一遍，S 和 R 不是可交换矩阵。它们不与大多数其他矩阵可交换。它们彼此可交换。
- en: 16.4.1 Commutative family of matrices
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.1 可交换矩阵族
- en: Sandra and Riva will need a large supply of these matrices so that Emily cannot
    simply try them all. This means that they need a large commutative family **Ғ**
    of matrices from which to select the matrix for each block of the message.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Sandra 和 Riva 需要大量的这些矩阵，这样 Emily 就不能简单地尝试它们所有。这意味着他们需要一个大的可交换矩阵族**Ғ**，从中选择每个消息块的矩阵。
- en: Note **Ғ** is a commutative family of matrices, not a family of commutative
    matrices. It is essential to understand that it is the family that is commutative,
    and not the matrices themselves. Nearly all matrices in **Ғ** will *not* be commutative.
    They will commute with one another, but not with other matrices.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**Ғ**是一个可交换的矩阵族，而不是一组可交换的矩阵。重要的是要理解，可交换的是矩阵族，而不是矩阵本身。**Ғ**中几乎所有的矩阵都*不*可交换。它们彼此可交换，但与其他矩阵不可交换。
- en: The easiest way to construct a commutative family is to begin with any invertible
    matrix, F, and take its powers, F⁰, F¹, F², F³, ... , where F⁰ is the identity
    matrix I, and F¹ = F. Call F the *generating matrix* for the family **Ғ**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 构造可交换矩阵族的最简单方法是从任意可逆矩阵 F 开始，并取其幂，F⁰、F¹、F²、F³、...，其中 F⁰ 是单位矩阵 I，而 F¹ = F。将 F
    称为**Ғ**族的*生成矩阵*。
- en: Sandra and Riva will each need to use a different matrix for each block of the
    message, otherwise Emily might solve the set of linear equations R(SM[i]) = RSM[i]
    given a sufficient set of message blocks M[i] with known plaintext.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Sandra 和 Riva 每个消息块都需要使用不同的矩阵，否则 Emily 可能会在已知明文的足够消息块 M[i] 的情况下解出线性方程组 R(SM[i])
    = RSM[i]。
- en: 16.4.2 Multiplicative order
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.2 乘法阶
- en: To make the family **Ғ** large, you need to find or to construct a generating
    matrix F of high multiplicative order. That is, the smallest integer n > 0 such
    that F^n = I needs to be large, at least 10^(25), but preferably larger. If the
    matrix F is invertible, such an n will always exist, and the multiplicative inverse
    F' of F is F^(n-1). A method for finding invertible matrices was given in section
    15.8\. Determining the multiplicative order of F is a bit of an art. It is clearly
    not feasible to take successive powers F until F^n = I, certainly not when n >
    10^(25). But it can be done.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要使**Ғ**族变得更大，你需要找到或构造一个具有很高乘法阶的生成矩阵 F。也就是说，需要找到一个最小的整数 n > 0，使得 F^n = I，至少要大于
    10^（25），但最好更大。如果矩阵 F 是可逆的，这样的 n 总是存在的，并且 F 的乘法逆 F' 是 F^(n-1)。在第 15.8 节中给出了一种寻找可逆矩阵的方法。确定
    F 的乘法阶有点艺术性。显然，一直计算 F 的连续幂直到 F^n = I 是不可行的，特别是当 n > 10^（25）时。但这是可以做到的。
- en: To find the multiplicative order, begin with 1×1 matrices, namely the ring elements.
    Look at the multiplicative order of these elements. These can easily be found
    by enumeration, since the highest possible value for n is 255\. Likely values
    are 2, 3, 7, 15, 31, 63, 127 and 255\. The multiplicative orders for larger matrices
    will tend to be multiples of these values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到乘法阶，从 1×1 矩阵开始，即环元素。查看这些元素的乘法阶。这些可以通过枚举轻松找到，因为 n 的最大可能值是 255。可能的值是 2、3、7、15、31、63、127
    和 255。更大矩阵的乘法阶往往是这些值的倍数。
- en: Suppose that the multiplicative orders of the ring elements happen to be 2,
    7 and 31\. When you try 2×2 matrices, first raise each matrix A to some multiple
    of the single-element orders, say 2⁴7²31 = 24304\. Then enumerate the powers of
    B = A^(24304). Suppose you find that B^(52) = I. You now know for certain that
    the multiplicative order m of A evenly divides x = 24304×52 = 2⁶7²13×31, and that
    it is a multiple of 2⁶13\. You should next try A^(x/7) and A^(x/31) to see if
    those are I. If A^(x/7) is I, you then try A^(x/49). In this case the highest
    multiplicative order might be 2⁶7×13×31.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设环元素的乘法阶恰好是 2、7 和 31。当你尝试 2×2 矩阵时，首先将每个矩阵 A 提升到单元素阶的某个倍数，比如 2⁴7²31 = 24304。然后枚举
    B = A^(24304) 的幂。假设你发现 B^(52) = I。你现在可以确定 A 的乘法阶 m 能够整除 x = 24304×52 = 2⁶7²13×31，且是
    2⁶13 的倍数。接下来应该尝试 A^(x/7) 和 A^(x/31) 看看它们是否为 I。如果 A^(x/7) 是 I，那么你就尝试 A^(x/49)。在这种情况下，最高的乘法阶可能是
    2⁶7×13×31。
- en: You next tackle the 3×3 matrices. If no other prime factors besides 2, 3, 7,
    13 and 31 appeared in the multiplicative orders of the 2×2 matrices, then a good
    starting exponent might be x = 2⁸7²13²31². Enumerate successive powers of B =
    A^x and repeat the process of narrowing down the exponent. As the matrices get
    larger, the multiplicative order may increase by a factor too large to find by
    enumeration. In this case you will need to guess at the new prime factors that
    will appear.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你要处理 3×3 矩阵。如果除了 2、3、7、13 和 31 之外，2×2 矩阵的乘法阶中没有其他质因数出现，那么一个好的起始指数可能是 x =
    2⁸7²13²31²。枚举 B = A^x 的连续幂，并重复缩小指数的过程。随着矩阵变大，乘法阶可能会增加一个无法通过枚举找到的因子。在这种情况下，你将需要猜测新的可能出现的质因数。
- en: Watch for patterns that appear in the sequence of multiplicative orders. This
    requires some detective work. For example, suppose 2³-1, 2⁶-1, 2⁹-1 and 2^(12)-1
    appear. You won’t see these directly, because they are not all prime. 2⁶-1 = 63
    = 3²7, 2⁹-1 = 511 = 7×73 and 2^(12)-1 = 4095 = 3²5×7×13\. So finding a 13 among
    the prime factors is a clue that the “real” factor may be 2^(12)-1, and finding
    a 73 is a strong indicator that 2⁹-1 is a factor. If you see 2³-1, 2⁶-1, 2⁹-1
    and 2^(12)-1 all appear, you should expect 2^(15)-1 to appear soon. If all of
    these appear, they are each divisible by 7, so the multiplicative order will be
    divisible by 7⁴.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意乘法阶序列中出现的模式。这需要一些侦探工作。例如，假设出现了 2³-1、2⁶-1、2⁹-1 和 2^(12)-1。你不会直接看到这些，因为它们不全是质数。2⁶-1
    = 63 = 3²7，2⁹-1 = 511 = 7×73 和 2^(12)-1 = 4095 = 3²5×7×13。所以在质因数中找到 13 是指向“真正”因数可能是
    2^(12)-1 的线索，而找到 73 则强烈表明 2⁹-1 是一个因数。如果出现了 2³-1、2⁶-1、2⁹-1 和 2^(12)-1，你应该期待很快出现
    2^(15)-1。如果这些全部出现，它们都可以被 7 整除，所以乘法阶将被 7⁴ 整除。
- en: 16.4.3 Maximum order
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.3 最大阶
- en: Sandra’s objective in all of this is to make the family **Ғ** as large as possible
    so that she and Riva have lots of choices for their matrices S and R. A useful
    trick is to watch the multiplicative orders for differences in the sets of factors.
    For example, if the multiplicative order of A is 19m and the multiplicative order
    of B is 23m, then the multiplicative order of AB just might be 19×23m = 437m.
    If that doesn’t work, then A'B or AB' may have multiplicative order 437m.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米莉在这一切中的目标是尽可能地扩大家族**Ғ**，这样她和里娃就有很多选择来选择他们的矩阵S和R。一个有用的技巧是观察因子集合之间的乘法阶数差异。例如，如果A的乘法阶数为19m，B的乘法阶数为23m，那么AB的乘法阶数很可能是19×23m=437m。如果这不起作用，那么A'B或AB'可能具有乘法阶数437m。
- en: If at all possible, Sandra should choose a generating matrix F whose multiplicative
    order has a large prime factor, say m > 10^(35), in order to prevent a Silver-Pohlig-Hellman
    attack (section 14.4). Sandra will need to factor 2^n-1 for various n to find
    the ones that have large prime factors, and then find a generating matrix whose
    multiplicative order is divisible by one of those 2^n-1 by trying successively
    larger matrices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，桑德拉应该选择一个生成矩阵F，其乘法阶数具有一个大素数因子，比如$m > 10^{35}$，以防止Silver-Pohlig-Hellman攻击（第14.4节）。桑德拉需要对各种$n$进行因式分解$2^n-1$，找到具有大素数因子的那些，并尝试用逐渐增大的矩阵找到一个乘法阶数可被其中一个$2^n-1$整除的生成矩阵。
- en: 16.4.4 Emily attacks
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.4 艾米莉的攻击
- en: Suppose that Sandra has chosen F and **Ғ**, and that she has sent a message
    to Riva. Since Sandra and Riva are communicating over a public channel, such as
    the internet, assume that Emily knows F, **Ғ**, SM, RSM and RM. Her goal is to
    find either R or S, so she gets two chances. Let’s concentrate on how Emily might
    find R. Emily knows two things about R. First, she knows the values of SM and
    RSM, so that gives her a set of n linear equations in the n² unknown elements
    of R. Second, she knows that R is in the family **Ғ**, so it must commute with
    F, namely RF = FR. If the ring ***R*** is commutative, then this gives her n(n-1)
    additional linear equations in the n² elements of R.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设桑德拉已经选择了F和**Ғ**，并且她已经向里娃发送了一条消息。由于桑德拉和里娃正在通过公共信道进行通信，比如互联网，假设艾米莉知道F、**Ғ**、SM、RSM和RM。她的目标是找到R或S，所以她有两次机会。让我们集中讨论艾米莉如何找到R。艾米莉知道关于R的两件事。首先，她知道SM和RSM的值，这给了她n个线性方程，这些方程是关于R的$n^2$个未知元素的。其次，她知道R在家族**Ғ**中，所以它必须与F交换，即RF
    = FR。如果环***R***是可交换的，那么这给了她n(n-1)个关于R的$n^2$个元素的附加线性方程。
- en: This works because the left side of the matrix equation RF = FR produces sums
    of terms of the form rf, where r is an unknown element of R and f is a known element
    of F. The right side produces terms of the form fr. Since the ring is commutative,
    the left-side terms rf can be converted to the form fr and combined with the right-side
    terms to form linear equations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效的原因是矩阵方程RF = FR的左侧产生了形式为$r f$的项，其中$r$是R的未知元素，$f$是F的已知元素。右侧产生了形式为$f r$的项。由于环是可交换的，左侧项$r
    f$可以转换为形式$f r$，并与右侧项组合形成线性方程。
- en: With n² linear equations in n² unknowns it would seem like child’s play to solve
    those linear equations and find R. It’s not that easy. Recall from section 15.3.1
    that there are strong congruences and weak congruences. The same is true for linear
    equations over any finite ring whose size is not a prime. The more prime factors
    the ring size has, the more potential for weak equations. In the present case,
    the ring size is 2⁸, with 8 prime factors, so many of the linear equations are
    likely to be weak. A typical size for the matrices might be 30×30 if the ring
    ***R*** were well-chosen, or 128×128, or even 256×256 with a poor choice of ring.
    Even with a well-chosen ring, and even if half of the equations are strong, you
    would expect to have at least 2^(450) solutions to the set of 30×30 = 900 equations.
    In practice the number of solutions is much greater because there can be equations
    with 4, 8 or possibly 16 solutions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在$n^2$个未知数的$n^2$个线性方程中解决这些线性方程并找到$R$似乎很容易。但事实并非如此。回顾第15.3.1节，我们知道有强同余和弱同余。对于任何不是素数的有限环上的线性方程，情况也是如此。环大小有多少素因子，就有多少潜在的弱方程。在当前情况下，环大小为$2^8$，有8个素因子，所以许多线性方程很可能是弱方程。如果环***R***选择得当，矩阵的典型大小可能是30×30，或者128×128，甚至256×256，如果环的选择不佳。即使选择了合适的环，即使一半的方程是强的，你也会期望至少有$2^{450}$个解集合的30×30=900个方程。实际上，解的数量要多得多，因为可能有4、8或甚至16个解的方程。
- en: There is good news for Emily. Emily can solve for R' instead of R, and whichever
    one of those 2^(450) or more solutions she gets will be a valid inverse of R,
    letting her obtain the message by R'RM = M.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Emily 有个好消息。Emily 可以解决 R' 而不是 R，而她得到的那 2^(450) 或更多的解中的任何一个都将是 R 的有效逆，让她通过 R'RM
    = M 获得消息。
- en: 16.4.5 Non-commutative ring
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.5 非交换环
- en: It looks like Sandra and Riva are sunk. Emily has won this battle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Sandra 和 Riva 看起来是失败的。Emily 赢得了这场战斗。
- en: One possible answer to this attack would be for Sandra and Riva to use a non-commutative
    ring. Two examples of non-commutative rings are matrices and quaternions (section
    15.7.2). You can form matrices whose elements are themselves matrices or quaternions,
    or, conversely, quaternions whose coefficients are matrices or quaternions. None
    of these are good choices. You would need to make them very large to produce matrices
    of high multiplicative order.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种攻击的一个可能方法是让 Sandra 和 Riva 使用一个非交换环。非交换环的两个例子是矩阵和四元数（第 15.7.2 节）。你可以形成元素本身是矩阵或四元数的矩阵，或者反过来，系数是矩阵或四元数的四元数。但这些都不是好选择。你需要让它们变得非常大才能产生高乘法阶的矩阵。
- en: A better route is to construct your own ring ***N*** using the techniques of
    section 15.7\. You should choose a ring that has many elements that (1) are invertible,
    (2) have high multiplicative order, and (3) are non-commutative. It is a tricky
    balancing act to find a ring that has all of these features. For example, a ring
    that has elements of maximal multiplicative order (255 for a 256-element ring)
    could not have any non-commutative elements. If you could find a ring where half
    of the elements are invertible, half have multiplicative order equal to about
    half the ring size, and half are non-commutative, *dayenu* (it would be sufficient).
    You cannot achieve all 3 of these goals simultaneously, but you may exceed some
    while coming close on the others.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用第 15.7 节的技术构造你自己的环***N***。你应该选择一个具有许多具备以下特征的元素的环：(1) 可逆，(2) 具有高乘法阶，以及
    (3) 非交换。要找到一个同时具有所有这些特征的环是一个棘手的平衡行为。例如，一个具有最大乘法阶元素（256 元素环的 255）的环不能有任何非交换元素。如果你能找到一个环，其中一半元素是可逆的，一半具有乘法阶约为环大小一半的元素，一半是非交换的，*dayenu*（这就足够了）。你不能同时达到这
    3 个目标，但你可以在某些目标上超过其他目标，同时接近其他目标。
- en: With a non-commutative ring, the matrix equation RF = FR can no longer be linearized,
    because it is no longer certain that rf = fr. Instead, the matrix equation leads
    to a set of *bilinear* equations. The general term in a bilinear equation takes
    the form axb, where a and b are elements of the ring, and x is a variable whose
    value you wish to determine. While linear equations can be solved using a simple
    systematic approach, namely Gaussian elimination, there is no such method for
    bilinear equations. There is not even a general method for solving such a simple
    equation as ax+xb = c with a single variable, x. So solving bilinear equations
    over a ring is “impossible.”
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非交换环，矩阵方程 RF = FR 不再能线性化，因为不再确定 rf = fr。相反，矩阵方程导致一组*bilinear*方程。双线性方程中的一般项的形式为axb，其中
    a 和 b 是环的元素，x 是您希望确定的变量。虽然线性方程可以使用简单的系统方法解决，即高斯消元法，但对于双线性方程却没有这样的方法。甚至对于一个变量 x
    的简单方程 ax+xb = c 也没有一个一般的解法。因此，在环上解双线性方程是“不可能的”。
- en: 16.4.6 Solving bilinear equations
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.6 解双线性方程
- en: That said, I will now show you how to solve bilinear equations. The trick is
    to change the representation of the elements in the ring ***N***. We have already
    seen several examples of how this can be done. In the ring ***R13***, elements
    are represented as *a* + *b*√13. Gaussian integers are represented as a+bi. Quaternions
    are represented as a+bi+cj+dk. Here, i, j and k are abstract units whose products
    determine the behavior of the ring, and a, b, c and d are commutative elements
    of the ring. Quaternions can be non-commutative because the multiplication of
    the units is not commutative, that is, ij ≠ ji, ik ≠ ki and jk ≠ kj. With only
    one unit, Gaussian integers are necessarily commutative.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我现在将向你展示如何解决双线性方程。诀窍在于改变环***N***中元素的表示。我们已经看到了几个这样做的示例。在环***R13***中，元素表示为*a*
    + *b*√13。高斯整数表示为a+bi。四元数表示为a+bi+cj+dk。这里，i、j 和 k 是决定环行为的抽象单位的乘积，而a、b、c 和 d 是环的可交换元素。四元数可以是非交换的，因为单位的乘法不是交换的，即，ij
    ≠ ji，ik ≠ ki，jk ≠ kj。只有一个单位时，高斯整数必然是可交换的。
- en: The trick is to *linearize* the bilinear equations by finding a representation
    for the non-commutative ring ***N***. This is easily done. Start by dividing the
    elements of ***N*** into two sets, A and B, where A contains the elements that
    have representations, and B contains the remaining elements. Initially A is empty
    and B contains all the elements of the ring. Begin by taking the commutative elements
    and moving them into set A. These ring elements will represent themselves. They
    are the “a” term in the representation. Choose any remaining invertible element
    as the unit i. Take all of the ring elements that can be represented as a+bi,
    where a and b are commutative elements of the ring, and move them from set B into
    set A. So far, all of the elements of A are still commutative.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性化*双线性方程的技巧是通过找到非交换环 ***N*** 的表示来完成的。这很容易做到。首先将 ***N*** 的元素划分为两组，A 和 B，其中
    A 包含具有表示的元素，而 B 包含其余的元素。最初，A 是空的，B 包含环的所有元素。从取可交换的元素并将它们移到集合 A 开始。这些环元素将表示它们自己。它们是表示中的“a”项。选择任意剩余可逆元素作为单位
    i。取所有可以表示为a+bi的环元素，其中a和b是环的可交换元素，并将它们从集合 B 移动到集合 A。到目前为止，A 的所有元素仍然是可交换的。'
- en: Set B cannot be empty because ***N*** is not commutative. We already noted that
    a ring with only one unit, like the Gaussian integers, must be commutative. So
    take a second invertible element from set B and call that the second unit, j.
    This time you take all elements that can be represented as a+bi+cj and move them
    from set B to set A. There may still be ring elements remaining in set B. In that
    case you would repeat these steps, but for simplicity let’s suppose that (1) only
    two units are needed; (2) all of the elements in the ring can be represented as
    a+bi+cj, where i and j are the abstract units; and (3) a, b and c are commutative
    elements of the ring ***N***. In practice, the number of units you get may depend
    on your choice of i and j, so you should make multiple trials to get the fewest
    units. This is important because more units means you will have more equations
    when you linearize. Since the time needed to solve a set of linear equations is
    proportional to the cube of the number of equations, this has a large impact.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 B 不能为空，因为 ***N*** 不是交换的。我们已经注意到只有一个单位的环，如高斯整数，必须是可交换的。因此，从集合 B 中取出第二个可逆元素，并称其为第二个单位
    j。这次，您将所有可以表示为a+bi+cj的元素从集合 B 移动到集合 A。可能仍然存在于集合 B 中的环元素。在这种情况下，您将重复这些步骤，但为简单起见，假设（1）只需要两个单位；（2）环中的所有元素都可以表示为a+bi+cj，其中i和j是抽象单位；和（3）a、b和c是环
    ***N*** 的可交换元素。在实践中，您获得的单位数量可能取决于您选择的i和j，因此您应该进行多次尝试以获得最少的单位。这很重要，因为更多的单位意味着在线性化时会有更多的方程。由于解一组线性方程所需的时间与方程数量的立方成正比，这对计算有很大影响。
- en: Let’s go back to the matrix equation RF = FR, and put the ring elements into
    the form a+bi+cj. The unknown elements of ***R*** would have the form x+yi+zj,
    where x, y and z are unknown commutative ring elements. Now a term of the matrix
    product RF would have the form
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回到矩阵方程RF = FR，并将环元素表示为a+bi+cj的形式。 ***R*** 的未知元素将具有x+yi+zj的形式，其中x、y和z是未知的可交换环元素。
    现在矩阵乘积RF的一个项将具有以下形式：
- en: '![16-unnumb-1-equation-16-2](../Images/16-unnumb-1-equation-16-2.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![16-unnumb-1-equation-16-2](../Images/16-unnumb-1-equation-16-2.png)'
- en: where i², j², ij and ji would be further expanded as linear combinations of
    1, i and j, such as d+ei+fj. The actual expansions, of course, would depend on
    the choice of ring and which elements were chosen as i and j.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其中i²、j²、ij和ji将进一步扩展为1、i和j的线性组合，如d+ei+fj。当然，实际的展开取决于环的选择以及哪些元素被选择为i和j。
- en: The same must be done with the terms in the matrix product FR. In the end, instead
    of 900 equations in 900 unknowns you get 2700 equations in 2700 unknowns. This
    boosts the number of false solutions from 2^(450) up to 2^(1350). This is bad
    news for Emily. False solutions do not allow her to recover the message.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘积 FR 中的项也必须进行相同的处理。最终，您将得到2700个未知数的2700个方程，而不是900个未知数的900个方程。这将将错误解的数量从2^(450)增加到2^(1350)。这对
    Emily 来说是个坏消息。错误的解决方案不允许她恢复消息。
- en: 16.4.7 Weaklings
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.7 弱点
- en: The family **Ғ** will include some weaklings, such as diagonal matrices and
    triangular matrices, which Emily can easily invert. These weaklings should not
    be used as keys. When choosing a matrix from **Ғ**, verify that there is at least
    one nonzero element both above and below the main diagonal. To make this test
    fast, just verify that at least one of X[12], X[13] and X[23] is nonzero, and
    at least one of X[21], X[31] and X[32] is nonzero. Otherwise reject X and choose
    again. The percentage of matrices that get rejected is negligible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ғ**家族将包括一些弱点，如对角矩阵和三角矩阵，艾米莉可以轻松求逆。这些弱点不应作为密钥使用。在从**Ғ**中选择矩阵时，请验证主对角线上下至少有一个非零元素。为了快速进行这个测试，只需验证X[12]、X[13]和X[23]中至少有一个非零，以及X[21]、X[31]和X[32]中至少有一个非零。否则拒绝X并重新选择。被拒绝的矩阵的百分比是可以忽略不计的。'
- en: 16.4.8 Making it fast
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.8 加速方法
- en: The advantage of using matrices instead of exponentiation may not be clear yet.
    Choosing a matrix S or R from the family **Ғ** requires taking a large power of
    the generating matrix F. How is that any better or faster than taking a large
    integer to a large power? The difference is preparation. In the Shamir and Massey-Omura
    methods, Sandra and Riva must take the number each has received from the other
    party and raise that to a large power. Since they do not know that number in advance,
    they cannot make any preparations to speed up the exponentiation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵而不是指数的优势可能还不太明显。从**Ғ**家族中选择矩阵S或R需要对生成矩阵F进行大幂次运算。这与将大整数求大幂次有何区别或更快？区别在于准备工作。在Shamir和Massey-Omura方法中，桑德拉和瑞娃必须对对方收到的数字进行大幂次运算。由于他们事先不知道这个数字，所以他们无法做任何准备来加快指数运算。
- en: With the matrix method, however, the generating matrix F is known beforehand.
    Both Sandra and Riva can generate some powers of F in advance, then keep this
    base set of matrix powers on hand so that they can generate a new power of F by
    just 1 or 2 matrix multiplications. For starters, they could generate the set
    of 16 matrices F, F², F⁴, F⁸, ... , F^(32768) using just 15 matrix multiplications.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用矩阵方法，生成矩阵F事先是已知的。桑德拉和瑞娃都可以提前生成一些F的幂次，然后保留这个基础矩阵幂集，这样他们就可以通过仅进行1或2次矩阵乘法来生成新的F的幂次。首先，他们可以仅使用15次矩阵乘法生成16个矩阵F，F²，F⁴，F⁸，...，F^(32768)的集合。
- en: If they did only that much, then Emily could do the same. She would have the
    same base set of matrices as Sandra and Riva, so she could easily determine their
    encryption matrices, S and R. To prevent this, Sandra and Riva need to randomize
    their sets of matrices. They do this by choosing two of their matrices at random
    and multiplying them. This product will replace one of those two matrices in the
    base set. Sandra and Riva do this independently. Neither one knows which powers
    of F the other one has chosen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们只是做到了这一点，那么艾米莉也可以做到同样的事情。她会拥有与桑德拉和瑞娃相同的基础矩阵集，因此她可以轻松确定它们的加密矩阵S和R。为了防止这种情况发生，桑德拉和瑞娃需要随机化他们的矩阵集。他们通过随机选择两个矩阵并将它们相乘来实现这一点。这个乘积将替换基础集中的其中一个矩阵。桑德拉和瑞娃独立地执行这个操作。彼此都不知道对方选择了哪些F的幂次。
- en: This replacement operation should be repeated many times during setup, say 1000
    times, so that each party’s set of matrices is thoroughly random. If 1000 seems
    excessive, remember that in the Shamir method using a 300-digit prime, each exponentiation
    will require about 1000 multiplications and 1000 modulo reductions. Sandra and
    Riva also need to keep the inverses of their matrices. Each time they multiply
    two of the powers of F they need to multiply the corresponding powers of F' so
    that they never need to invert any of the powers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置过程中，应该重复执行这个替换操作很多次，比如1000次，这样每个参与方的矩阵集就会彻底随机化。如果1000次看起来过多，记住，在Shamir方法中使用一个300位的素数，每次指数运算将需要约1000次乘法和1000次模重。桑德拉和瑞娃还需要保留他们矩阵的逆。每次他们将两个F的幂次相乘时，他们需要相应地将F'的幂次相乘，这样他们就永远不需要求逆任何幂次。
- en: This setup step, generating the base set, needs to be done only once, before
    the first message is sent. When you have this expanded set of generating matrices
    you can produce a matrix for sending a message using just one multiplication for
    the matrix, and one for its inverse. You randomly choose two different matrices
    F^a and F^b from your base set, multiply to get F^(a+b), then replace F^a by F^(a+b)
    so you generate different matrices each time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置步骤，在发送第一条消息之前，只需执行一次。当您拥有这个扩展的生成矩阵集时，您可以通过仅进行一次矩阵乘法和一次其逆矩阵的乘法来生成用于发送消息的矩阵。您随机选择来自基本集的两个不同的矩阵F^a和F^b，相乘得到F^(a+b)，然后将F^a替换为F^(a+b)，以便每次生成不同的矩阵。
- en: Using this technique, I have found that the matrix method is about 2100 times
    as fast as either the Shamir or Massey-Omura exponentiation method for a 30×30
    matrix versus a 1024-bit modulus.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我发现矩阵方法对于30×30矩阵与1024位模数相比，约快2100倍，而不论是Shamir还是Massey-Omura指数方法。
- en: 16.5 Two-sided three pass protocol
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 双侧三步协议
- en: The matrix multiplication in the previous matrix method may be done on either
    the left side or the right side, meaning the message may be enciphered as SM or
    MS. It is also possible to multiply on both sides. In this case the message is
    split into blocks of n² characters, and there are two independent commutative
    families of n×n matrices, **Ғ** and **Ɠ**, with generating matrices F and G. Sandra
    will encipher the message with matrices S from **Ғ** and T from **Ɠ**, and Riva
    will superencipher with matrices R from **Ғ** and Q from **Ɠ**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前述矩阵方法中的矩阵乘法可以在左侧或右侧执行，这意味着消息可以被加密为SM或MS。也可以在两侧同时进行乘法。在这种情况下，消息被分成n²个字符的块，并且有两个独立的n×n矩阵的可交换的族，**Ғ**
    和 **Ɠ**，其生成矩阵为 F 和 G。桑德拉将用来自 **Ғ** 的矩阵 S 和来自 **Ɠ** 的矩阵 T 加密消息，而丽娃将用来自 **Ғ** 的矩阵
    R 和来自 **Ɠ** 的矩阵 Q 进行超加密。
- en: Sandra sends Riva the enciphered message SMT. Riva superenciphers this and sends
    back RSMTQ. Sandra removes her encipherment by using the inverse matrices S' and
    T', sending S'RSMTQT' = RMQ back to Riva, who deciphers it using her inverse matrices
    R' and Q', as R'RMQQ' = M. The 2-sided method is not practical for short messages
    due to its large block size, but for long messages it is much faster than the
    1-sided methods because you get n² characters in each block instead of n characters.
    For 30×30 matrices it can be 15 times as fast as the 1-sided method, hence about
    30,000 times as fast as the Shamir or Massey-Omura method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 桑德拉向丽娃发送加密的消息SMT。丽娃进行超加密并发送回RSMTQ。桑德拉通过使用逆矩阵S'和T'去除她的加密，发送S'RSMTQT' = RMQ回给丽娃，丽娃使用她的逆矩阵R'和Q'来解密，如R'RMQQ'
    = M。对于短消息来说，双侧方法不实用，因为其块大小较大，但对于长消息来说，它比单侧方法快得多，因为每个块中有n²个字符而不是n个字符。对于30×30矩阵，它可以比单侧方法快15倍，因此约比Shamir或Massey-Omura方法快约30,000倍。
- en: Emily must solve for two matrices simultaneously. Let the 3 matrices that Emily
    intercepts be called X, Y and Z, that is, X = SMT, Y = RSMTQ and Z = RMQ. Emily
    knows that Y = RXQ and Z = S'YT'. It looks like Emily will need to solve a large
    set of quadratic equations over the non-commutative ring ***N***, which is much
    more difficult than solving linear or bilinear equations. However, if these equations
    are multiplied by R', Q', S and T, respectively, they become R'Y = XQ, YQ' = RX,
    SZ = YT' and ZT = S'Y. These matrix equations multiply out to yield bilinear equations.
    We saw how to solve bilinear equations in section 16.4.6.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米莉必须同时解出两个矩阵。让艾米莉拦截的三个矩阵分别称为X、Y和Z，即X = SMT，Y = RSMTQ和Z = RMQ。艾米莉知道Y = RXQ和Z
    = S'YT'。看起来艾米莉需要解一个大型的二次方程组，而不是解线性或双线性方程。然而，如果这些方程分别乘以R'、Q'、S和T，它们就会变成R'Y = XQ、YQ'
    = RX、SZ = YT'和ZT = S'Y。这些矩阵方程展开后会得到双线性方程。我们在第16.4.6节中看到了如何解决双线性方程。
- en: Emily can recover M if she can find both R' and Q', or if she can find both
    S' and T'. She has the choice of solving either the first two or the last two
    of these four equations. Let’s continue the example of 30×30 matrices, and concentrate
    on solving R'Y = XQ. There are 900 unknowns in R' and 900 more in Q. This matrix
    equation provides 900 bilinear equations in these 1800 unknowns. Emily also knows
    that R' is in **Ғ**, and Q is in **Ɠ**, so R'F = FR' and QG = GQ. Each of these
    yields an additional 30×29 = 870 bilinear equations. This gives Emily a total
    of 2640 bilinear equations in 1800 unknowns. These equations can be linearized
    by changing the representation of the ring elements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米丽可以通过找到 R' 和 Q'，或者找到 S' 和 T' 来恢复 M。她可以选择解决这四个方程中的前两个或后两个中的任意一个。让我们继续以 30×30
    矩阵的例子，并集中于解决 R'Y = XQ。R' 中有 900 个未知数，Q 中还有 900 个。这个矩阵方程在这 1800 个未知数中提供了 900 个双线性方程。艾米丽还知道
    R' 在 **Ғ** 中，Q 在 **Ɠ** 中，所以 R'F = FR'，QG = GQ。每个方程都产生了额外的 30×29 = 870 个双线性方程。这给了艾米丽总共
    2640 个双线性方程，1800 个未知数。通过改变环元素的表示，这些方程可以线性化。
- en: This results in 7920 linear equations in 5400 unknowns. When there are more
    equations than unknowns the system is called *overdetermined*. As Emily reduces
    the set of equations, the excess equations simply drop away. That is, many rows
    of the 7920×5400 matrix become all-zero. They may be shifted to the bottom of
    the matrix and ignored. In the end, the same difficulties appear as the 1-sided
    case, namely that there are a multitude of solutions. Since the 2-sided equations
    are overdetermined, they are stronger than the 1-sided equations. On the other
    hand, there are twice as many unknowns. It is not clear which method is ultimately
    stronger. You might simply opt for the 2-sided method because it is so much faster.******
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了 7920 个线性方程，5400 个未知数。当方程比未知数多时，系统被称为 *过度确定*。随着艾米丽减少方程组，多余的方程将被简单地舍弃。也就是说，7920×5400
    矩阵的许多行变成了全零。它们可以移到矩阵底部并被忽略。最后，与单边情况一样出现了相同的困难，即存在大量的解决方案。由于双边方程组是过度确定的，它们比单边方程组更强大。另一方面，未知数是两倍多。不清楚哪种方法最终更强大。您可能会选择双边方法，因为它快得多。******
