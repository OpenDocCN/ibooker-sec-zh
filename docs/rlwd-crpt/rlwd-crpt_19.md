# 附录：练习答案

## 第二章

*如果哈希函数用作承诺方案，你能判断它是否提供隐藏和绑定吗？*。

一个哈希函数 *隐藏* 在于其预像抗性属性；即，如果你的输入足够随机，以至于没有人能够猜测到它。为了解决这个问题，你可以生成一个随机数，并将其与你的输入进行哈希，稍后你可以公开你的输入和随机数来 *打开* 你的承诺。哈希函数 *绑定* 在于第二预像抗性属性。

*顺便问一下，这个字符串有没有表示 256 位（32 字节）的方法？这样安全吗？*。

我们不关心碰撞抗性。我们只关心第二预像抗性。因此，我们可以截断摘要以减小其大小。

*你能猜到 Dread Pirate Roberts（Silk Road 网站管理员的化名）是如何得到包含网站名称的哈希的吗？*。

Dread Pirate Roberts 创建了许多密钥，直到其中一个以那个酷炫的 base32 表示形式进行哈希。Facebook 也是这样做的，并且可以从 facebookcorewwwi.onion ([`facebook.com/notes/protect-the-graph/making-connections-to-facebook-more-secure/1526085754298237`](https://facebook.com/notes/protect-the-graph/making-connections-to-facebook-more-secure/1526085754298237)) 访问。这些被称为 *虚荣地址*。

## 第三章

*你能想出可变长度计数器可能如何允许攻击者伪造身份认证标签吗？*。

通过观察以下消息，其中 `||` 表示字符串连接，`MAC(k,` `"1"` `||` `"1` `is` `my` `favorite` `number")`，攻击者可以伪造第十一条消息的有效认证标签，`MAC(k,` `"11"` `|` `"` `is` `my` `favorite` `number")`。

*注意：并非所有的 MAC 都是 PRF。你能明白为什么吗？*。

假设以下函数是有效的 MAC 和 PRF：`MAC(key,` `input)`，那么以下函数是有效的 MAC 吗？`NEW_MAC` `=` `MAC(key,` `input)` `||` `0x01`？它是有效的 PRF 吗？它是有效的 MAC，因为它防止伪造，但它不是有效的 PRF，因为你可以很容易地区分输出和完全随机的字符串（因为最后一个字节总是设置为 1）。

## 第六章

*如果每个人都使用相同的共享秘密会很糟糕；你能明白为什么吗？*。

如果我能用这个共享的秘密给你加密消息，我也可以解密其他人的消息。

*你知道为什么不能立即使用密钥交换的输出吗？*。

记住你在第五章关于密钥交换学到的知识。在 (FF)DH 中，计算是在一个大素数 *p* 的模下进行的。让我们以小素数为例，65,537\. 以十六进制表示，我们的 *p* 写为 `0x010001`，而在二进制中，它写为 `0000` `0001` `0000` `0000` `0000` `0001`。在二进制中，注意到第一个 1 之前的零，因为我们将我们的数字表示为字节（8 位的倍数）。

如果你了解模算术，你会知道对于这个质数*p*的模数永远不会更大，这意味着前 7 位将始终被设置为 0。此外，第八位大多数情况下会设置为 0 而不是 1。这不是*均匀随机*的。理想情况下，每一位都应该有相同的概率被设置为 1 或 0。

## 第七章

*正如你在第三章中所看到的，由 MAC 产生的认证标签必须以恒定时间验证，以避免时间攻击。你认为我们需要对验证签名做同样的事情吗？*。

不需要。这是因为验证认证标签涉及到一个秘密密钥。验证签名仅涉及公钥，因此不需要以恒定时间验证。

## 第八章

*想象一下，将不同熵源混合在一起的方法只是简单地将它们进行异或。你能看到这可能会导致不可贡献吗？*。

一个带有后门的熵源可以将其输出设置为所有其他熵源的异或，有效地将所有熵取消为 0。

*BLS 等签名方案（见图 8.5 和第七章中提到）会产生唯一的签名，但对于 ECDSA 和 EdDSA 却不成立。你明白为什么吗？*。

在 ECDSA 中，签名者可以选择不同的随机数产生相同密钥对和消息的不同签名。而 EdDSA 是一种签名算法，根据要签名的消息确定地推导出随机数，但这并不意味着签名者不能选择任何随机数。

## 第九章

*如果服务器的私钥在某个时间点被泄露，那么中间人攻击者随后将能够解密所有先前记录的对话。你明白这是如何发生的吗？*。

攻击者随后将能够倒带历史并在握手时模拟服务器。实际上，攻击者现在拥有了服务器的私钥。执行密钥交换和推导握手后对称密钥的所有其他信息都是公开的。

*实际证书`tbsCertificate`中不包含值`signatureAlgorithm`和`signatureValue`。你知道为什么吗？*。

认证机构（CA）需要签署证书，这导致了一个悖论：签名不能成为签名本身的一部分。因此，CA 必须将签名附加到证书上。其他标准和协议可能使用不同的技术。例如，你可以将签名作为`tbsCertificate`的一部分，并在签署或验证证书时假装它由全 0 组成。

## 第十章

*你知道为什么电子邮件的内容在加密之前被压缩而不是之后吗？*。

根据密码的定义，密文无法与随机字符串区分开来。因此，压缩算法无法找到有效压缩加密数据的模式。因此，压缩总是在加密之前应用。

*你能想到一种明确的签署消息的方法吗？*。

一句话：验证上下文。一种方法是在签名中包含发送者和接收者的姓名和他们的公钥，然后对其进行加密。

## 第十一章

*有时应用程序试图通过让客户端在将密码发送到服务器之前进行哈希（也许使用密码哈希）来解决服务器在注册时了解用户密码的问题。你能确定这是否有效吗？*。

仅仅使用客户端哈希无法防止像臭名昭著的传递哈希攻击那样的攻击（[`en.wikipedia.org/wiki/Pass_the_hash`](https://en.wikipedia.org/wiki/Pass_the_hash)）；如果服务器直接存储 Alice 的哈希密码，那么任何窃取它的人也可以将其用作 Alice 的密码进行身份验证。一些应用程序同时进行客户端哈希和服务器端哈希，这种情况下或许可以防止主动攻击者知道原始密码（尽管主动攻击者可能通过更新客户端应用程序的代码来禁用客户端哈希）。

*想象一种协议，你必须输入正确的 4 位 PIN 码才能安全连接到设备。仅仅猜测正确的 PIN 码的机会是多少？*。

这是一万分之一的机会猜对某件事。如果你在乐透中有这样的几率，你会很高兴的。
