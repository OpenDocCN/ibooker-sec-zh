- en: 2 Hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs: []
  type: TYPE_NORMAL
- en: Defining hash functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing security archetypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying data integrity with hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a cryptographic hash function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `hashlib` module for cryptographic hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn to use hash functions to ensure data integrity,
    a fundamental building block of secure system design. You’ll also learn how to
    distinguish safe and unsafe hash functions. Along the way, I’ll introduce you
    to Alice, Bob, and a few other archetypal characters. I use these characters to
    illustrate security concepts throughout the book. Finally, you’ll learn how to
    hash data with the `hashlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 What is a hash function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every *hash function* has input and output. The input to a hash function is
    called a *message*. A message can be any form of data. The Gettysburg Address,
    an image of a cat, and a Python package are examples of potential messages. The
    output of a hash function is a very large number. This number goes by many names:
    *hash value*, *hash*, *hash code*, *digest*, and *message digest*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I use the term *hash value*. Hash values are typically represented
    as alphanumeric strings. A hash function maps a set of messages to a set of hash
    values. Figure 2.1 illustrates the relationships among a message, a hash function,
    and a hash value.
  prefs: []
  type: TYPE_NORMAL
- en: '![CH02_F01_Byrne](Images/CH02_F01_Byrne.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 A hash function maps an input known as a message to an output known
    as a hash value.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I depict each hash function as a funnel. A hash function and a
    funnel both accept variable-sized inputs and produce fixed-size outputs. I depict
    each hash value as a fingerprint. A hash value and a fingerprint uniquely identify
    a message or a person, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are different from one another. These differences typically boil
    down to the properties defined in this section. To illustrate the first few properties,
    we’ll use a built-in Python function, conveniently named `hash`. Python uses this
    function to manage dictionaries and sets, and you and I are going to use it for
    instructional purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `hash` function is a good way to introduce the basics because
    it is much simpler than the hash functions discussed later in this chapter. The
    built-in `hash` function takes one argument, the message, and returns a hash value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Message input
  prefs: []
  type: TYPE_NORMAL
- en: ❷ Hash value output
  prefs: []
  type: TYPE_NORMAL
- en: 'Hash functions are characterized by three basic properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed-length hash values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The avalanche effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deterministic behavior
  prefs: []
  type: TYPE_NORMAL
- en: 'Every hash function is *deterministic*: for a given input, a hash function
    always produces the same output. In other words, hash function behavior is repeatable,
    not random. Within a Python process, the built-in `hash` function always returns
    the same hash value for a given message value. Run the following two lines of
    code in an interactive Python shell. Your hash values will match, but will be
    different from mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Same hash value
  prefs: []
  type: TYPE_NORMAL
- en: The hash functions I discuss later in this chapter are universally deterministic.
    These functions behave the same regardless of how or where they are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed-length hash values
  prefs: []
  type: TYPE_NORMAL
- en: Messages have arbitrary lengths; hash values, for a particular hash function,
    have a fixed length. If a function does not possess this property, it does not
    qualify as a hash function. The length of the message does not affect the length
    of the hash value. Passing different messages to the built-in `hash` function
    will give you different hash values, but each hash value will always be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Avalanche effect
  prefs: []
  type: TYPE_NORMAL
- en: 'When small differences between messages result in large differences between
    hash values, the hash function is said to exhibit the *avalanche effect*. Ideally,
    every output bit depends on every input bit: if two messages differ by one bit,
    then on average only half the output bits should match. A hash function is judged
    by how close it comes to this ideal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code. The hash values for both string and integer
    objects have a fixed length, but only the hash values for string objects exhibit
    the avalanche effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The built-in `hash` function is a nice instructional tool but it cannot be considered
    a cryptographic hash function. The next section outlines three reasons this is
    true.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1 Cryptographic hash function properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *cryptographic hash function* must meet three additional criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: One-way function property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weak collision resistance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong collision resistance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The academic terms for these properties are *preimage resistance*, *second preimage
    resistance*, and *collision resistance*. For purposes of discussion, I avoid the
    academic terms, with no intentional disrespect to scholars.
  prefs: []
  type: TYPE_NORMAL
- en: One-way functions
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions used for cryptographic purposes, with no exceptions, must be
    *one-way functions*. A function is one-way if it is easy to invoke and difficult
    to reverse engineer. In other words, if you have the output, it must be difficult
    to identify the input. If an attacker obtains a hash value, we want it to be difficult
    for them to figure out what the message was.
  prefs: []
  type: TYPE_NORMAL
- en: 'How difficult? We typically use the word *infeasible*. This means *very difficult*—so
    difficult that an attacker has only one option if they wish to reverse engineer
    the message: brute force.'
  prefs: []
  type: TYPE_NORMAL
- en: What does *brute force* mean? Every attacker, even an unsophisticated one, is
    capable of writing a simple program to generate a very large number of messages,
    hash each message, and compare each computed hash value to the given hash value.
    This is an example of a brute-force attack. The attacker has to have a lot of
    time and resources, not intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: How much time and resources? Well, it’s subjective. The answer isn’t written
    in stone. For example, a theoretical brute-force attack against some of the hash
    functions discussed later in this chapter would be measured in millions of years
    and billions of dollars. A reasonable security professional would call this infeasible.
    This does not mean it’s impossible. We recognize there is no such thing as a perfect
    hash function, because brute force will always be an option for attackers.
  prefs: []
  type: TYPE_NORMAL
- en: Infeasibility is a moving target. A brute-force attack considered infeasible
    a few decades ago may be practical today or tomorrow. As the costs of computer
    hardware continue to fall, so do the costs of brute-force attacks. Unfortunately,
    cryptographic strength weakens with time. Try not to interpret this as though
    every system is eventually vulnerable. Instead, understand that every system must
    eventually use stronger hash functions. This chapter will help you make an informed
    decision about which hash functions to use.
  prefs: []
  type: TYPE_NORMAL
- en: Collision resistance
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions used for cryptographic purposes, with no exceptions, must possess
    *collision resistance*. What is a collision? Although hash values for different
    messages have the same length, they almost never have the same value . . . almost.
    When two messages hash to the same hash value, it is called a *collision*. Collisions
    are bad. Hash functions are designed to minimize collisions. We judge a hash function
    on how well it avoids collisions; some are better than others.
  prefs: []
  type: TYPE_NORMAL
- en: A hash function has *weak collision resistance* if, given a message, it is infeasible
    to identify a second message that hashes to the same hash value. In other words,
    if an attacker has one input, it must be infeasible to identify another input
    capable of producing the same output.
  prefs: []
  type: TYPE_NORMAL
- en: A hash function has *strong collision resistance* if it is infeasible to find
    any collision whatsoever. The difference between weak collision resistance and
    strong collision resistance is subtle. Weak collision resistance is bound to a
    particular given message; strong collision resistance applies to any pair of messages.
    Figure 2.2 illustrates this difference.
  prefs: []
  type: TYPE_NORMAL
- en: '![CH02_F02_Byrne](Images/CH02_F02_Byrne.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 Weak collision resistance compared to strong collision resistance
  prefs: []
  type: TYPE_NORMAL
- en: Strong collision resistance implies weak collision resistance, not the other
    way around. Any hash function with strong collision resistance also has weak collision
    resistance; a hash function with weak collision resistance may not necessarily
    have strong collision resistance. Strong collision resistance is therefore a bigger
    challenge; this is usually the first property lost when an attacker or researcher
    breaks a cryptographic hash function. Later in this chapter, I show you an example
    of this in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the key word is *infeasible*. Despite how nice it would be to identify
    a collisionless hash function, we will never find one because it does not exist.
    Think about it. Messages can have any length; hash values can have only one length.
    The set of all possible messages will therefore always be larger than the set
    of all possible hash values. This is known as the *pigeonhole principle*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned what a hash function is. Now it’s time to learn
    how hashing ensures data integrity. But first, I’ll introduce you to a handful
    of archetypal characters. I use these characters throughout the book to illustrate
    security concepts, starting with data integrity in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Archetypal characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I use five archetypal characters to illustrate security concepts in this book
    (see Figure 2.3). Trust me, these characters make it much easier to read (and
    write) this book. The solutions in this book revolve around the problems faced
    by Alice and Bob. If you’ve read other security books, you’ve probably already
    met these two characters. Alice and Bob are just like you—they want to create
    and share information securely. Occasionally, their friend Charlie makes an appearance.
    The data for each example in this book tends to flow among Alice, Bob, and Charlie;
    remember A, B, and C. Alice, Bob, and Charlie are good characters. Feel free to
    identify with these characters as you read this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![CH02_F03_Byrne](Images/CH02_F03_Byrne.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 Archetypal characters with halos are good; attackers are designated
    with horns.
  prefs: []
  type: TYPE_NORMAL
- en: Eve and Mallory are bad characters. Remember Eve as evil. Remember Mallory as
    malicious. These characters attack Alice and Bob by trying to steal or modify
    their data and identities. Eve is a passive attacker; she is an eavesdropper.
    She tends to gravitate toward the network portion of the attack surface. Mallory
    is an active attacker; she is more sophisticated. She tends to use the system
    or the users as entry points.
  prefs: []
  type: TYPE_NORMAL
- en: Remember these characters; you’ll see them again. Alice, Bob, and Charlie have
    halos; Eve and Mallory have horns. In the next section, Alice will use hashing
    to ensure data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Data integrity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Data* *integrity*, sometimes called *message integrity*, is the assurance
    that data is free of unintended modification. It answers the question, “Has the
    data changed?” Suppose Alice works on a document management system. Currently,
    the system stores two copies of each document to ensure data integrity. To verify
    the integrity of a document, the system compares both copies, byte for byte. If
    the copies do not match, the document is considered corrupt. Alice is unsatisfied
    with how much storage space the system consumes. The costs are getting out of
    control, and the problem is getting worse as the system accommodates more documents.'
  prefs: []
  type: TYPE_NORMAL
- en: Alice realizes she has a common problem and decides to solve it with a common
    solution, a cryptographic hash function. As each document is created, the system
    computes and stores a hash value of it. To verify the integrity of each document,
    the system first rehashes it. The new hash value is then compared to the old hash
    value in storage. If the hash values don’t match, the document is considered corrupt.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 illustrates this process in four steps. A puzzle piece depicts the
    comparison of both hash values.
  prefs: []
  type: TYPE_NORMAL
- en: '![CH02_F04_Byrne](Images/CH02_F04_Byrne.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 Alice ensures data integrity by comparing hash values, not documents.
  prefs: []
  type: TYPE_NORMAL
- en: Can you see why collision resistance is important? Let’s say Alice were to use
    a hash function that lacked collision resistance. The system would have no absolute
    way of detecting data corruption if the original version of the file collides
    with the corrupted version.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section demonstrated an important application of hashing: data integrity.
    In the next section, you’ll learn how to choose an actual hash function suitable
    for doing this.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Choosing a cryptographic hash function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python supports cryptographic hashing natively. There is no need for third-party
    frameworks or libraries. Python ships with a `hashlib` module that exposes everything
    most programmers need for cryptographic hashing. The `algorithms_guaranteed` set
    contains every hash function that is guaranteed to be available for all platforms.
    The hash functions in this collection represent your options. Few Python programmers
    will ever need or even see a hash function outside this set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is natural to feel overwhelmed by this many choices. Before choosing a hash
    function, we must divide our options into those that are safe and unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.1 Which hash functions are safe?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The safe and secure hash functions of `algorithms_guaranteed` fall under the
    following hash algorithm families:'
  prefs: []
  type: TYPE_NORMAL
- en: SHA-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BLAKE2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-2
  prefs: []
  type: TYPE_NORMAL
- en: The *SHA-2* hash function family was published by the NSA in 2001\. This family
    is composed of SHA-224, SHA-256, SHA-384, and SHA-512\. SHA-256 and SHA-512 are
    the core of this family. Don’t bother memorizing the names of all four functions;
    just focus on SHA-256 for now. You’re going to see it a lot in this book.
  prefs: []
  type: TYPE_NORMAL
- en: You should use SHA-256 for general-purpose cryptographic hashing. This is an
    easy decision because every system we work on is already using it. The operating
    systems and networking protocols we deploy applications with depend on SHA-256,
    so we don’t have a choice. You’d have to work very hard to not use SHA-256\. It
    is safe, secure, well supported, and used everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: The name of each function in the SHA-2 family conveniently self-documents its
    hash value length. Hash functions are often categorized, judged, and named by
    the length of their hash values. SHA-256, for example, is a hash function that
    produces—you guessed it—hash values that are 256 bits long. Longer hash values
    are more likely to be unique and less likely to collide. Longer is better.
  prefs: []
  type: TYPE_NORMAL
- en: SHA-3
  prefs: []
  type: TYPE_NORMAL
- en: The *SHA-3* hash function family is composed of SHA3-224, SHA3-256, SHA3-384,
    SHA3-512, SHAKE128 and SHAKE256\. SHA-3 is safe, secure, and considered by many
    to be the natural successor of SHA-2\. Unfortunately, SHA-3 adoption hasn’t gained
    momentum at the time of this writing. You should consider using a SHA-3 function
    like SHA3-256 if you’re working in a high-security environment. Just be aware
    that you may not find the same levels of support that exist for SHA-2.
  prefs: []
  type: TYPE_NORMAL
- en: BLAKE2
  prefs: []
  type: TYPE_NORMAL
- en: '*BLAKE2* isn’t as popular as SHA-2 or SHA-3 but does have one big advantage:
    BLAKE2 leverages modern CPU architecture to hash at extreme speeds. For this reason,
    you should consider using BLAKE2 if you need to hash large amounts of data. BLAKE2
    comes in two flavors: BLAKE2b and BLAKE2s. BLAKE2b is optimized for 64-bit platforms.
    BLAKE2s is optimized for 8- to 32-bit platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned how to identify and choose a safe hash function, you’re
    ready to learn how to identify and avoid the unsafe ones.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2 Which hash functions are unsafe?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The hash functions in `algorithms_guaranteed` are popular and cross-platform.
    This doesn’t mean every one of them is cryptographically secure. Insecure hash
    functions are preserved in Python for the sake of maintaining backward compatibility.
    Understanding these functions is worth your time because you may encounter them
    in legacy systems. The unsafe hash functions of `algorithms_guaranteed` are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: MD5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MD5
  prefs: []
  type: TYPE_NORMAL
- en: '*MD5* is an obsolete 128-bit hash function developed in the early 1990s. This
    is one of the most used hash functions of all time. Unfortunately, MD5 is still
    in use even though researchers have demonstrated MD5 collisions as far back as
    2004\. Today cryptanalysts can generate MD5 collisions on commodity hardware in
    less than an hour.'
  prefs: []
  type: TYPE_NORMAL
- en: SHA-1
  prefs: []
  type: TYPE_NORMAL
- en: '*SHA-1* is an obsolete 160-bit hash function developed by the NSA in the mid-1990s.
    Like MD5, this hash function was popular at one time but it is no longer considered
    secure. The first collisions for SHA-1 were announced in 2017 by a collaboration
    effort between Google and Centrum Wiskunde & Informatica, a research institute
    in the Netherlands. In theoretical terms, this effort stripped SHA-1 of strong
    collision resistance, not weak collision resistance.'
  prefs: []
  type: TYPE_NORMAL
- en: Many programmers are familiar with SHA-1 because it is used to verify data integrity
    in version-control systems such as Git and Mercurial. Both of these tools use
    a SHA-1 hash value to identify and ensure the integrity of each commit. Linus
    Torvalds, the creator of Git, said at a Google Tech Talk in 2007, “SHA-1, as far
    as Git is concerned, isn’t even a security feature. It’s purely a consistency
    check.”
  prefs: []
  type: TYPE_NORMAL
- en: WARNING MD5 or SHA-1 should never be used for security purposes when creating
    a new system. Any legacy system using either function for security purposes should
    be refactored to a secure alternative. Both of these functions have been popular,
    but SHA-256 is popular and secure. Both are fast, but BLAKE2 is faster and secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a summary of the dos and don’ts of choosing a hash function:'
  prefs: []
  type: TYPE_NORMAL
- en: Use SHA-256 for general-purpose cryptographic hashing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use SHA3-256 in high-security environments, but expect less support than for
    SHA-256.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use BLAKE2 to hash large messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never use MD5 or SHA1 for security purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you’ve learned how to choose a safe cryptographic hash function, let’s
    apply this choice in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Cryptographic hashing in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `hashlib` module features a named constructor for each hash function in
    `hashlib.algorithms_guaranteed`. Alternatively, each hash function is accessible
    dynamically with a general-purpose constructor named `new`. This constructor accepts
    any string in `algorithms_guaranteed`. Named constructors are faster than, and
    preferred over, the generic constructor. The following code demonstrates how to
    construct an instance of SHA-256 with both constructor types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Named constructor
  prefs: []
  type: TYPE_NORMAL
- en: ❷ Generic constructor
  prefs: []
  type: TYPE_NORMAL
- en: 'A hash function instance can be initialized with or without a message. The
    following code initializes a SHA-256 function with a message. Unlike the built-in
    `hash` function, the hash functions in `hashlib` require the message to be of
    type bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Each hash function instance, regardless of how it is created, has the same
    API. The public methods for a SHA-256 instance are analogous to the public methods
    for an MD5 instance. The `digest` and `hexdigest` methods return a hash value
    as bytes and hexadecimal text, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Returns hash value as bytes
  prefs: []
  type: TYPE_NORMAL
- en: ❷ Returns hash value as string
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the `digest` method to demonstrate an MD5 collision.
    Both messages have only a handful of different characters (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Different message
  prefs: []
  type: TYPE_NORMAL
- en: ❷ Same hash value, collision
  prefs: []
  type: TYPE_NORMAL
- en: 'A message can alternatively be hashed with the `update` method, shown in bold
    in the following code. This is useful when the hash function needs to be created
    and used separately. The hash value is unaffected by how the message is fed to
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Hash function constructed without message
  prefs: []
  type: TYPE_NORMAL
- en: ❷ Message delivered with update method
  prefs: []
  type: TYPE_NORMAL
- en: ❸ Same hash value
  prefs: []
  type: TYPE_NORMAL
- en: A message can be broken into chunks and hashed iteratively with repeated calls
    to the `update` method, shown in bold in the following code. Each call to the
    `update` method updates the hash value without copying or storing a reference
    to the message bytes. This feature is therefore useful when a large message cannot
    be loaded into memory all at once. Hash values are insensitive to how the message
    is processed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Hash function initiated with message
  prefs: []
  type: TYPE_NORMAL
- en: ❷ Hash function given message in chunks
  prefs: []
  type: TYPE_NORMAL
- en: ❸ Same hash value
  prefs: []
  type: TYPE_NORMAL
- en: 'The `digest_size` property exposes the length of the hash value in terms of
    bytes. Recall that SHA-256, as the name indicates, is a 256-bit hash function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Cryptographic hash functions are universally deterministic by definition. They
    are naturally cross-platform. The inputs from the examples in this chapter will
    produce the same outputs on any computer in any programming language through any
    API. The following two commands demonstrate this guarantee, using Python and Ruby.
    If two implementations of the same cryptographic hash function produce a different
    hash value, you know that at least one of them is broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in `hash` function, on the other hand, by default, is deterministic
    only within a particular Python process. The following two commands demonstrate
    two *different* Python processes hashing the same message to different hash values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Same message
  prefs: []
  type: TYPE_NORMAL
- en: ❷ Different hash value
  prefs: []
  type: TYPE_NORMAL
- en: WARNING The built-in `hash` function should never be used for cryptographic
    purposes. This function is very fast, but it does not possess enough collision
    resistance to be in the same league as SHA-256.
  prefs: []
  type: TYPE_NORMAL
- en: You may have wondered by now, “Aren’t hash values just checksums?” The answer
    is no. The next section explains why.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Checksum functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hash functions and checksum functions share a few things in common. *Hash functions*
    accept data and produce hash values; *checksum functions* accept data and produce
    checksums. A hash value and a checksum are both numbers. These numbers are used
    to detect undesired data modification, usually when data is at rest or in transit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python natively supports checksum functions such as cyclic redundancy check
    (CRC) and Adler-32 in the `zlib` module. The following code demonstrates a common
    use case of CRC. This code compresses and decompresses a block of repetitious
    data. A checksum of the data is calculated before and after this transformation
    (shown in bold). Finally, error detection is performed by comparing the checksums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: ❶ Checksums a message
  prefs: []
  type: TYPE_NORMAL
- en: ❷ Compresses and decompresses the message
  prefs: []
  type: TYPE_NORMAL
- en: ❸ No errors detected by comparing checksums
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite their similarities, hash functions and checksum functions should not
    be confused with each other. The trade-off between a hash function and a checksum
    function boils down to cryptographic strength versus speed. In other words, cryptographic
    hash functions have stronger collision resistance, while checksum functions are
    faster. For example, CRC and Adler-32 are much faster than SHA-256, but neither
    possesses sufficient collision resistance. The following two lines of code demonstrate
    one of countless CRC collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you could identify a collision like this with SHA-256, it would send shockwaves
    across the cybersecurity field. Associating checksum functions with data integrity
    is a bit of a stretch. It is more accurate to characterize checksum functions
    with *error detection*, not data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING Checksum functions should never be used for security purposes. Cryptographic
    hash functions can be used in place of checksum functions at a substantial performance
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned to use the `hashlib` module, not the `zlib` module,
    for cryptographic hashing. The next chapter continues with hashing. You’ll learn
    how to use the `hmac` module for keyed hashing, a common solution for data authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hash functions deterministically map messages to fixed-length hash values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use cryptographic hash functions to ensure data integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should use SHA-256 for general-purpose cryptographic hashing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code using MD5 or SHA1 for security purposes is vulnerable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use the `hashlib` module for cryptographic hashing in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checksum functions are unsuitable for cryptographic hashing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alice, Bob, and Charlie are good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eve and Mallory are bad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
