- en: 17 Cross-Origin Resource Sharing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 跨源资源共享
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Understanding the same-origin policy
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同源策略
- en: Sending and receiving simple CORS requests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送和接收简单的 CORS 请求
- en: Implementing CORS with `django-cors-headers`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `django-cors-headers` 实现 CORS
- en: Sending and receiving preflighted CORS requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送和接收预检 CORS 请求
- en: In chapter 15, you learned that an origin is defined by the protocol (scheme),
    host, and port of a URL. Every browser implements a *same-origin policy* (*SOP*).
    The goal of this policy is to ensure that certain resources are accessible to
    documents with only the “same origin.” This prevents a page with an origin of
    mallory.com from gaining unauthorized access to a resource originating from ballot.charlie.com.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 15 章中，您了解到一个源由 URL 的协议（方案）、主机和端口定义。每个浏览器都实现了*同源策略*（SOP）。该策略的目标是确保只有“相同源”的文档可以访问某些资源。这样可以防止具有
    mallory.com 源的页面未经授权地访问源自 ballot.charlie.com 的资源。
- en: Think of *Cross-Origin Resource Sharing* (CORS) as a way to relax the browser’s
    SOP. This allows social.bob.com to load a font from https:/./fonts.gstatic.com.
    It also lets a page from alice.com send an asynchronous request to social.bob.com.
    In this chapter, I’ll show you how to safely create and consume shared resources
    with `django-cors-headers`. Because of the nature of CORS, this chapter contains
    more JavaScript than Python.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将*跨源资源共享*（CORS）看作是放宽浏览器同源策略的一种方式。这使得 social.bob.com 可以从 https:/./fonts.gstatic.com
    加载字体。它还允许 alice.com 的页面向 social.bob.com 发送异步请求。在本章中，我将向您展示如何使用 `django-cors-headers`
    安全地创建和消耗共享资源。由于 CORS 的性质，本章包含的 JavaScript 比 Python 更多。
- en: 17.1 Same-origin policy
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1 同源策略
- en: By now, you’ve seen Mallory gain unauthorized access to many resources. She
    cracked Charlie’s password with a rainbow table. She took over Bob’s account with
    a `Host` header attack. She figured out who Alice voted for with XSS. In this
    section, Mallory launches a much simpler attack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到 Mallory 未经授权地访问了许多资源。她用彩虹表破解了 Charlie 的密码。她用 `Host` 头攻击接管了 Bob 的帐户。她通过
    XSS 弄清了 Alice 投票给谁。在本节中，Mallory 发起了一次更简单的攻击。
- en: Suppose Mallory wants to know who Bob voted for in the 2020 US presidential
    election. She lures him back to mallory.com, and his browser renders the following
    malicious web page. This page quietly requests Bob’s ballot form from ballot.charlie.com,
    a site Bob is currently logged in to. The ballot form, containing Bob’s vote,
    is then loaded into a hidden iframe. This triggers a JavaScript event handler,
    which *attempts* to read Bob’s vote and send it to Mallory’s server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Mallory 想知道 Bob 在 2020 年美国总统选举中投了谁的票。她引诱他回到 mallory.com，他的浏览器渲染了以下恶意网页。这个页面悄悄地从
    Bob 当前登录的网站 ballot.charlie.com 请求 Bob 的选票表单。包含 Bob 投票的选票表单然后加载到一个隐藏的 iframe 中。这触发了一个
    JavaScript 事件处理程序，*试图*读取 Bob 的投票并将其发送到 Mallory 的服务器。
- en: Mallory’s attack fails miserably, as shown in the following listing. Bob’s browser
    blocks her web page from accessing the iframe document property, raising a `DOMException`
    instead. The SOP saves the day.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Mallory 的攻击失败得很惨，如下列表所示。Bob 的浏览器阻止了她的网页访问 iframe 文档属性，而是抛出了 `DOMException` 异常。同源策略（SOP）挽救了这一局面。
- en: Listing 17.1 Mallory fails to steal Bob’s private information
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.1 Mallory 未能窃取 Bob 的私人信息
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Raises DOMException instead of accessing Bob’s vote
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 抛出 DOMException 而不是访问 Bob 的投票
- en: ❷ Tries to capture Bob’s vote but never executes
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 试图获取 Bob 的投票但从未执行
- en: ❸ Loads Bob’s ballot page
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 加载 Bob 的选票页面
- en: ❹ Invoked after ballot page loads
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在选票页面加载后调用
- en: ❺ Hides ballot page
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 隐藏选票页面
- en: Long ago, there was no SOP. If Mallory had tried this technique in the mid-1990s,
    she would have succeeded. Attacks like this were so easy to execute that someone
    like Mallory usually didn’t have the need for techniques such as XSS. Obviously,
    it didn’t take each browser vendor very long to adopt an SOP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，还没有同源策略。如果 Mallory 在 1990 年代中期尝试了这种技术，她就会成功。像这样的攻击非常容易执行，以至于像 Mallory 这样的人通常不需要像
    XSS 这样的技术。显然，各浏览器供应商并没有花很长时间就采纳了同源策略。
- en: Contrary to popular belief, the browser’s SOP does not apply to all cross-origin
    activity; most embedded content is exempt. For example, suppose Mallory’s malicious
    web page loads an image, script, and stylesheet from ballot.charlie.com; the SOP
    would have no problem displaying, executing, and applying all three of these resources.
    This is exactly how a website integrates with a CDN. It happens all the time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与流行观念相反，浏览器的SOP并不适用于所有的跨域活动；大多数嵌入内容是例外的。例如，假设Mallory的恶意网页从ballot.charlie.com加载了图像、脚本和样式表；SOP将毫无问题地显示、执行和应用这三种资源。这正是网站与CDN集成的方式。这种情况时常发生。
- en: For the remainder of this chapter, I cover functionality that *is* subject to
    the SOP. In these scenarios, the browser and the server must cooperate via CORS.
    Like CSP, CORS is a W3C Recommendation ([www.w3.org/TR/2020/SPSD-cors-20200602/](https://www.w3.org/TR/2020/SPSD-cors-20200602/)).
    This document defines a standard for sharing resources between origins, giving
    you a mechanism to relax the browser’s SOP in precise ways.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分中，我将介绍*受同源策略约束的*功能。在这些场景中，浏览器和服务器必须通过CORS进行合作。与CSP一样，CORS是W3C的推荐标准（[www.w3.org/TR/2020/SPSD-cors-20200602/](https://www.w3.org/TR/2020/SPSD-cors-20200602/)）。该文档定义了在来源之间共享资源的标准，为您提供了一种以精确方式放宽浏览器SOP的机制。
- en: 17.2 Simple CORS requests
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2 简单的CORS请求
- en: 'CORS is a collaboration effort between the browser and server, implemented
    by a group of request and response headers. In this section, I introduce the most
    commonly used CORS header with two simple examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CORS是浏览器和服务器之间的协作努力，由一组请求和响应头部实现。在本节中，我介绍了两个简单的例子，其中包含最常用的CORS头部：
- en: Using a font from Google
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用谷歌的字体
- en: Sending an asynchronous request
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送异步请求
- en: Embedded content generally doesn’t require CORS; fonts are an exception. Suppose
    Alice requests the web page in listing 17.2 from bob.com (this page also appeared
    in chapter 15). As shown in bold, the web page triggers a second request to https://fonts.googleapis.com
    for a stylesheet. Google’s stylesheet triggers a third request to https://fonts.gstatic.com
    for a web font.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入内容通常不需要CORS；字体是例外。假设Alice从bob.com请求了列表17.2中的网页（此页面也出现在第15章）。如粗体所示，网页触发了对https://fonts.googleapis.com的样式表的第二次请求。谷歌的样式表触发了对https://fonts.gstatic.com的Web字体的第三次请求。
- en: Listing 17.2 A web page embeds a stylesheet and font from Google
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.2 网页嵌入了来自谷歌的样式表和字体
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ A public stylesheet hosted by Google
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由谷歌托管的公共样式表
- en: ❷ An inline stylesheet
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个内联样式表
- en: 'Google sends the third response with two interesting headers. The `Content-Type`
    header indicates that the font is in Web Open Font Format (you learned about this
    header in chapter 14). More importantly, the response also contains a CORS-defined
    `Access-Control-Allow-Origin` header. By sending this header, Google informs the
    browser that a resource from any origin is allowed to access the font:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌发送的第三个响应带有两个有趣的头部信息。`Content-Type`头部指示字体采用Web开放字体格式（你在第14章学过这个头部）。更重要的是，响应还包含了一个由CORS定义的`Access-Control-Allow-Origin`头部。通过发送这个头部，谷歌告知浏览器允许来自任何来源的资源访问该字体：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Relaxes the same-origin policy for all origins
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 放宽了所有来源的同源策略
- en: This solution works fine if your goal is to share a resource with the entire
    world; but what if you want to share a resource with only a single trusted origin?
    This use case is covered next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是与全世界分享资源，这个解决方案是完全有效的；但是如果你只想与一个信任的来源分享资源呢？接下来就介绍了这种用例。
- en: 17.2.1 Cross-origin asynchronous requests
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.1 跨源异步请求
- en: Suppose Bob wants his social media site users to stay informed about the latest
    trends. He creates a new read-only /trending/ resource, serving a short list of
    popular social media posts. Alice wants to display this information to users of
    alice.com as well so she writes the following JavaScript. Her code retrieves Bob’s
    new resource with an asynchronous request. An event handler populates a widget
    with the response.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Bob希望他的社交媒体站点用户始终了解最新趋势。他创建了一个新的只读/trending/资源，提供了一份热门社交媒体帖子的简短列表。Alice也想将这些信息展示给alice.com的用户，所以她编写了以下JavaScript。她的代码通过异步请求检索Bob的新资源。事件处理程序用响应填充了一个小部件。
- en: Listing 17.3 A web page sends a cross-origin asynchronous request
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.3 网页发送了一个跨域异步请求
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Sends a cross-origin request
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 发送一个跨域请求
- en: ❷ Renders response items to the user
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将响应项呈现给用户
- en: To Alice’s surprise, her browser blocks the response, and the response handler
    is never called. Why? The SOP simply has no way to determine whether the response
    contains public or private data; `social.bob.com/trending/` and `social.bob .com/direct-messages/`
    are treated the same. Like all cross-origin asynchronous requests, the response
    must contain a valid `Access-Control-Allow-Origin` header or the browser will
    block access to it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 令Alice惊讶的是，她的浏览器阻止了响应，并且响应处理程序从未被调用。为什么？SOP简单地无法确定响应是否包含公共或私人数据；`social.bob.com/trending/`和`social.bob.com/direct-messages/`被视为相同。与所有跨域异步请求一样，响应必须包含有效的`Access-Control-Allow-Origin`头，否则浏览器将阻止访问。
- en: 'Alice asks Bob to add an `Access-Control-Allow-Origin` header to `/trending/`.
    Notice that Bob is more restrictive of `/trending/` than Google is of its font.
    By sending this header, social.bob.com informs the browser that a document must
    originate from `https://alice.com` in order to access the resource:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Alice要求Bob向`/trending/`添加`Access-Control-Allow-Origin`头。请注意，Bob对`/trending/`的限制比Google对其字体的限制更严格。通过发送这个头，social.bob.com告知浏览器文档必须源自`https://alice.com`才能访问资源：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Access-Control-Allow-Origin` is the first of many CORS headers I cover in
    this chapter. In the next section, you’ll learn how to start using it.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Origin`是我在本章中介绍的许多CORS头中的第一个。在下一节中，您将学习如何开始使用它。'
- en: 17.3 CORS with django-cors-headers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3 使用django-cors-headers进行CORS
- en: 'Sharing resources between origins is easy with `django-cors-headers`. From
    within your virtual environment, run the following command to install it. This
    package should be installed into the shared resource producer, not the consumers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`django-cors-headers`在不同来源之间共享资源很容易。在您的虚拟环境中，运行以下命令来安装它。此软件包应安装到共享资源生产者，而不是消费者：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, add the `corsheaders` app to `INSTALLED_APPS` in your `settings` module:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的`settings`模块中的`INSTALLED_APPS`中添加`corsheaders`应用程序：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, add `CorsMiddleware` to `MIDDLEWARE` as it appears here in bold font.
    According to the project documentation, `CorsMiddleware` should be placed “before
    any middleware that can generate responses such as Django''s `CommonMiddleware`
    or WhiteNoise’s `WhiteNoiseMiddleware`”:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`MIDDLEWARE`中添加`CorsMiddleware`，如粗体字所示。根据项目文档，`CorsMiddleware`应该被放置“在任何可以生成响应的中间件之前，例如Django的`CommonMiddleware`或WhiteNoise的`WhiteNoiseMiddleware`”：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 17.3.1 Configuring Access-Control-Allow-Origin
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3.1 配置Access-Control-Allow-Origin
- en: 'Before configuring `Access-Control-Allow-Origin`, you must answer two questions.
    The answers to these questions should be precise:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置`Access-Control-Allow-Origin`之前，您必须回答两个问题。这些问题的答案应该是精确的：
- en: Which resources are you sharing?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你分享哪些资源？
- en: Which origins are you sharing them with?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将它们与哪些来源分享？
- en: 'Use the `CORS_URLS_REGEX` setting to define shared resources by URL path pattern.
    As the name implies, this setting is a regular expression. The default value matches
    all URL paths. The following example matches any URL path starting with `shared_
    resources`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CORS_URLS_REGEX`设置来定义URL路径模式的共享资源。顾名思义，此设置是一个正则表达式。默认值匹配所有URL路径。以下示例匹配以`shared_resources`开头的任何URL路径：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note I recommend hosting all shared resources with a common URL path prefix.
    Furthermore, do not host unshared resources with this path prefix as well. This
    clearly communicates what is shared to two groups of people: other members of
    your team and resource consumers.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我建议使用共同的URL路径前缀托管所有共享资源。此外，不要使用此路径前缀托管未共享的资源。这清楚地传达了共享给两组人的内容：团队的其他成员和资源消费者。
- en: 'As you probably guessed, the value of the `Access-Control-Allow-Origin` should
    be as restrictive as possible. Use `*` if you are sharing resources publicly;
    use a single origin if you are sharing resources privately. The following settings
    configure the value of `Access-Control-Allow-Origin`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能猜到的那样，`Access-Control-Allow-Origin`的值应尽可能严格。如果您公开共享资源，则使用`*`；如果您私下共享资源，则使用单个来源。以下设置配置了`Access-Control-Allow-Origin`的值：
- en: '`CORS_ORIGIN_ALLOW_ALL`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CORS_ORIGIN_ALLOW_ALL`'
- en: '`CORS_ORIGIN_WHITELIST`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CORS_ORIGIN_WHITELIST`'
- en: '`CORS_ORIGIN_REGEX_WHITELIST`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CORS_ORIGIN_REGEX_WHITELIST`'
- en: Assigning `CORS_ORIGIN_ALLOW_ALL` to `True` sets `Access-Control-Allow-Origin`
    to `*`. This also disables the other two settings.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CORS_ORIGIN_ALLOW_ALL`设置为`True`会将`Access-Control-Allow-Origin`设置为`*`。这也会禁用其他两个设置。
- en: 'The `CORS_ORIGIN_WHITELIST` setting shares resources with one or more specific
    origins. If the origin of a request matches any item in this list, it becomes
    the value of the `Access-Control-Allow-Origin` header. For example, Bob would
    use the following configuration to share resources with sites owned by Alice and
    Charlie:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`CORS_ORIGIN_WHITELIST` 设置与一个或多个特定来源共享资源。如果请求的来源与列表中的任何项目匹配，它将成为 `Access-Control-Allow-Origin`
    头部的值。例如，鲍勃将使用以下配置与 Alice 和 Charlie 拥有的站点共享资源：'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Access-Control-Allow-Origin` header will not accommodate the entire list;
    it accepts only one origin. How does `django-cors-headers` know the origin of
    the request? If you guessed the `Referer` header, you are pretty close. Actually,
    the browser designates the request origin with a header named `Origin`. This header
    behaves like `Referer` but does not reveal the URL path.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Origin` 头部不会容纳整个列表；它只接受一个来源。`django-cors-headers` 如何知道请求的来源呢？如果你猜测是
    `Referer` 头部，你就很接近了。实际上，浏览器使用一个名为 `Origin` 的头部指定请求的来源。这个头部的行为类似于 `Referer` 但不会显示
    URL 路径。'
- en: 'The `CORS_ORIGIN_REGEX_WHITELIST` setting is analogous to `CORS_ORIGIN_WHITELIST`.
    As the name indicates, this setting is a list of regular expressions. If the origin
    of the request is matched by any expression in this list, it becomes the value
    of `Access-Control-Allow-Origin`. For example, Bob would use the following to
    share resources with all subdomains of alice.com:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`CORS_ORIGIN_REGEX_WHITELIST` 设置类似于 `CORS_ORIGIN_WHITELIST`。正如名称所示，这个设置是一个正则表达式列表。如果请求的来源与列表中的任何表达式匹配，它将成为
    `Access-Control-Allow-Origin` 的值。例如，鲍勃将使用以下设置与 alice.com 的所有子域共享资源：'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note You may be surprised to learn that WhiteNoise serves every static resource
    with an `Access-Control-Allow-Origin` header set to `*`. The original intent was
    to grant cross-origin access to static resources such as fonts. This should not
    be a problem as long as you are using WhiteNoise to serve public resources. If
    this is not the case, you can remove this behavior by setting `WHITENOISE_ALLOW_ALL_ORIGINS`
    to `False`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能会惊讶地发现 WhiteNoise 将每个静态资源都以 `Access-Control-Allow-Origin` 头部设置为 `*`。最初的目的是授予对静态资源（如字体）的跨域访问。只要您使用
    WhiteNoise 提供公共资源，这不应该成为问题。如果不是这种情况，您可以通过将 `WHITENOISE_ALLOW_ALL_ORIGINS` 设置为
    `False` 来移除此行为。
- en: In the next section, I cover use cases too complicated for `Access-Control-Allow-Origin`
    alone. I introduce you to several more response headers, two request headers,
    and a rarely used request method, `OPTIONS`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将介绍一些对于 `Access-Control-Allow-Origin` 单独来说过于复杂的用例。我向你介绍几个更多的响应头，两个请求头，以及一个很少使用的请求方法
    `OPTIONS`。
- en: 17.4 Preflight CORS requests
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.4 预检 CORS 请求
- en: Before I dive into this subject, I’m going to provide a little background about
    the problem it solves. Imagine it is 2003 and Charlie is building ballot.charlie.com.
    The /vote/ endpoint handles POST and PUT requests, allowing users to create and
    change their vote, respectively.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我深入讨论这个主题之前，我将提供一些关于它解决的问题的背景信息。想象一下是 2003 年，查理正在构建 ballot.charlie.com。/vote/
    端点处理 POST 和 PUT 请求，允许用户创建和更改他们的投票。
- en: Charlie knows that the SOP doesn’t block cross-origin form submission, so he
    guards his POST handler with `Referer` validation. This blocks malicious sites
    such as mallory.com from successfully submitting forged votes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查理知道 SOP 不会阻止跨域表单提交，因此他用 `Referer` 验证保护他的 POST 处理程序。这样可以阻止像 mallory.com 这样的恶意网站成功提交伪造的投票。
- en: Charlie also knows that the SOP does block cross-origin PUT requests, so he
    doesn’t bother guarding his PUT handler with `Referer` validation. He forgoes
    this layer of defense, relying on the fact that browsers block all cross-origin
    unsafe non-POST requests. Charlie completes ballot.charlie.com and pushes it to
    production.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 查理也知道 SOP 阻止跨域 PUT 请求，因此他不费力地用 `Referer` 验证保护他的 PUT 处理程序。他放弃了这一层防御，依赖于浏览器阻止所有跨域不安全的非
    POST 请求的事实。查理完成了 ballot.charlie.com 并将其推送到生产环境。
- en: CORS is born in the following year (2004). Over the next 10 years, it matures
    into a W3C Recommendation. During this time, the specification authors had to
    find a way to roll out CORS without endangering defenseless endpoints like Charlie’s
    PUT handler.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 在随后的一年（2004 年）诞生。在接下来的 10 年里，它发展成为 W3C 的推荐标准。在此期间，规范的作者们不得不找到一种方法来推出 CORS，而不危及像查理的
    PUT 处理程序这样的无防御的端点。
- en: Obviously, CORS couldn’t simply unleash cross-origin unsafe requests for a new
    generation of browsers. Older sites such as ballot.charlie.com would suffer a
    new wave of attacks. Inspecting a response header such as `Access-Control-Allow-Origin`
    couldn’t protect these sites because the attack would be finished before the browser
    received the response.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，CORS 不能简单地为新一代浏览器释放跨源不安全请求。旧站点如 ballot.charlie.com 将遭受新一波攻击。检查响应头部如 `Access-Control-Allow-Origin`
    无法保护这些站点，因为攻击会在浏览器接收到响应之前完成。
- en: CORS had to enable the browser to discover if the server was prepared *before*
    sending a cross-origin unsafe request. This discovery mechanism is called a *preflight
    request*. The browser sends a preflight request to determine whether it is safe
    to send a potentially harmful cross-origin resource request. In other words, the
    browser asks for permission instead of forgiveness. The original cross-origin
    resource request is sent only if the server responds favorably to the preflight
    request.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 必须使浏览器能够在发送跨源不安全请求之前发现服务器是否准备就绪。这种发现机制称为*预检请求*。浏览器发送预检请求以确定是否安全发送潜在有害的跨源资源请求。换句话说，浏览器请求权限而不是原谅。仅当服务器对预检请求作出积极响应时，原始的跨源资源请求才会被发送。
- en: The preflight request method is always `OPTIONS`. Like `GET` and `HEAD`, the
    `OPTIONS` method is safe. The browser automatically assumes all responsibility
    for sending the preflight request and processing the preflight response. Client-side
    code never deliberately performs these tasks. The next section examines a preflight
    request in more technical detail.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 预检请求方法始终是 `OPTIONS`。像 `GET` 和 `HEAD` 一样，`OPTIONS` 方法是安全的。浏览器自动承担发送预检请求和处理预检响应的所有责任。客户端代码从不故意执行这些任务。下一节将更详细地介绍预检请求。
- en: 17.4.1 Sending the preflight request
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.1 发送预检请求
- en: Suppose Bob wants to improve his social networking site with a new feature,
    anonymous comments. Anyone can say anything without consequence. Let’s see what
    happens.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Bob 想要通过一个新功能来改善他的社交网络网站，即匿名评论。任何人都可以毫无后果地说任何话。我们来看看会发生什么。
- en: Bob deploys social.bob.com/comment/, allowing anyone to create or update a comment.
    He then writes the JavaScript in listing 17.4 for his public website www.bob.com.
    This code lets the public anonymously comment on photos posted by his social network
    users.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 部署了 social.bob.com/comment/，允许任何人创建或更新评论。然后，他为他的公共网站 www.bob.com 编写了列表 17.4
    中的 JavaScript。这段代码让公众可以匿名评论他社交网络用户发布的照片。
- en: 'Notice two important details:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个重要细节：
- en: The `Content-Type` header is explicitly set to `application/json`. A cross-origin
    request with either of these properties requires a preflight request.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type` 头部明确设置为 `application/json`。带有这些属性之一的跨源请求需要预检请求。'
- en: www.bob.com sends the comment with a PUT request.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: www.bob.com 发送带有 PUT 请求的评论。
- en: 'In other words, this code sends two requests: the preflight request and the
    actual cross-origin resource request.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这段代码发送了两个请求：预检请求和实际的跨源资源请求。
- en: Listing 17.4 A web page from www.bob.com adds a comment to a photo
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.4 www.bob.com 的一个网页向照片添加评论
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Reads the comment from the DOM
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 DOM 中读取评论
- en: ❷ A preflight triggering Content-Type request header value
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 触发预检的 Content-Type 请求头值
- en: ❸ A preflight triggering request method
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个触发预检请求的方法
- en: Note If you want to understand CORS, let the headers tell the story.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 如果你想了解 CORS，请让头部告诉你故事。
- en: 'Here are some interesting headers of the preflight request. You learned about
    two of them previously. The `Host` header designates where the request is going;
    the `Origin` header designates where the request comes from. `Access-Control-Request-Headers`
    and `Access-Control-Request-Method`, shown in bold font, are CORS headers. The
    browser uses these headers to ask if the server is prepared for a PUT request
    bearing an atypical content type:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是预检请求的一些有趣的头部信息。你之前学过其中的两个。`Host` 头部指明了请求去向何处；`Origin` 头部指明了请求来自何处。以**粗体**显示的
    `Access-Control-Request-Headers` 和 `Access-Control-Request-Method` 是 CORS 头部。浏览器使用这些头部来询问服务器是否准备好接受携带非典型内容类型的
    PUT 请求：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are some interesting headers from the preflight response. `Access-Control-Allow-Headers`
    and `Access-Control-Allow-Methods` are replies to `Access-Control-Request-Headers`
    and `Access-Control-Request-Method`, respectively. These response headers communicate
    which methods and request headers Bob’s server can handle. This includes the PUT
    method and the `Content-Type` header, shown in bold font. You already know plenty
    about the third response header, `Access-Control-Allow-Origin`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预检响应中的一些有趣的标头。`Access-Control-Allow-Headers` 和 `Access-Control-Allow-Methods`
    是对 `Access-Control-Request-Headers` 和 `Access-Control-Request-Method` 的回复。这些响应标头通知
    Bob 的服务器可以处理哪些方法和请求标头。这包括 PUT 方法和加粗显示的 `Content-Type` 标头。关于第三个响应标头 `Access-Control-Allow-Origin`，您已经了解了很多：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, the browser is given permission to send the original cross-origin asynchronous
    PUT request. Figure 17.1 illustrates both requests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，浏览器被允许发送原始的跨源异步 PUT 请求。图 17.1 描绘了这两个请求。
- en: '![CH17_F01_Byrne](Images/CH17_F01_Byrne.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![CH17_F01_Byrne](Images/CH17_F01_Byrne.png)'
- en: Figure 17.1 A successful preflighted CORS request
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 成功的预检 CORS 请求
- en: 'So, exactly what conditions trigger a preflight request? Table 17.1 enumerates
    various triggers. If the browser discovers more than one trigger, it sends at
    most only one preflight request. Small browser differences do exist (see MDN Web
    Docs for the details: [http://mng.bz/0rKv](https://shortener.manning.com/0rKv)).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，究竟是什么条件触发了预检请求呢？表 17.1 枚举了各种触发器。如果浏览器发现多个触发器，则最多只发送一个预检请求。存在一些浏览器之间的小差异（有关详细信息，请参见
    MDN Web 文档：[http://mng.bz/0rKv](https://shortener.manning.com/0rKv)）。
- en: Table 17.1 Preflight request triggers
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17.1 预检请求触发器
- en: '| Request property | Trigger condition |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 请求属性 | 触发条件 |'
- en: '| method | The request method is anything other than GET, HEAD, or POST. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 请求方法不是 GET、HEAD 或 POST 之外的任何内容。 |'
- en: '| headers | The request contains a header that is neither safelisted or forbidden.
    The CORS specification defines safelisted request headers as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '| 标头 | 请求包含一个既不在安全列表中也不被禁止的标头。CORS 规范将安全列表请求标头定义如下：'
- en: Accept
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Accept
- en: Accept-Language
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Accept-Language
- en: Content-Language
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Content-Language
- en: Content-Type (further restrictions follow)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Content-Type（更多限制遵循）
- en: The CORS specification defines 20 forbidden headers, including Cookie, Host,
    Origin, and Referer [(https://fetch.spec.whatwg.org/#forbidden-header-name).](https://fetch.spec.whatwg.org/#forbidden-header-name)
    |
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 规范定义了 20 个被禁止的标头，包括 Cookie、Host、Origin 和 Referer [(https://fetch.spec.whatwg.org/#forbidden-header-name).](https://fetch.spec.whatwg.org/#forbidden-header-name)
    |
- en: '| Content-Type header | The Content-Type header is anything other than these:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '| 内容类型标头 | 内容类型标头除了以下内容之外都是其他：'
- en: application/x-www-form-urlencoded
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: application/x-www-form-urlencoded
- en: multipart/form-data
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: multipart/form-data
- en: text/plain
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: text/plain
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| ReadableStream | The browser requests a data stream via the Streams API.
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| ReadableStream | 浏览器通过流 API 请求数据流。 |'
- en: '| XMLHttpRequestUpload | The browser attaches an event listener to XMLHttpRequest.upload.
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| XMLHttpRequestUpload | 浏览器将事件侦听器附加到 XMLHttpRequest.upload。 |'
- en: As a resource consumer, you are not responsible for sending the preflight request;
    as a resource producer, you are responsible for sending the preflight response.
    The next section covers how to fine-tune various preflight response headers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为资源消费者，您不需要发送预检请求；作为资源生产者，您需要发送预检响应。下一节将介绍如何调整各种预检响应标头。
- en: 17.4.2 Sending the preflight response
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4.2 发送预检响应
- en: 'In this section, you’ll learn how to manage several preflight response headers
    with `django-cors-headers`. The first two headers were covered in the previous
    section:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 `django-cors-headers` 管理多个预检响应标头。前两个标头在前一节中已经涵盖了：
- en: '`Access-Control-Allow-Methods`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Methods`'
- en: '`Access-Control-Allow-Headers`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Headers`'
- en: '`Access-Control-Max-Age`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Access-Control-Max-Age`'
- en: 'The `CORS_ALLOW_METHODS` setting configures the `Access-Control-Allow-Methods`
    response header. The default value is a list of common HTTP methods, shown here.
    You should apply the principle of least privilege when configuring this value;
    allow only the methods you need:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`CORS_ALLOW_METHODS` 设置配置 `Access-Control-Allow-Methods` 响应标头。默认值是一个常见的 HTTP
    方法列表，如下所示。在配置此值时，您应该应用最小权限原则；只允许您需要的方法：'
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `CORS_ALLOW_HEADERS` setting configures the `Access-Control-Allow-Headers`
    response header. The default value for this setting is a list of common harmless
    request headers, shown here. `Authorization`, `Content-Type`, `Origin`, and `X-CSRFToken`
    have been covered previously in this book:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`CORS_ALLOW_HEADERS`设置配置了`Access-Control-Allow-Headers`响应头。此设置的默认值是一组常见的无害请求头，如下所示。`Authorization`、`Content-Type`、`Origin`和`X-CSRFToken`在本书中已经介绍过了：'
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Introduced alongside OAuth 2
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与 OAuth 2 同时引入
- en: ❷ Introduced alongside XSS
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 与 XSS 同时引入
- en: ❸ Introduced in this chapter
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在本章中引入
- en: ❹ Introduced alongside CSRF
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 与 CSRF 同时引入
- en: 'Extending this list with a custom request header doesn’t require copying the
    entire thing into your settings file. The following code demonstrates how to do
    this cleanly by importing the `default_headers` tuple:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义请求头扩展此列表不需要将整个内容复制到您的设置文件中。以下代码演示了如何通过导入`default_headers`元组来干净地执行此操作：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Access-Control-Max-Age` response header limits how long the preflight
    response is cached by the browser. This header is configured by the `CORS_PREFLIGHT
    _MAX_AGE` setting. The default value for this setting is `86400` (one day, in
    seconds):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Access-Control-Max-Age`响应头限制了浏览器缓存预检请求响应的时间。该头由`CORS_PREFLIGHT_MAX_AGE`设置配置。此设置的默认值为`86400`（一天，以秒为单位）：'
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Caching for a long time period may potentially complicate your releases. For
    example, suppose your server tells a browser to cache a preflight response for
    one day. Then you modify the preflight response in order to roll out a new feature.
    It could take up to one day before the browser can use the feature. I recommend
    setting `CORS_PREFLIGHT_MAX_AGE` to 60 seconds or less in production. This avoids
    a potential headache and the performance hit is typically negligible.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间缓存可能会增加您的发布复杂性。例如，假设您的服务器告诉浏览器将预检请求响应缓存一天。然后，您修改了预检请求响应以推出新功能。在浏览器可以使用该功能之前可能需要一天的时间。我建议在生产中将`CORS_PREFLIGHT_MAX_AGE`设置为60秒或更短。这样可以避免潜在的麻烦，而性能损失通常可以忽略不计。
- en: 'Debugging your way through local development issues is next to impossible when
    your browser is caching the preflight response. Do yourself a favor and assign
    `CORS_PREFLIGHT_MAX_AGE` to `1` in your development environment:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器缓存预检响应时，通过本地开发问题进行调试几乎是不可能的。为自己做个好事，在开发环境中将`CORS_PREFLIGHT_MAX_AGE`分配给`1`：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 17.5 Sending cookies across origins
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.5 跨源发送 cookies
- en: Bob realizes he made a big mistake. People are using anonymous comments to say
    really bad things to one another on his social networking site. Everyone is upset.
    He decides to replace anonymous comments with authenticated comments. From now
    on, requests to /comment/ must bear a valid session ID.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 意识到他犯了一个大错。人们正在使用匿名评论在他的社交网络站点上互相说一些非常不好的话。每个人都很不高兴。他决定用认证评论替换匿名评论。从现在开始，对/comment/的请求必须携带有效的会话ID。
- en: Unfortunately for Bob, each request from www.bob.com already omits the user’s
    session ID, even for users currently logged in to social.bob.com. By default,
    browsers omit cookies from cross-origin asynchronous requests. They also ignore
    cookies arriving from cross-origin asynchronous responses.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是对于 Bob，来自 www.bob.com 的每个请求已经省略了用户的会话ID，即使对于当前已登录到 social.bob.com 的用户也是如此。默认情况下，浏览器会省略跨源异步请求中的
    cookies。它们还会忽略来自跨源异步响应的 cookies。
- en: 'Bob adds the `Access-Control-Allow-Credentials` header to the /comment/ preflight
    response. Like other CORS headers, this one is designed to relax the SOP. Specifically,
    this header permits the browser to include credentials in the subsequent cross-origin
    resource request. Client-side credentials include cookies, authorization headers,
    and client TLS certificates. An example header is shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 将`Access-Control-Allow-Credentials`头添加到/comment/预检响应中。与其他 CORS 头一样，此头旨在放宽
    SOP。具体来说，此头允许浏览器在随后的跨源资源请求中包含凭据。客户端凭据包括 cookies、授权头和客户端 TLS 证书。以下是一个示例头：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `CORS_ALLOW_CREDENTIALS` setting instructs `django-cors-headers` to add
    this header to all CORS responses:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`CORS_ALLOW_CREDENTIALS`设置指示`django-cors-headers`将此头添加到所有 CORS 响应中：'
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Access-Control-Allow-Credentials` *allows* the browser to send cookies; it
    doesn’t *force* the browser to do anything. In other words, the server and browser
    must both opt in. `Access-Control-Allow-Credentials` is intended to be used in
    conjunction with `fetch(credentials)` or `XmlHttpRequest.withCredentials`. Finally,
    Bob adds one line of JavaScript to www.bob.com, shown here in bold font. Problem
    solved:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ An opt-in setting for sending and receiving cookies
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: I chose to isolate CORS and CSRF from each other in this book. I also chose
    to present these topics back-to-back because CORS and CSRF resistance are often
    confused for each other. Despite some overlap, these subjects are not the same.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 17.6 CORS and CSRF resistance
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the confusion between CORS and CSRF is to be expected. Both topics
    fall under web security; both topics apply to traffic between websites. These
    similarities are overshadowed by many differences:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: CORS headers cannot resist common forms of CSRF.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSRF resistance cannot relax the same-origin policy.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CORS is a W3C Recommendation; CSRF protection is unstandardized.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request forgery requires a session ID; resource sharing does not.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CORS is no substitute for CSRF resistance. In chapter 16, you saw Mallory trick
    Alice into submitting a hidden form from mallory.com to admin.alice.com. The SOP
    does not regulate this kind of request. There is no way to stop attacks like this
    with CORS headers. CSRF resistance is the only way.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, CSRF resistance is no substitute for CORS. In this chapter, you saw
    Bob use CORS to relax the SOP, sharing a /trending/ resource with https:/./alice.com.
    Conversely, no form of CSRF resistance would have allowed Bob to relax the SOP.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, CORS is a W3C Recommendation. This standard has been implemented
    in a relatively uniform manner by every browser and countless server-side frameworks,
    including `django-cors-headers`. There is no equivalent for CSRF resistance. Django,
    Ruby on Rails, ASP.NET, and every other web framework is free to resist CSRF in
    its own unique way.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a successful forged request must bear a valid session ID; the user
    must be logged in. Conversely, many successful CORS requests do not, and should
    not, bear a session ID. In this chapter, you saw Google share a font with Alice
    even though she was not logged in to Google. Bob originally shared /trending/
    with www.bob.com users even though many of them were not logged in to social.bob.com.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In short, the purpose of CSRF resistance is to reject unintentional malicious
    requests for the sake of safety. The purpose of CORS is to accept intentional
    requests to support feature functionality. In the next chapter, I cover clickjacking,
    yet another topic that is confused with CSRF and CORS.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The internet would be a very dangerous place without the SOP.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CORS can be thought of as a way to relax the SOP.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple CORS use cases are accommodated by `Access-Control-Allow-Origin`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser precedes a potentially harmful CORS request with a preflight request.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器在可能有害的CORS请求之前会发送一个预检请求。
- en: Host all shared resources with a common URL path prefix.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有共享资源托管在具有共同URL路径前缀的主机上。
