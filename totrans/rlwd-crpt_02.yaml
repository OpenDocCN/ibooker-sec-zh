- en: 1 Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 引言
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What cryptography is about
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学的内涵
- en: Theoretical versus real-world cryptography
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理论与现实中的密码学
- en: What you’ll learn throughout this adventure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将在这次冒险中学到什么
- en: Greetings, traveler; sit tight. You’re about to enter a world of wonder and
    mystery—the world of cryptography. *Cryptography* is the ancient discipline of
    securing situations that are troubled with malicious characters. This book includes
    the spells that we need to defend ourselves against the malice. Many have attempted
    to learn this craft, but few have survived the challenges that stand in the way
    of mastery. Exciting adventures await, indeed!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 问候，旅行者；坐稳了。你即将进入一个充满奇迹和神秘的世界——密码学的世界。*密码学*是一门古老的学科，旨在保护受到恶意人物侵扰的情况。这本书包括了我们需要防御自己免受恶意的咒语。许多人尝试学习这门技艺，但很少有人能在掌握之前生存下来，因为掌握这门技艺面临着重重挑战。的确，令人兴奋的冒险在等待着！
- en: In this book, we’ll uncover how cryptographic algorithms can secure our letters,
    identify our allies, and protect treasures from our enemies. Sailing through the
    cryptographic sea will not be the smoothest journey as cryptography is the foundation
    of all security and privacy in our world—the slightest mistake could be deadly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将揭示密码算法如何保护我们的信件，识别我们的盟友，并保护我们的宝藏免受敌人的侵害。穿越密码学的海洋将不会是一次最顺利的旅程，因为密码学是我们世界安全和隐私的基础——最轻微的错误都可能致命。
- en: Note If you find yourself lost, remember to keep moving forward. It will all
    eventually make sense.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 如果你发现自己迷失了方向，请记得继续向前走。一切最终都会变得清晰起来。
- en: '![](../Images/01_001_UN01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_001_UN01.jpg)'
- en: 1.1 Cryptography is about securing protocols
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 密码学是关于保护协议的
- en: 'Our journey starts with an introduction to cryptography, the science aiming
    to defend protocols against saboteurs. But first, what’s a *protocol*? Simply
    put, it’s a list of steps that one (or more people) must follow in order to achieve
    something. For example, imagine the following premise: you want to leave your
    magic sword unattended for a few hours so you can take a nap. One protocol to
    do this could be the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程从介绍密码学开始，这是一门旨在防御协议免受破坏者侵害的科学。但首先，什么是*协议*？简单来说，它是一个（或多个人）必须遵循一系列步骤以实现某事的步骤列表。例如，想象一下以下假设：你想将你的魔剑无人看管几个小时，这样你就可以小睡一会儿。一个做到这一点的协议可能是这样的：
- en: Deposit weapon on the ground
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将武器放在地上
- en: Take nap under a tree
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在树下小睡一会儿
- en: Recover weapon from the ground
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从地上取回武器
- en: Of course, it’s not a great protocol as anybody can steal your sword while you’re
    napping . . . And so, cryptography is about taking into account the adversaries
    who are looking to take advantage of you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是一个很好的协议，因为任何人都可以在你小睡时偷走你的剑……因此，密码学是考虑到那些想要利用你的对手的。
- en: In ancient times, when rulers and generals were busy betraying each other and
    planning coups, one of their biggest problems was finding a way to *share confidential
    information with those they trusted*. From here, the idea of cryptography was
    born. It took centuries and hard work before cryptography became the serious discipline
    it is today. Now, it’s used all around us to provide the most basic services in
    the face of our chaotic and adverse world.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在古代，当统治者和将军们忙于背叛彼此和策划政变时，他们最大的问题之一就是如何*与他们信任的人分享机密信息*。从这里，密码学的概念诞生了。经过几个世纪的努力和辛勤工作，密码学才成为今天严肃的学科。现在，它在我们周围被广泛使用，以在我们混乱和不利的世界中提供最基本的服务。
- en: The story of this book is about the practice of cryptography. It takes you on
    an expedition throughout the computing world to cover cryptographic protocols
    in use today; it also shows you what parts they are made of and how everything
    fits together. While a typical cryptography book usually starts with the discovery
    of cryptography and takes you through its history, I think that it makes little
    sense for me to kick off things that way. I want to tell you about the practical.
    I want to tell you about what I’ve witnessed myself, reviewing cryptographic applications
    for large companies as a consultant, or the cryptography I’ve made use of myself
    as an engineer in the field.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的故事是关于密码学的实践。它带领你在整个计算机世界中进行探险，介绍了当今正在使用的密码协议；它还向你展示了它们由什么部分组成以及如何组合在一起。虽然一本典型的密码学书通常是从密码学的发现开始，然后带你穿越它的历史，但我认为用这种方式开始事情没有太多意义。我想告诉你实用的东西。我想告诉你我亲眼所见的，作为一家大公司的顾问审查密码应用，或者作为领域工程师自己使用的密码学。
- en: There will be (almost) no scary math formulas. The purpose of this book is to
    demystify cryptography, survey what is considered useful nowadays, and provide
    intuition about how things around you are built. This book is intended for curious
    people, interested engineers, adventurous developers, and inquisitive researchers.
    Chapter 1, this chapter, initiates a tour of the world of cryptography. We will
    discover the different types of cryptography, which ones matter to us, and how
    the world agreed on using these.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎不会有可怕的数学公式。本书的目的是揭示密码学的神秘，调查当今被认为有用的内容，并提供关于你周围事物是如何构建的直觉。本书面向对此感兴趣的人，有冒险精神的工程师，冒险的开发者和好奇的研究人员。第1章，本章，开始了对密码学世界的探索之旅。我们将发现不同类型的密码学，哪些对我们重要，以及世界是如何同意使用这些的。
- en: '1.2 Symmetric cryptography: What is symmetric encryption?'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 对称加密：什么是对称加密？
- en: One of the fundamental concepts of cryptography is *symmetric encryption*. It
    is used in a majority of cryptographic algorithms in this book, and it is, thus,
    extremely important. I introduce this new concept here via our first protocol.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学的一个基本概念是*对称加密*。它在本书中的大多数密码算法中使用，因此非常重要。我通过我们的第一个协议在这里介绍这个新概念。
- en: Let’s imagine that Queen Alice needs to send a letter to Lord Bob, who lives
    a few castles away. She asks her loyal messenger to ride his trusty steed and
    battle his way through the dangerous lands ahead in order to deliver the precious
    message to Lord Bob. Yet, she is suspicious; even though her loyal messenger has
    served her for many years, she wishes the message in transit to remain secret
    from all passive observers, including the messenger! You see, the letter most
    likely contains some controversial gossip about the kingdoms on the way.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，女王爱丽丝需要给住在几个城堡之外的鲍勃勋爵发送一封信。她请求她忠诚的信使骑着他可靠的坐骑，冒着前方危险的土地，为了将珍贵的消息送到鲍勃勋爵手中。然而，她心存疑虑；即使她的忠诚信使为她服务多年，她希望在传输过程中的消息对所有被动观察者保密，包括信使！你看，这封信很可能包含了一些关于途中王国的有争议的八卦。
- en: '![](../Images/01_001_UN02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_001_UN02.jpg)'
- en: What Queen Alice needs is a protocol that mimics handing the message to Lord
    Bob herself with no middlemen. This is quite an impossible problem to solve in
    practice unless we introduce cryptography (or teleportation) into the equation.
    This is what we ended up doing ages ago by inventing a new type of cryptographic
    algorithm—called a *symmetric encryption algorithm* (also known as a *cipher*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 女王爱丽丝需要的是一个模拟将消息直接交给鲍勃勋爵而没有中间人的协议。这在实践中是一个几乎不可能解决的问题，除非我们引入密码学（或者传送）到方程中。这就是我们很久以前通过发明一种新类型的加密算法——称为*对称加密算法*（也称为*密码*）来解决的问题。
- en: Note By the way, a type of cryptographic algorithm is often referred to as a
    *primitive*. You can think of a primitive as the smallest, useful construction
    you can have in cryptography, and it is often used with other primitives in order
    to build a protocol. It is mostly a term and has no particularly important meaning,
    although it appears often enough in the literature that it is good to know about
    it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，一种加密算法通常被称为*原语*。你可以把原语看作是密码学中最小的、有用的构造，通常与其他原语一起使用以构建协议。这主要是一个术语，没有特别重要的意义，尽管它在文献中经常出现，但了解它是很好的。
- en: 'Let’s see how we can use an encryption primitive to hide Queen Alice’s message
    from the messenger. Imagine for now that the primitive is a black box (we can’t
    see what’s inside or what it’s doing internally) that provides two functions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用加密原语来隐藏女王爱丽丝的消息免受信使的干扰。现在想象一下，这个原语是一个黑匣子（我们看不到里面或者它内部在做什么），提供两个函数：
- en: ENCRYPT
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ENCRYPT
- en: DECRYPT
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DECRYPT
- en: The first function, ENCRYPT, works by taking a *secret key* (usually a large
    number) and a *message*. It then outputs a series of random-looking numbers, some
    noisy data if you will. We will call that output the encrypted message. I illustrate
    this in figure 1.1.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数，ENCRYPT，通过取一个*秘钥*（通常是一个大数）和一个*消息*来工作。然后输出一系列看起来像随机数的数字，一些嘈杂的数据。我们将称这个输出为加密消息。我在图1.1中说明了这一点。
- en: '![](../Images/01_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_01.jpg)'
- en: Figure 1.1 The ENCRYPT function takes a message and a secret key and outputs
    the encrypted message—a long series of numbers that look like random noise.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 ENCRYPT函数接受一个消息和一个秘钥，并输出加密消息——一长串看起来像随机噪音的数字。
- en: The second function, DECRYPT, is the inverse of the first one. It takes the
    same secret key and the random output of the first function (the encrypted message)
    and then it finds the original message. I illustrate this in figure 1.2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数DECRYPT是第一个函数的反函数。它使用相同的秘钥和第一个函数的随机输出（加密的消息），然后找到原始消息。我在图1.2中进行了说明。
- en: '![](../Images/01_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_02.jpg)'
- en: Figure 1.2 The DECRYPT function takes an encrypted message and a secret key
    and returns the original message.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 DECRYPT函数接收一个加密的消息和一个秘钥，并返回原始消息。
- en: To make use of this new primitive, Queen Alice and Lord Bob have to first meet
    in real life and decide on what secret key to use. Later, Queen Alice can use
    the provided ENCRYPT function to protect a message with the help of the secret
    key. She then passes the encrypted message to her messenger, who eventually delivers
    it to Lord Bob. Lord Bob then uses the DECRYPT function on the encrypted message
    with the same secret key to recover the original message. Figure 1.3 shows this
    process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新的原语，女王艾丽斯和鲍勃勋爵必须首先在现实生活中见面并决定使用什么秘钥。稍后，女王艾丽斯可以使用提供的ENCRYPT函数，借助秘钥保护消息。然后，她将加密的消息传递给她的信使，最终将其传递给鲍勃勋爵。然后，鲍勃勋爵使用相同的秘钥对加密的消息使用DECRYPT函数来恢复原始消息。图1.3显示了这个过程。
- en: '![](../Images/01_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_03.jpg)'
- en: Figure 1.3 (1) Alice uses the ENCRYPT function with a secret key to transform
    her message into noise. (2) She then passes the encrypted message to her messenger,
    who will not learn anything about the underlying message. (3) Once Bob receives
    the encrypted message, he can recover the original content by using the DECRYPT
    function with the same secret key Alice used.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3（1）艾丽斯使用带有秘钥的ENCRYPT函数将她的消息转换为噪音。（2）然后她将加密的消息传递给她的信使，后者不会了解到底层消息的任何信息。（3）一旦鲍勃收到加密的消息，他可以使用与艾丽斯相同的秘钥使用DECRYPT函数来恢复原始内容。
- en: During this exchange, all the messenger had was something that looked random
    and that provided no meaningful insight into the content of the hidden message.
    Effectively, we augmented our insecure protocol into a secure one, thanks to the
    help of cryptography. The new protocol makes it possible for Queen Alice to deliver
    a confidential letter to Lord Bob without anyone (except Lord Bob) learning the
    content of it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个交换过程中，信使所拥有的只是看起来随机的东西，它对隐藏消息的内容没有任何有意义的见解。实际上，借助密码学的帮助，我们将我们的不安全协议增强为安全协议。新的协议使女王艾丽斯能够向鲍勃勋爵发送一封机密信件，而没有任何人（除了鲍勃勋爵）了解其内容。
- en: The process of using a secret key to render things to noise, making them indistinguishable
    from random, is a common way of securing a protocol in cryptography. You will
    see more of this as you learn more cryptographic algorithms in the next chapters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用秘钥将事物渲染成噪音，使其与随机无法区分的过程，在密码学中是一种常见的安全协议保护方式。随着你在接下来的章节中学习更多密码算法，你会看到更多这样的内容。
- en: By the way, symmetric encryption is part of a larger category of cryptography
    algorithms called *symmetric cryptography* or *secret key cryptography*. This
    is due to the same key being used by the different functions exposed by the cryptographic
    primitive. As you will see later, sometimes there’s more than one key.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，对称加密是密码学算法的一个更大类别的一部分，称为*对称密码学*或*秘密密钥密码学*。这是由于密码原语暴露的不同函数使用相同的密钥。后面你会看到，有时会有不止一个密钥。
- en: '1.3 Kerckhoff’s principle: Only the key is kept secret'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 克尔克霍夫原则：只有密钥是保密的
- en: To design a cryptographic algorithm (like our encryption primitive) is an easy
    task, but to design a *secure* cryptographic algorithm is not for the faint of
    heart. While we shy away from creating such algorithms in this book, we *do* learn
    how to recognize the good ones. This can be difficult as there is more choice
    than one can ask for the task. Hints can be found in the repeated failures of
    the history of cryptography, as well as the lessons that the community has learned
    from them. As we take a look at the past, we will grasp at what turns a cryptographic
    algorithm into a trusted-to-be-secure one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个密码算法（就像我们的加密原语）是一件容易的事情，但设计一个*安全*的密码算法并不是胆小之人能够做到的。虽然我们在这本书中避免创建这样的算法，但我们*确实*学会了如何识别优秀的算法。这可能会很困难，因为选择太多，超出了任务所需。在密码学的历史中反复失败的经验教训以及社区从中学到的教训中可以找到一些提示。当我们回顾过去时，我们将领会到什么将密码算法变成一个值得信赖的安全算法。
- en: 'Hundreds of years have passed and many queens and lords have been buried. Since
    then, paper has been abandoned as our primary means of communication in favor
    of better and more practical technologies. Today, we have access to powerful computers
    as well as the internet. More practical, sure, but this also means that our previous
    malicious messenger has become much more powerful. He is now everywhere: the Wi-Fi
    in the Starbucks cafe you’re sitting in, the different servers making up the internet
    and forwarding your messages, and even in the machines running our algorithms.
    Our enemies are now able to observe many more messages as each request you make
    to a website might pass through the wrong wire and become altered or copied in
    a matter of nanoseconds without anyone noticing.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数百年过去了，许多皇后和领主被埋葬了。从那时起，纸张被放弃作为我们主要的交流方式，转而采用更好更实用的技术。如今，我们可以接触到强大的计算机以及互联网。更实用，当然，但这也意味着我们之前的恶意传送者变得更加强大。他现在无处不在：你所在的星巴克咖啡厅的Wi-Fi、构成互联网并转发你的消息的不同服务器，甚至在运行我们算法的机器上。我们的敌人现在能够观察到更多的消息，因为你向网站发出的每个请求都可能通过错误的线路，并在几纳秒内被改变或复制，而没有人注意到。
- en: Before us, we can see that recent history contains many instances of encryption
    algorithms falling apart, being broken by secret state organizations or by independent
    researchers, and failing to protect their messages or accomplish their claims.
    Many lessons were learned, and we slowly came to understand how to produce good
    cryptography.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前，我们可以看到最近的历史中有许多加密算法失效的例子，被秘密国家组织或独立研究人员破解，并未能保护其消息或实现其声明。我们吸取了许多教训，并逐渐了解了如何制造良好的密码学。
- en: 'Note A cryptographic algorithm can be considered *broken* in many ways. For
    an encryption algorithm, you can imagine several ways to attack the algorithm:
    the secret key can be leaked to the attacker, messages can be decrypted without
    the help of the key, some information about the message can be revealed just by
    looking at the encrypted message, and so on. Anything that would somehow weaken
    the assumptions we made about the algorithm could be considered a break.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，密码算法可以通过多种方式被视为*破解*。对于加密算法，你可以想象到多种攻击算法的方法：秘密密钥可以泄露给攻击者，消息可以在没有密钥的情况下解密，仅通过查看加密消息就可以透露一些关于消息的信息，等等。任何会削弱我们对算法做出的假设的事情都可以被视为破解。
- en: 'A strong notion came out of the long process of trial and error that cryptography
    went through: to obtain confidence in the security claims made by a cryptographic
    primitive, the primitive has to be analyzed in the open by experts. Short of that,
    you are relying on *security through obscurity*, which hasn’t worked well historically.
    This is why *cryptographers* (the people who build) usually use the help of *cryptanalysts*
    (the people who break) in order to analyze the security of a construction. (Although
    cryptographers are often cryptanalysts themselves and vice-versa.)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学经历了漫长的试验和错误过程后，产生了一个强有力的概念：要对密码原语所声称的安全性进行信任，就必须由专家公开分析该原语。否则，你就是在依赖*安全性通过模糊性*，这在历史上并不奏效。这就是为什么*密码学家*（构建者）通常会寻求*密码分析家*（破解者）的帮助来分析一个构造的安全性。（尽管密码学家经常自己也是密码分析家，反之亦然。）
- en: '![](../Images/01_03_UN03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_03_UN03.jpg)'
- en: Let’s take the Advanced Encryption Standard (AES) encryption algorithm as an
    example. AES was the product of an international competition organized by the
    National Institute of Standards and Technology (NIST).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以高级加密标准（AES）加密算法为例。AES是由美国国家标准与技术研究院（NIST）组织的国际竞赛的产物。
- en: Note NIST is a United States agency whose role is to define standards and develop
    guidelines for use in government-related functions as well as other public or
    private organizations. Like AES, it has standardized many widely used cryptographic
    primitives.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，NIST是一个美国机构，其角色是定义政府相关职能以及其他公共或私营组织使用的标准并制定指南。像AES一样，它标准化了许多广泛使用的密码原语。
- en: The AES competition lasted several years, during which many volunteering cryptanalysts
    from around the world gathered to take a chance at breaking the various candidate
    constructions. After several years, once enough confidence was built by the process,
    a single competing encryption algorithm was nominated to become the Advanced Encryption
    Standard itself. Nowadays, most people trust that AES to be a solid encryption
    algorithm, and it is widely used to encrypt almost anything. For example, you
    use it every day when you browse the web.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: AES竞赛持续了数年，期间来自世界各地的许多志愿密码分析师聚集在一起，试图打破各种候选结构。几年后，通过这个过程建立了足够的信心后，一个单一的竞争性加密算法被提名为成为高级加密标准本身。现在，大多数人相信AES是一种可靠的加密算法，并且被广泛用于几乎所有的加密。例如，当你浏览网页时，你每天都在使用它。
- en: 'The idea to build cryptographic standards in the open is related to a concept
    often referred to as *Kerckhoffs’ principle*, which can be understood as something
    like this: it would be foolish to rely on our enemies not to discover what algorithms
    we use because they most likely will. Instead, let’s be open about them.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在公开建立加密标准的想法与一个经常被称为*Kerckhoffs' principle*的概念有关，可以理解为这样一种情况：依赖于我们的敌人不会发现我们使用的算法是愚蠢的，因为他们很可能会发现。相反，让我们对此持开放态度。
- en: 'If the enemies of Queen Alice and Lord Bob knew exactly how they were encrypting
    messages, how is their encryption algorithm secure? The answer is the *secret
    key*! The secrecy of the key makes the protocol secure, not the secrecy of the
    algorithm itself. This is a common theme in this book: all the cryptographic algorithms
    that we will learn about and that are used in the real world are most often free
    to be studied and used. Only the secret keys used as input to these algorithms
    are kept secret. *Ars ipsi secreta magistro* (an art secret even for the master),
    said Jean Robert du Carlet in 1644\. In the next section, I will talk about a
    totally different kind of cryptographic primitive. For now, let’s use figure 1.4
    to organize what we’ve learned so far.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果女王艾丽斯和鲍勃勋爵的敌人确切地知道他们是如何加密消息的，那么他们的加密算法如何安全？答案是*秘钥*！秘钥的保密性使得协议安全，而不是算法本身的保密性。这是本书的一个常见主题：我们将要学习的所有加密算法，以及实际世界中使用的加密算法，大多数情况下是可以自由学习和使用的。只有作为这些算法输入的秘钥是保密的。1644年，让·罗伯特·迪·卡莱特（Jean
    Robert du Carlet）说：“*Ars ipsi secreta magistro*”（即使对于大师来说也是秘密的艺术）。在接下来的部分中，我将谈论一种完全不同类型的密码原语。现在，让我们使用图1.4来整理我们迄今为止学到的知识。
- en: '![](../Images/01_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_04.jpg)'
- en: Figure 1.4 The cryptographic algorithms you have learned so far. AES is an instantiation
    of a symmetric encryption algorithm, which is a cryptographic primitive that is
    part of the broader class of symmetric cryptographic algorithms.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 到目前为止你学到的密码算法。AES是对称加密算法的一个实例，它是更广泛的对称加密算法类别的一部分。
- en: '1.4 Asymmetric cryptography: Two keys are better than one'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 非对称加密：两把钥匙比一把好
- en: 'In our discussion about symmetric encryption, we said that Queen Alice and
    Lord Bob first met to decide on a symmetric key. This is a plausible scenario,
    and a lot of protocols actually do work like this. Nonetheless, this quickly becomes
    less practical in protocols with many participants: do we need our web browser
    to meet with Google, Facebook, Amazon, and the other billions of websites before
    securely connecting to those?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关于对称加密的讨论中，我们说女王艾丽斯和鲍勃勋爵首先见面商定一个对称秘钥。这是一个合理的情景，实际上很多协议确实是这样工作的。然而，在有许多参与者的协议中，这很快就变得不太实际：我们需要我们的网络浏览器与谷歌、Facebook、亚马逊以及其他数十亿个网站见面，然后才能安全地连接到它们吗？
- en: This problem, often referred to as *key distribution*, has been a hard one to
    solve for quite a long time, at least until the discovery in the late 1970s of
    another large and useful category of cryptographic algorithms called *asymmetric
    cryptography* or *public key cryptography*. Asymmetric cryptography generally
    makes use of different keys for different functions (as opposed to a single key
    used in symmetric cryptography) or provides different points of view to different
    participants. To illustrate what this means and how public key cryptography helps
    to set up trust between people, I’ll introduce a number of asymmetric primitives
    in this section. Note that this is only a glance of what you’ll learn in this
    book as I’ll talk about each of these cryptographic primitives in more detail
    in subsequent chapters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题，通常称为*密钥分配*，在很长一段时间内一直很难解决，至少直到20世纪70年代末另一类大而有用的密码算法被发现，称为*非对称密码学*或*公钥密码学*。非对称密码学通常使用不同的密钥来执行不同的功能（与对称密码学中使用的单个密钥相对），或者为不同的参与者提供不同的观点。为了说明这意味着什么以及公钥密码学如何帮助建立人与人之间的信任，我将在本节中介绍一些非对称原语。请注意，这只是你将在本书中学到的内容的一个概述，因为我将在随后的章节中更详细地讨论这些密码原语中的每一个。
- en: 1.4.1 Key exchanges or how to get a shared secret
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 密钥交换或如何获得共享秘密
- en: The first asymmetric cryptography primitive we’ll look at is the *key exchange*.
    The first public key algorithm discovered and published was a key exchange algorithm
    named after its authors, Diffie-Hellman (DH). The DH key exchange algorithm’s
    main purpose is to establish a common secret between two parties. This common
    secret can then be used for different purposes (for example, as a key to a symmetric
    encryption primitive).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的第一个非对称密码学原语是*密钥交换*。首次发现并发布的公钥算法是一种以其作者命名的密钥交换算法，称为Diffie-Hellman（DH）。DH密钥交换算法的主要目的是在两个参与方之间建立一个共同的秘密。然后可以将这个共同的秘密用于不同的目的（例如，作为对称加密原语的密钥）。
- en: In chapter 5, I will explain how Diffie-Hellman works, but for this introduction,
    let’s use a simple analogy in order to understand what a key exchange provides.
    Like many algorithms in cryptography, a key exchange must start with the participants
    using a common set of parameters. In our analogy, we will simply have Queen Alice
    and Lord Bob agree to use a square (■). The next step is for them to choose their
    own random shape. Both of them go to their respective secret place, and out of
    sight, Queen Alice chooses a triangle (▲) and Lord Bob chooses a star (★). The
    objects they chose need to remain secret at all costs! These objects represent
    their *private keys* (see figure 1.5).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我将解释Diffie-Hellman的工作原理，但在此简介中，让我们使用一个简单的类比来理解密钥交换提供了什么。像密码学中的许多算法一样，密钥交换必须从参与者使用的一组共同参数开始。在我们的类比中，我们简单地让Alice女王和Bob勋爵同意使用一个正方形（■）。接下来的步骤是让他们选择自己的随机形状。他们俩都去各自的秘密地点，在不被看到的情况下，Alice女王选择了一个三角形（▲），而Bob勋爵选择了一个星形（★）。他们选择的对象必须以任何代价保持秘密！这些对象代表他们的*私钥*（见图1.5）。
- en: '![](../Images/01_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![01_05.jpg](../Images/01_05.jpg)'
- en: Figure 1.5 The first step of a DH (Diffie-Hellman) key exchange is to have both
    participants generate a private key. In our analogy, Queen Alice chooses a triangle
    as her private key, whereas Lord Bob chooses a star as his private key.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 DH（Diffie-Hellman）密钥交换的第一步是让两个参与者生成一个私钥。在我们的类比中，Alice女王选择一个三角形作为她的私钥，而Bob勋爵选择一个星形作为他的私钥。
- en: Once they chose their private keys, they both individually combine their secret
    shape with the common shape they initially agreed on using (the square). The combinations
    result in unique shapes representing their *public keys*. Queen Alice and Lord
    Bob can now exchange their public keys (hence the name *key exchange*) because
    public keys are considered public information. I illustrate this in figure 1.6.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们选择了他们的私钥，他们都会单独将他们的秘密形状与他们最初同意使用的共同形状（正方形）相结合。这些组合产生了代表他们的*公钥*的独特形状。Alice女王和Bob勋爵现在可以交换他们的公钥（因此称为*密钥交换*），因为公钥被视为公共信息。我在图1.6中说明了这一点。
- en: '![](../Images/01_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![01_06.jpg](../Images/01_06.jpg)'
- en: Figure 1.6 The second step of a DH key exchange where both participants exchange
    their public keys. Participants derive their public keys by combining their private
    keys with a common shape.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 DH密钥交换的第二步，两个参与者交换他们的公钥。参与者通过将他们的私钥与一个共同形状相结合来导出他们的公钥。
- en: 'We are now starting to see why this algorithm is called a public key algorithm.
    It is because it requires a *key pair* comprised of a private key and a public
    key. The final step of the DH key exchange algorithm is quite simple: Queen Alice
    takes Lord Bob’s public key and combines it with her private key. Lord Bob does
    the same with Queen Alice’s public key and combines it with his own private key.
    The result should now be the same on each side; in our example, a shape combining
    a star, a square, and a triangle (see figure 1.7).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始看到为什么这个算法被称为公钥算法。这是因为它需要一个由私钥和公钥组成的 *密钥对*。DH 密钥交换算法的最后一步非常简单：Alice 女王取
    Bob 男爵的公钥并与她的私钥结合。Bob 男爵也同样对待 Alice 女王的公钥，并将其与自己的私钥结合。结果现在应该在每一方都是相同的；在我们的示例中，是一个形状结合了星形、正方形和三角形（见图
    1.7）。
- en: '![](../Images/01_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_07.jpg)'
- en: Figure 1.7 The final step of a DH key exchange where both participants produce
    the same shared secret. To do this, Queen Alice combines her private key with
    Lord Bob’s public key, and Lord Bob combines his private key with Queen Alice’s
    public key. The shared secret cannot be obtained from solely observing the public
    keys.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 DH 密钥交换的最后一步，两个参与者产生相同的共享密钥。为此，Alice 女王将她的私钥与 Bob 男爵的公钥结合，而 Bob 男爵则将他的私钥与
    Alice 女王的公钥结合。仅观察公钥无法获取共享密钥。
- en: It is now up to the participants of the protocol to make use of this shared
    secret. You will see several examples of this in this book, but the most obvious
    scenario is to make use of it in an algorithm that requires a shared secret. For
    example, Queen Alice and Lord Bob could now use the shared secret as a key to
    encrypt further messages with a symmetric encryption primitive. To recap
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由协议参与者决定如何使用这个共享密钥。在本书中，你会看到几个示例，但最明显的场景是在需要共享密钥的算法中使用它。例如，Alice 女王和 Bob 男爵现在可以使用共享密钥作为对称加密原语进一步加密消息的密钥。概括一下
- en: Alice and Bob exchange their public keys, which masks their respective private
    keys.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 和 Bob 交换他们的公钥，这掩盖了他们各自的私钥。
- en: With the other participant’s public key and their respective private key, they
    can compute a shared secret.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一方的公钥和各自的私钥，他们可以计算出一个共享密钥。
- en: An adversary who observes the exchange of public keys doesn’t have enough information
    to compute the shared secret.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察公钥交换的对手没有足够的信息来计算共享密钥。
- en: Note In our example, the last point is easily bypassable. Indeed, without the
    knowledge of any private keys, we can combine the public keys together to produce
    the shared secret. Fortunately, this is only a limitation of our analogy, but
    it works well enough for us to understand what a key exchange does.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 在我们的示例中，最后一点很容易被绕过。实际上，在没有任何私钥知识的情况下，我们可以将公钥组合在一起生成共享密钥。幸运的是，这只是我们比喻的一个局限性，但它足以帮助我们理解密钥交换的作用。
- en: In practice, a DH key exchange is quite insecure. Can you take a few seconds
    to figure out why?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，DH 密钥交换非常不安全。你能花几秒钟想出为什么吗？
- en: Because Queen Alice accepts any public key she receives as being Lord Bob’s
    public key, I could intercept the exchange and replace it with mine, which would
    allow me to impersonate Lord Bob to Queen Alice (and the same can be done to Lord
    Bob). We say that a *man-in-the-middle* (MITM) attacker can successfully attack
    the protocol. How do we fix this? We will see in later chapters that we either
    need to augment this protocol with another cryptographic primitive, or we need
    to be aware in advance of what Lord Bob’s public key is. But then, aren’t we back
    to square one?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Alice 女王接受她收到的任何公钥都是 Bob 男爵的公钥，所以我可以拦截交换并用我的公钥替换它，这样我就可以冒充 Bob 男爵向 Alice
    女王发起攻击（同样也可以对 Bob 男爵进行相同操作）。我们称之为 *中间人* （MITM）攻击者可以成功攻击协议。我们如何解决这个问题？在后面的章节中，我们将看到我们要么需要用另一个加密原语增强此协议，要么需要事先知道
    Bob 男爵的公钥是什么。但那样的话，我们不是回到了原点吗？
- en: Previously, Queen Alice and Lord Bob needed to know a shared secret; now Queen
    Alice and Lord Bob need to know their respective public keys. How do they get
    to know that? Is that a chicken-and-egg problem all over again? Well, kind of.
    As we will see, in practice, public key cryptography does not solve the problem
    of trust, but it simplifies its establishment (especially when the number of participants
    is large).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，Alice 女王和 Bob 男爵需要知道一个共享密钥；现在 Alice 女王和 Bob 男爵需要知道各自的公钥。他们如何知道呢？这是不是又是一个鸡生蛋蛋生鸡的问题？嗯，有点像。正如我们将看到的，实际上，公钥密码学并不能解决信任问题，但它简化了其建立（特别是当参与者数量很多时）。
- en: Let’s stop here and move on to the next section as you will learn more about
    key exchanges in chapter 5\. We still have a few more asymmetric cryptographic
    primitives to uncover (see figure 1.8) to finish our tour of real-world cryptography.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，继续下一节，因为你将在第5章了解更多关于密钥交换的知识。我们还有一些非对称加密原语需要揭示（见图1.8），以完成我们对现实世界密码学的概览。
- en: '![](../Images/01_08.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_08.jpg)'
- en: Figure 1.8 The cryptographic algorithms we have learned so far. Two large classes
    of cryptographic algorithms are symmetric cryptography (with symmetric encryption)
    and asymmetric cryptography (with key exchanges).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 我们到目前为止学到的加密算法。两大类加密算法是对称加密（使用对称加密）和非对称加密（使用密钥交换）。
- en: 1.4.2 Asymmetric encryption, not like the symmetric one
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 非对称加密，不像对称加密那样
- en: 'The invention of the DH key exchange algorithm was quickly followed by the
    invention of the *RSA algorithm* named after Ron Rivest, Adi Shamir, and Leonard
    Adleman. RSA contains two different primitives: a public key encryption algorithm
    (or asymmetric encryption) and a (digital) signature scheme. Both primitives are
    part of the larger class of cryptographic algorithms called *asymmetric cryptography*.
    In this section, we will explain what these primitives do and how they can be
    useful.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: DH密钥交换算法的发明很快被RSA算法的发明紧随其后，该算法以Ron Rivest、Adi Shamir和Leonard Adleman命名。RSA包含两种不同的原语：公钥加密算法（或非对称加密）和（数字）签名方案。这两种原语都是更大类别的加密算法称为非对称加密的一部分。在本节中，我们将解释这些原语的作用以及它们如何有用。
- en: 'The first one, asymmetric encryption, has a similar purpose to the symmetric
    encryption algorithm we talked about previously: it allows one to encrypt messages
    in order to obtain confidentiality. Yet, unlike symmetric encryption, which had
    the two participants encrypt and decrypt messages with the same symmetric key,
    asymmetric encryption is quite different:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，非对称加密，与我们之前讨论的对称加密算法有类似的目的：它允许加密消息以获得机密性。然而，与对称加密不同，对称加密是完全不同的：
- en: 'It works with two different keys: a public key and a private key.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用两个不同的密钥：一个公钥和一个私钥。
- en: 'It provides an asymmetric point of view: anyone can encrypt with the public
    key, but only the owner of the private key can decrypt messages.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个不对称的观点：任何人都可以使用公钥加密，但只有私钥的所有者可以解密消息。
- en: Let’s now use a simple analogy to explain how one can use asymmetric encryption.
    We start with our friend Queen Alice again, who holds a private key (and its associated
    public key). Let’s picture her public key as an open chest that she releases to
    the public for anyone to use (see figure 1.9).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一个简单的类比来解释如何使用非对称加密。我们再次从我们的朋友女王爱丽丝开始，她持有一个私钥（及其相关的公钥）。让我们把她的公钥想象成一个她向公众发布供任何人使用的开放箱子（见图1.9）。
- en: '![](../Images/01_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_09.jpg)'
- en: Figure 1.9 To use asymmetric encryption, Queen Alice needs to first publish
    her public key (represented as an open box here). Now, anyone can use the public
    key to encrypt messages to her. And she should be able to decrypt them using the
    associated private key.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 为了使用非对称加密，女王爱丽丝需要先发布她的公钥（这里用一个开放的盒子表示）。现在，任何人都可以使用这个公钥来加密发送消息给她。而且她应该能够使用相关的私钥解密它们。
- en: Now, you and I and everyone who wants can encrypt a message to her using her
    public key. In our analogy, imagine that you would insert your message into the
    open chest and then close it. Once the chest is closed, nobody but Queen Alice
    should be able to open it. The box effectively protects the secrecy of the message
    from observers. The closed box (or encrypted content) can then be sent to Queen
    Alice, and she can use her private key (only known to her, remember) to decrypt
    it (see figure 1.10).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你、我和每个想要的人都可以使用她的公钥加密一条消息给她。在我们的类比中，想象一下你会把你的消息插入到开放的箱子里，然后关闭它。一旦箱子关闭了，除了女王爱丽丝之外，没有人能够打开它。这个盒子有效地保护了消息的保密性免受观察者的观察。然后，关闭的盒子（或加密内容）可以发送给女王爱丽丝，她可以使用她的私钥（只有她知道的）来解密它们（见图1.10）。
- en: '![](../Images/01_10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_10.jpg)'
- en: 'Figure 1.10 Asymmetric encryption: (1) anyone can use Queen Alice’s public
    key to encrypt messages to her. (2) After receiving them, (3) she can decrypt
    the content using her associated private key. Nobody is able to observe the messages
    directed to Queen Alice while they are being sent to her.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 非对称加密：（1）任何人都可以使用艾丽丝女王的公钥将消息加密给她。（2）接收后，（3）她可以使用相关联的私钥解密内容。在消息发送给艾丽丝女王时，没有人能够观察到。
- en: Let’s summarize in figure 1.11 the cryptographic primitives we have learned
    so far. We are only missing one more to finish our tour of real-world cryptography!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在图1.11中总结到目前为止我们学到的加密原语。我们只需要再学习一个就可以完成我们的真实世界加密之旅了！
- en: '![](../Images/01_11.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_11.jpg)'
- en: 'Figure 1.11 The cryptographic algorithms we have learned so far: two large
    classes of cryptographic algorithms are symmetric cryptography (with symmetric
    encryption) and asymmetric cryptography (with key exchanges and asymmetric encryption).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 到目前为止我们学到的加密算法：两类大型加密算法是对称加密（使用对称加密）和非对称加密（使用密钥交换和非对称加密）。
- en: 1.4.3 Digital signatures, just like your pen-and-paper signatures
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 数字签名，就像你的纸笔签名一样
- en: We saw that RSA provides an asymmetric encryption algorithm, but as we mentioned
    earlier, it also provides a *digital signature* algorithm. The invention of this
    digital signature cryptographic primitive has been of immense help to set up trust
    between the Alices and Bobs of our world. It is similar to real signatures; you
    know, the one that you are required to sign on a contract when you’re trying to
    rent an apartment, for example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到RSA提供了一种非对称加密算法，但正如我们之前提到的，它也提供了一种*数字签名*算法。这一数字签名的加密原语的发明在建立我们世界的爱丽丝和鲍勃之间的信任方面帮助巨大。它类似于真实的签名；你知道的，比如当你试图租一间公寓时，你被要求在合同上签字的那种。
- en: “What if they forge my signature?” you may ask, and indeed, real signatures
    don’t provide much security in the real world. On the other hand, cryptographic
    signatures can be used in the same kind of way but provide a cryptographic certificate
    with your name on it. Your cryptographic signature is *unforgeable* and can easily
    be verified by others. Pretty useful compared to the archaic signatures you used
    to write on checks!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: “如果他们伪造我的签名怎么办？”你可能会问，实际上，真实的签名在现实世界中并不提供太多安全性。另一方面，加密签名可以以同样的方式使用，但提供带有你名字的加密证书。你的加密签名是*无法伪造的*，并且可以很容易地被其他人验证。与你过去在支票上写的古老签名相比，非常有用！
- en: In figure 1.12, we can imagine a protocol where Queen Alice wants to show Lord
    David that she trusts Lord Bob. This is a typical example of how to establish
    trust in a multiparticipant setting and how asymmetric cryptography can help.
    By signing a piece of paper containing “I, Queen Alice, trust Lord Bob,” Queen
    Alice can take a stance and notify Lord David that Lord Bob is to be trusted.
    If Lord David already trusts Queen Alice and her signature algorithm, then he
    can choose to trust Lord Bob in return.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在图1.12中，我们可以想象一个协议，艾丽丝女王想向大卫勋爵表明她信任鲍勃勋爵。这是一个典型的多参与者环境下建立信任的例子，以及非对称加密如何帮助。通过签署一份包含“我，艾丽丝女王，信任鲍勃勋爵”的文件，艾丽丝女王可以表明立场并通知大卫勋爵要信任鲍勃勋爵。如果大卫勋爵已经信任艾丽丝女王及其签名算法，那么他可以选择相应地信任鲍勃勋爵。
- en: '![](../Images/01_12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_12.jpg)'
- en: Figure 1.12 Lord David already trusts Queen Alice. Because Queen Alice trusts
    Lord Bob, can Lord David safely trust Lord Bob as well?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 大卫勋爵已经信任艾丽丝女王。因为艾丽丝女王信任鲍勃勋爵，所以大卫勋爵能够安全地信任鲍勃勋爵吗？
- en: In more detail, Queen Alice can use the RSA signature scheme and her private
    key to sign the message, “I, Queen Alice, trust Lord Bob.” This generates a signature
    that should look like random noise (see figure 1.13).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，艾丽丝女王可以使用RSA签名方案和她的私钥签署消息“我，艾丽丝女王，信任鲍勃勋爵”。这将生成一个看起来像随机噪音的签名（见图1.13）。
- en: '![](../Images/01_13.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_13.jpg)'
- en: Figure 1.13 To sign a message, Queen Alice uses her private key and generates
    a signature.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 要签署一条消息，艾丽丝女王使用她的私钥并生成一个签名。
- en: 'Anyone can then *verify the signature* by combining:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以通过组合*验证签名*：
- en: Alice’s public key
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艾丽丝的公钥
- en: The message that was signed
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名的消息
- en: The signature
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名
- en: The result is either *true* (the signature is valid) or *false* (the signature
    is invalid) as figure 1.14 shows.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结果要么是*true*（签名有效），要么是*false*（签名无效），如图1.14所示。
- en: '![](../Images/01_14.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_14.jpg)'
- en: Figure 1.14 To verify a signature from Queen Alice, one also needs the message
    signed and Queen Alice’s public key. The result is either validating the signature
    or invalidating it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 要验证来自阿丽斯女王的签名，还需要被签名的消息和阿丽斯女王的公钥。结果要么验证签名，要么无效化签名。
- en: 'We have now learned about three different asymmetric primitives:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在学到了三种不同的非对称基元：
- en: Key exchange with Diffie-Hellman
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与迪菲-赫尔曼（Diffie-Hellman）进行密钥交换
- en: Asymmetric encryption
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Digital signatures with RSA
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RSA进行数字签名
- en: These three cryptographic algorithms are the most known and commonly used primitives
    in asymmetric cryptography. It might not be totally obvious how they can help
    to solve real-world problems, but rest assured, they are used every day by many
    applications to secure things around them. It is time to complete our picture
    with all the cryptographic algorithms we’ve learned about so far (see figure 1.15).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种密码算法是非对称加密中最知名和常用的基元。它们如何帮助解决现实问题可能并不完全明显，但请放心，它们每天都被许多应用程序用来保护周围的事物。现在是时候用我们迄今学到的所有密码算法来完整地描绘我们的图景了（见图1.15）。
- en: '![](../Images/01_15.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_15.jpg)'
- en: Figure 1.15 The symmetric and asymmetric algorithms we have learned so far
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 我们迄今学到的对称和非对称算法
- en: 1.5 Classifying and abstracting cryptography
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 对加密进行分类和抽象
- en: 'In the previous section, we surveyed two large classes of algorithms:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们调查了两类大型算法：
- en: '*Symmetric cryptography (or secret key cryptography)*—A single secret is used.
    If several participants are aware of the secret, it is called a *shared* secret.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对称加密（或秘密密钥加密）*—使用单个秘密。如果有多个参与者知道秘密，则称为*共享*秘密。'
- en: '*Asymmetric cryptography (or public key cryptography)*—Participants have an
    asymmetrical view of the secrets. For example, some will have knowledge of a public
    key, while some will have knowledge of both a public and private key.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非对称加密（或公钥加密）*—参与者对于密钥有不对称的视角。例如，有些人会知道公钥，而有些人会同时知道公钥和私钥。'
- en: Symmetric and asymmetric cryptography are not the only two categories of primitives
    in cryptography, and it’s quite hard to classify the different subfields. But
    yet, as you will realize, a large part of our book is about (and makes use of)
    symmetric and asymmetric primitives. This is because a large part of what is useful
    in cryptography nowadays is contained in these subfields. Another way of dividing
    cryptography can be
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对称和非对称加密不是加密中唯一的两类基元，而且很难对不同的子领域进行分类。但是，正如你将意识到的那样，我们书中的很大一部分内容都是关于（并且利用了）对称和非对称基元。这是因为当今加密中有用的很大一部分内容都包含在这些子领域中。另一种划分加密的方式可能是
- en: '*Math-based constructions*—These rely on mathematical problems like factoring
    numbers. (The RSA algorithm for digital signatures and asymmetric encryption is
    an example of such a construction.)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于数学的构建*—这些依赖于数学问题，如分解数字。（RSA算法用于数字签名和非对称加密就是这种构建的一个例子。）'
- en: '*Heuristic-based constructions*—These rely on observations and statistical
    analysis by cryptanalysts. (AES for symmetric encryption is an example of such
    a construction.)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启发式构建*—这些依赖于密码分析人员的观察和统计分析。（对称加密的AES就是这种构建的一个例子。）'
- en: There is also a speed component to this categorization as mathematic-based constructions
    are often much slower than heuristic-based constructions. To give you an idea,
    symmetric constructions are most often based on heuristics (what seems to be working),
    while most asymmetric constructions are based on mathematical problems (what is
    thought to be hard).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分类还涉及速度因素，因为基于数学的构建通常比基于启发式的构建慢得多。给你一个概念，对称构建通常基于启发式（看起来有效的东西），而大多数非对称构建基于数学问题（被认为是困难的问题）。
- en: It is hard for us to rigorously categorize all of what cryptography has to offer.
    Indeed, every book or course on the subject gives different definitions and classifications.
    In the end, these distinctions are not too useful for us as we will see most of
    the cryptographic primitives as unique tools that make unique *security claims*.
    We can, in turn, use many of these tools as building blocks to create protocols.
    It is thus essential to understand how each of these tools work and what kind
    of security claims they provide in order to understand how they secure the protocols
    around us. For this reason, the first part of this book will go through the most
    useful cryptographic primitives and their security properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，严格分类密码学所能提供的一切是很困难的。事实上，关于这个主题的每本书或课程都给出了不同的定义和分类。最终，这些区别对我们来说并不太有用，因为我们将看到大多数密码原语都是具有独特
    *安全声明* 的独特工具。我们反过来可以使用这些工具中的许多作为构建协议的基础模块。因此，了解这些工具的每一个是如何工作的，以及它们提供了哪些安全声明，以便理解它们如何保护我们周围的协议，是非常重要的。因此，这本书的第一部分将介绍最有用的密码原语及其安全属性。
- en: A lot of the concepts in the book can be quite complicated the first time around.
    But like everything, the more we read about them and the more we see them in context,
    the more natural they become, the more we can abstract them. The role of this
    book is to help you to create abstractions, to allow you to create a mental model
    of what these constructions do, and to understand how they can be combined together
    to produce secure protocols. I will often talk about the interface of constructions
    and give real-world examples of usage and composition.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的很多概念第一次接触时可能会相当复杂。但像一切事物一样，我们越是阅读它们，越是在上下文中看到它们，它们就越自然，我们就能越抽象它们。这本书的作用是帮助你创建抽象，让你建立这些构造所做的事情的心理模型，并理解它们如何组合在一起产生安全协议。我经常会谈论构造的接口，并给出使用和组合的现实示例。
- en: 'The definition of cryptography used to be simple: Queen Alice and Lord Bob
    want to exchange secret messages. It isn’t anymore. What cryptography is nowadays
    is quite complex to describe and has grown organically around discoveries, breakthroughs,
    and practical needs. At the end of the day, cryptography is what helps to augment
    a protocol in order to make it work in adversarial settings.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，密码学的定义很简单：女王爱丽丝和博伯爵想要交换秘密信息。现在不再是这样了。如今的密码学描述相当复杂，是围绕着发现、突破和实际需求有机发展起来的。归根结底，密码学是帮助增强协议以使其在对抗环境中运行的东西。
- en: 'To understand exactly how cryptography can help, the set of goals that these
    protocols aim to achieve is what matters to us. That’s the useful part. Most of
    the cryptographic primitives and protocols we’ll learn about in this book provide
    one or two of the following properties:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要准确理解密码学如何帮助，对我们而言最重要的是这些协议旨在实现的一系列目标。那才是有用的部分。本书中我们将了解的大多数密码原语和协议提供以下一种或两种属性：
- en: '*Confidentiality*—It’s about masking and protecting some information from the
    wrong eyes. For example, encryption masks the messages in transit.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保密性* —— 它关乎掩盖和保护一些信息免受错误眼睛的侵害。例如，加密掩盖了传输中的消息。'
- en: '*Authentication*—It’s about identifying who we are talking to. For example,
    this can be helpful in making sure that messages we receive indeed come from Queen
    Alice.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*认证* —— 它关乎我们正在与谁交谈。例如，这有助于确保我们收到的消息确实来自女王爱丽丝。'
- en: Of course, this is still a heavy simplification of what cryptography can provide.
    In most cases, the details are in the security claims of the primitives. Depending
    on how we use a cryptographic primitive in a protocol, it will achieve different
    security properties.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这仍然是密码学可以提供的内容的一个重要简化。在大多数情况下，细节都在原语的安全声明中。根据我们在协议中如何使用密码原语，它将实现不同的安全属性。
- en: 'Throughout this book, we will learn new cryptographic primitives and how they
    can be combined to expose security properties like confidentiality and authentication.
    For now, appreciate the fact that cryptography is about providing insurances to
    a protocol in adversarial settings. While the “adversaries” are not clearly defined,
    we can imagine that they are the ones who attempt to break our protocol: a participant,
    an observer, a man in the middle. They reflect what a real-life adversary could
    be. Because eventually, cryptography is a practical field made to defend against
    bad actors in flesh and bones and bits.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将学习新的加密原语以及它们如何结合起来以暴露诸如保密性和认证等安全属性。目前，我们要欣赏的是，密码学是关于在对抗性环境中为协议提供保险的。虽然“对手”并没有明确定义，但我们可以想象他们是试图破坏我们协议的人：参与者、观察者、中间人。他们反映了真实生活中对手可能的情况。因为最终，密码学是一个实践领域，旨在防御血肉和骨头以及位的不良行为者。
- en: 1.6 Theoretical cryptography vs. real-world cryptography
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 理论密码学与现实世界密码学
- en: In 1993, Bruce Schneier released *Applied Cryptography* (Wiley), a book targeting
    developers and engineers who want to build applications that involve cryptography.
    Circa 2012, Kenny Paterson and Nigel Smart started an annual conference called
    Real World Crypto that targets the same crowd. But what do applied cryptography
    and real-world cryptography refer to? Is there more than one type of cryptography?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 1993年，布鲁斯·施奈尔（Bruce Schneier）发布了《*应用密码学*》（Wiley），这是一本针对希望构建涉及密码学应用的开发人员和工程师的书籍。大约在2012年，肯尼·帕特森（Kenny
    Paterson）和奈杰尔·斯马特（Nigel Smart）开始了一年一度的名为真实世界密码（Real World Crypto）的会议，针对的是同一群人。但是应用密码学和现实世界密码学是指什么？是否有多种类型的密码学？
- en: To answer the questions, we have to start by defining *theoretical cryptography*,
    the cryptography that cryptographers and cryptanalysts work on. These crypto people
    are mostly from academia, working in universities, but sometimes from the industry
    or in specific departments of the government. They research everything and anything
    in cryptography. Results are shared internationally through publications and presentations
    in journals and conferences. Yet not everything they do is obviously useful or
    practical. Often, no “proof of concept” or code is released. It wouldn’t make
    sense anyway, as no computer is powerful enough to run their research. Having
    said that, theoretical cryptography sometimes becomes so useful and practical
    that it makes its way to the other side.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这些问题，我们必须从定义*理论密码学*开始，这是密码学家和密码分析家从事的密码学。这些密码学人大多来自学术界，在大学工作，但有时来自行业或政府的特定部门。他们研究密码学的一切。结果通过国际期刊和会议的出版物和演示分享。然而，他们所做的并不是显然有用或实用的。通常情况下，没有“概念证明”或代码被发布。无论如何，这是毫无意义的，因为没有计算机足够强大来运行他们的研究。话虽如此，理论密码学有时变得如此有用和实用，以至于它会进入另一边。
- en: The other side is the world of *applied cryptography* or *real-world cryptography*.
    It is the foundation of the security you find in all applications around you.
    Although it often seems like it’s not there, almost transparent, it is there when
    you log into your bank account on the internet; it is with you when you message
    your friends; it helps protect you when you lose your phone. It is ubiquitous
    because, unfortunately, attackers are everywhere and actively try to observe and
    harm our systems. Practitioners are usually from the industry but will sometimes
    vet algorithms and design protocols with the help of the academic community. Results
    are often shared through conferences, blog posts, and open source software.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面是*应用密码学*或*现实世界密码学*的世界。它是你周围所有应用程序中发现的安全的基础。虽然它通常看起来好像不存在，几乎是透明的，但当你在互联网上登录银行账户时它就在那里；当你给朋友发消息时它与你同在；当你丢失手机时它帮助保护你。它是无处不在的，因为不幸的是，攻击者无处不在，并积极尝试观察和伤害我们的系统。从业者通常来自行业，但有时会与学术界合作评估算法并设计协议。结果通常通过会议、博客文章和开源软件分享。
- en: 'Real-world cryptography usually cares deeply about real-world considerations:
    what is the exact level of security provided by an algorithm? How long does it
    take to run the algorithm? What is the size of the inputs and outputs required
    by the primitive? Real-world cryptography is, as you might have guessed, the subject
    of this book. While theoretical cryptography is the subject of other books, we
    will still take a peek at what is brewing there in the last chapters of this book.
    Be prepared to be amazed as you might catch a glance of the real-world cryptography
    of tomorrow.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的密码学通常非常关注现实世界的考虑因素：算法提供的确切安全级别是多少？运行算法需要多长时间？原语需要的输入和输出大小是多少？现实世界的密码学就是这本书的主题。虽然理论密码学是其他书的主题，但我们仍将在本书的最后几章中窥探一下那里正在酝酿的东西。准备好被惊讶吧，因为你可能会一瞥到明天的现实世界的密码学。
- en: 'Now you might be wondering: how do developers and engineers choose what cryptography
    to use for their real-world applications?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能想知道：开发人员和工程师如何选择用于他们的现实世界应用的密码学？
- en: '1.7 From theoretical to practical: Choose your own adventure'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 从理论到实践：选择你自己的冒险
- en: '*Sitting on top are cryptanalysts who propose and solve hard mathematical problems
    [ . . . ] and at the bottom are software engineers who want to encrypt some data*.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*位于顶部的是提出并解决难题的密码分析师[...] 而在底部的是希望加密一些数据的软件工程师*。'
- en: —Thai Duong (“So you want to roll your own crypto?,” 2020)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: —Thai Duong（“那么你想自己设计密码学？”，2020）
- en: In all the years I’ve spent studying and working with cryptography, I’ve never
    noticed a single pattern in which a cryptographic primitive ends up being used
    in real-world applications. Things are pretty chaotic. Before a theoretical primitive
    gets to be adopted, there’s a long list of people who get to handle the primitive
    and shape it into something consumable and sometimes safer for the public at large.
    How can I even explain that to you?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我花费在研究和从事密码学的所有年份中，我从未注意到一个密码学原语在实际应用中被使用的单一模式。情况相当混乱。在一个理论原语被采用之前，有一长串人要处理这个原语，并将其塑造成某种可消费的东西，有时对大众更安全。我该如何向你解释呢？
- en: 'Have you heard of *Choose Your Own Adventure*? It’s an old book series where
    you got to pick how you want to step through the story. The principle was simple:
    you read the first section of the book; at the end of the section, the book lets
    you decide on the path forward by giving you different options. Each option was
    associated with a different section number that you could skip directly to if
    you so chose. So, I did the same here! Start by reading the next paragraph and
    follow the direction it gives you.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你听说过*选择你自己的冒险*吗？这是一个旧书系列，你可以选择如何沿着故事前进。原则很简单：你读完书的第一部分；在部分结束时，书让你通过给出不同的选项来决定未来的道路。每个选项都与一个不同的部分号码相关，如果你愿意，可以直接跳转到该部分。所以，在这里我也做了同样的事情！从阅读下一段开始，按照它给出的方向前进。
- en: '* * *'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '*Where it all begins.* Who are you? Are you Alice, a cryptographer? Are you
    David, working in the private industry and in need of a solution to your problems?
    Or are you Eve, working in a government branch and preoccupied by cryptography?'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*一切始于此。* 你是谁？你是爱丽丝，一位密码学家吗？你是大卫，私营行业工作者，需要解决问题吗？还是你是伊娃，工作在政府部门，忙于密码学？'
- en: You’re Alice, go to step 1.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是爱丽丝，前往步骤 1。
- en: You’re David, go to step 2.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是大卫，前往步骤 2。
- en: You’re Eve, go to step 3.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是伊娃，前往步骤 3。
- en: '*Step 1: Researchers gotta research.* You’re a researcher working in a university,
    or in the research team of a private company or a nonprofit, or in a government
    research organization like NIST or NSA. As such, your funding can come from different
    places and might incentivize you to research different things.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1：研究员得研究。* 你是一名在大学工作的研究人员，或者在私营公司或非营利组织的研究团队工作，或者在像 NIST 或 NSA 这样的政府研究机构工作。因此，你的资金可能来自不同的地方，并可能激励你研究不同的东西。'
- en: You invent a new primitive, go to step 4.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你发明了一个新的原语，前往步骤 4。
- en: You invent a new construction, go to step 5.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你发明了一种新的结构，前往步骤 5。
- en: You start an open competition, go to step 6.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你开始了一场公开竞赛，前往步骤 6。
- en: '*Step 2: The industry has a need.* As part of your job, something comes up
    and you are in need of a new standard. For example, the Wi-Fi Alliance is a nonprofit
    funded by interested companies to produce the set of standards around the Wi-Fi
    protocol. Another example are banks that got together to produce the Payment Card
    Industry Data Security Standard (PCI-DSS), which enforces algorithms and protocols
    to use if you deal with credit card numbers.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*第2步：行业有需求。* 作为你的工作的一部分，出现了一些问题，你需要一个新的标准。例如，Wi-Fi联盟是由感兴趣的公司资助的非营利组织，制定了围绕Wi-Fi协议的一套标准。另一个例子是银行联合起来制定了支付卡行业数据安全标准（PCI-DSS），该标准强制执行处理信用卡号码时要使用的算法和协议。'
- en: You decide to fund some much needed research, go to step 1.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你决定资助一些急需的研究，前往第1步。
- en: You decide to standardize a new primitive or protocol, go to step 5.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你决定标准化一个新的基元或协议，前往第5步。
- en: You start an open competition, go to step 6.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你发起了一场公开竞赛，前往第6步。
- en: '*Step 3: A government has a need.* You’re working for your country’s government,
    and you need to push out some new crypto. For example, the NIST is tasked with
    publishing the *Federal Information Processing Standards* (FIPS), which mandates
    what cryptographic algorithms can be used by companies that deal with the US government.
    While many of these standards were success stories and people tend to have a lot
    of trust in standards being pushed by government agencies, there is (unfortunately)
    a lot to say about failures.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*第3步：政府有需求。* 你为你国家的政府工作，需要推出一些新的加密。例如，NIST负责发布*联邦信息处理标准*（FIPS），规定了哪些加密算法可以被与美国政府打交道的公司使用。虽然许多这些标准都是成功案例，人们倾向于对政府机构推动的标准有很多信任，但（不幸的是）对于失败还有很多话要说。'
- en: 'In 2013, following revelations from Edward Snowden, it was discovered that
    NSA had purposefully and successfully pushed for the inclusion of backdoor algorithms
    in standards (see “Dual EC: A Standardized Back Door” by Bernstein et al.), which
    included a hidden switch that allowed NSA, and only the NSA, to predict your secrets.
    These *backdoors* can be thought of as magic passwords that allow the government
    (and only it, supposedly) to subvert your encryption. Following this, the cryptographic
    community lost a lot of confidence in standards and suggestions coming from governmental
    bodies. Recently, in 2019, it was found that the Russian standard GOST had been
    a victim of the same treatment.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '在2013年，根据爱德华·斯诺登的披露，发现NSA故意并成功地推动在标准中包含后门算法（参见Bernstein等人的“Dual EC: A Standardized
    Back Door”），其中包括一个隐藏的开关，允许NSA，仅限NSA，预测你的秘密。这些*后门*可以被视为魔法密码，允许政府（仅限政府，据说）颠覆你的加密。在此之后，密码学界对来自政府机构的标准和建议失去了很多信心。最近，在2019年，发现俄罗斯标准GOST也遭受了同样的对待。'
- en: '*Cryptographers have long suspected that the agency planted vulnerabilities
    in a standard adopted in 2006 by the National Institute of Standards and Technology
    and later by the International Organization for Standardization, which has 163
    countries as members. Classified N.S.A. memos appear to confirm that the fatal
    weakness, discovered by two Microsoft cryptographers in 2007, was engineered by
    the agency. The N.S.A. wrote the standard and aggressively pushed it on the international
    group, privately calling the effort “a challenge in finesse.”*.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码学家长期以来一直怀疑，该机构在2006年被国家标准技术研究所采纳并后来被国际标准化组织采纳的标准中植入了漏洞，该组织有163个成员国。机密的N.S.A.备忘录似乎证实了这个致命弱点，由2007年两名微软密码学家发现，由该机构设计。N.S.A.编写了这一标准，并积极推动国际组织，私下称这一努力为“一项精湛的挑战”。*。'
- en: —*New York Times* (“N.S.A. Able to Foil Basic Safeguards of Privacy on Web,”
    2013)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: —*纽约时报*（“N.S.A. Able to Foil Basic Safeguards of Privacy on Web,” 2013）
- en: You fund some research, go to step 1.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你资助了一些研究，前往第1步。
- en: You organize an open competition, go to step 6.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你组织了一场公开竞赛，前往第6步。
- en: You push for the standardization of a primitive or protocol that you’re using,
    go to step 7.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你推动正在使用的基元或协议的标准化，前往第7步。
- en: '*Step 4: A new concept is proposed.* As a researcher, you manage to do the
    impossible; you invent a new concept. Sure, someone already thought about encryption,
    but there are still new primitives being proposed every year in cryptography.
    Some of them will prove to be impossible to realize, and some will end up being
    solvable. Maybe you have an actual construction as part of your proposal, or maybe
    you’ll have to wait to see if someone can come up with something that works.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 4 步：提出一个新概念。* 作为研究人员，你成功做到了不可能的事情；你发明了一个新概念。当然，有人已经想到了加密，但在密码学领域每年仍然会提出一些新的原语。其中一些将被证明无法实现，而一些将最终得以解决。也许你的提议中有一个实际的构造，或者也许你得等待看看是否有人能想出有效的方法。'
- en: Your primitive gets implemented, go to step 5.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的原始构造被实施，前往第 5 步。
- en: Your primitive ends up being impossible to implement, go back to the beginning.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的原始构造最终无法实施，回到起点。
- en: '*Step 5: A new construction or protocol is proposed.* A cryptographer or a
    team of cryptographers proposes a new algorithm that instantiates a concept. For
    example, AES is an instantiation of an encryption scheme. (AES was initially proposed
    by Vincent Rijmen and Joan Daemen, who named their construction as a contraction
    of their names, Rijndael.) What’s next?'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 5 步：提出新的构造或协议。* 一个密码学家或密码学家团队提出了一个实现概念的新算法。例如，AES 是加密方案的一种实例化。（AES 最初由文森特·瑞曼和约安·达门提出，他们将他们的构造命名为他们的名字的缩写，Rijndael。）接下来呢？'
- en: Someone builds on your construction, go to step 5.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人在你的构造基础上进行改进，前往第 5 步。
- en: You partake in an open competition and win! Go to step 6.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你参加了一个公开竞赛并赢得了胜利！前往第 6 步。
- en: There’s a lot of hype for your work; you’re getting a standard! Go to step 7.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的工作有很多炒作；你将获得一个标准！前往第 7 步。
- en: You decide to patent your construction, go to step 8.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你决定对你的构造进行专利申请，前往第 8 步。
- en: You or someone else decides that it’ll be fun to implement your construction.
    Go to step 9.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你或其他人决定实现你的构造会很有趣。前往第 9 步。
- en: '*Step 6: An algorithm wins a competition.* The process cryptographers love
    the most is an open competition! For example, AES was a competition that invited
    researchers from all over the world to compete. After dozens of submissions and
    rounds of analysis and help from cryptanalysts (which can take years), the list
    was reduced to a few candidates (in the case of AES, a single one), which then
    moved to become standardized.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 6 步：一个算法赢得了比赛。* 密码学家们最喜欢的过程是一个公开的竞赛！例如，AES 就是一个邀请全球研究者参与的竞赛。经过数十次提交和分析以及密码分析师的帮助（可能需要数年），候选名单被缩减到几个（在
    AES 的情况下，只有一个），然后开始标准化过程。'
- en: You got lucky, after many years of competition your construction won! Go to
    step 7.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你很幸运，在多年的竞争后，你的构造赢得了胜利！前往第 7 步。
- en: Unfortunately, you lost. Go back to the start.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，你失败了。回到起点。
- en: '*Step 7: An algorithm or protocol is standardized.* A standard is usually published
    by a government or by a standardization body. The aim is to make sure that everyone
    is on the same page so as to maximize interoperability. For example, NIST regularly
    publishes cryptographic standards. A well-known standardization body in cryptography
    is the Internet Engineering Task Force (IETF), which is behind many standards
    on the internet (like TCP, UDP, TLS, and so on) and that you will hear about a
    lot in this book. Standards in the IETF are called *Request For Comment* (RFC)
    and can be written by pretty much anyone who wants to write a standard.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 7 步：一个算法或协议被标准化。* 标准通常由政府或标准化机构发布。目的是确保每个人都在同一页面上，以最大限度地提高互操作性。例如，NIST 定期发布密码学标准。密码学中的一个知名标准化机构是互联网工程任务组（IETF），它是互联网上许多标准（如
    TCP、UDP、TLS 等）的背后推动者，在本书中你会经常听到。在 IETF 中，标准称为 *请求评论*（RFC），几乎任何想要制定标准的人都可以编写。'
- en: '*To reinforce that we do not vote, we have also adopted the tradition of “humming”:
    When, for example, we have face-to-face meetings and the chair of the working
    group wants to get a “sense of the room”, instead of a show of hands, sometimes
    the chair will ask for each side to hum on a particular question, either “for”
    or “against”*.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了加强我们不投票的观念，我们还采用了“哼声”的传统：例如，当我们面对面开会时，工作组主席想要了解“房间的感觉”时，主席有时会要求每一方对特定问题哼唱，“支持”还是“反对”。*'
- en: —RFC 7282 (“On Consensus and Humming in the IETF,” 2014)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: —RFC 7282（《关于 IETF 中的共识和哼声》，2014）
- en: Sometimes, a company publishes a standard directly. For example, RSA Security
    LLC (funded by the creators of the RSA algorithm) released a series of 15 documents
    called the *Public Key Cryptography Standards* (PKCS) to legitimize algorithms
    and techniques the company used at that time. Nowadays, this is pretty rare, and
    a lot of companies go through the IETF to standardize their protocols or algorithms
    as an RFC instead of a custom document.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一家公司直接发布一个标准。例如，RSA 安全有限责任公司（由 RSA 算法的创建者资助）发布了一系列 15 个名为 *公钥密码学标准*（PKCS）的文档，以合法化该公司当时使用的算法和技术。如今，这种情况非常罕见，许多公司通过
    IETF 来标准化他们的协议或算法，而不是通过自定义文档。
- en: Your algorithm or protocol gets implemented, go to step 9.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的算法或协议得到了实现，前往步骤 9。
- en: Nobody cares about your standard, go back to the start.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有人关心你的标准，回到起点。
- en: '*Step 8: A patent expires.* A patent in cryptography usually means that nobody
    will use the algorithm. Once the patent expires, it is not uncommon to see a renewed
    interest in the primitive. The most popular example is probably Schnorr signatures,
    which were the first contender to become the most popular signature scheme until
    Schnorr himself patented the algorithm in 1989\. This led to the NIST standardizing
    a poorer algorithm called Digital Signature Algorithm (DSA), which became the
    go-to signature scheme at the time, but doesn’t see much use nowadays. The patent
    over Schnorr signatures expired in 2008, and the algorithm has since started regaining
    popularity.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 8：专利到期。* 在密码学中，专利通常意味着没有人会使用该算法。一旦专利过期，重新对原语产生兴趣并不罕见。最著名的例子可能是 Schnorr
    签名，它曾是最受欢迎的签名方案之一，直到 Schnorr 本人在 1989 年对算法进行了专利。这导致 NIST 标准化了一个较差的算法，称为数字签名算法（DSA），它成为了当时的首选签名方案，但现在已经不太使用。Schnorr
    签名的专利在 2008 年到期，自那时起该算法开始重新受到关注。'
- en: It’s been too long, your algorithm will be forever forgotten. Go back to the
    beginning.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间过去太久了，你的算法将永远被遗忘。回到起点。
- en: Your construction inspires many more constructions to get invented on top of
    it, go to step 5.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的构建启发了更多的构建被发明在其之上，前往步骤 5。
- en: Now people want to use your construction, but not before it’s standardized for
    real. Go to step 7.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在人们想要使用你的构建，但在真正标准化之前不会这样。前往步骤 7。
- en: Some developers are implementing your algorithm! Go to step 9.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些开发人员正在实现你的算法！前往步骤 9。
- en: '*Step 9: A construction or protocol gets implemented.* Implementers have the
    hard task to not only decipher a paper or a standard (although standards are *supposed*
    to target implementers), but they also must make their implementations easy and
    safe to use. This is not always a simple task as many devastating bugs can arise
    in the way cryptography is used.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 9：构建或协议被实现。* 实现者不仅要解读论文或标准（尽管标准 *应该* 面向实现者），而且还必须使他们的实现易于使用和安全。这并不总是一件简单的任务，因为在使用密码学的方式上可能会出现许多灾难性的错误。'
- en: Someone decides it is time for these implementations to be backed by a standard.
    It’s embarrassing without one. Go to step 7.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人决定是时候为这些实现提供一个标准支持了。没有标准支持是令人尴尬的。前往步骤 7。
- en: Hype is raining on your cryptographic library! Go to step 10.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 炒作正落在你的加密库头上！前往步骤 10。
- en: '*Step 10: A developer uses a protocol or primitive in an application.* A developer
    has a need, and your cryptographic library seems to solve it—easy peasy!'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 10：开发人员在应用程序中使用协议或原语。* 开发人员有一个需求，而你的加密库似乎解决了这个需求 —— 轻而易举！'
- en: The primitive solves the need, but it doesn’t have a standard. Not great. Go
    to step 7.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原语解决了需求，但它没有一个标准。不太好。前往步骤 7。
- en: I wish this was written in my programming language. Go to step 9.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望这是用我的编程语言编写的。前往步骤 9。
- en: I misused the library or the construction is broken. Game over.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我滥用了库或者构建已经损坏。游戏结束。
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: You got it! There are many means for a primitive to go real-world. The best
    way involves many years of analysis, an implementor-friendly standard, and good
    libraries. A worse way involves a bad algorithm with a poor implementation. In
    figure 1.16, I illustrate the preferred path.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你成功了！原语实现到真实世界有很多方式。最好的方式涉及多年的分析，一个友好的实现标准和优秀的库。更糟糕的方式涉及一个糟糕的算法和糟糕的实现。在图 1.16
    中，我说明了首选路径。
- en: '![](../Images/01_16.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01_16.jpg)'
- en: 'Figure 1.16 The ideal life cycle for a cryptographic algorithm starts when
    cryptographers instantiate a concept in a white paper. For example, AES is an
    instantiation of the concept of symmetric encryption (there are many more symmetric
    encryption algorithms out there). A construction can then be standardized: everybody
    agrees to implement it a certain way to maximize interoperability. Then support
    is created by implementing the standard in different languages.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 理想的加密算法生命周期始于密码专家在白皮书中实例化一个概念。例如，AES 是对称加密概念的一个实例化（还有许多其他对称加密算法）。然后可以对构造进行标准化：每个人都同意以某种方式实现它以最大程度地实现互操作性。然后通过在不同语言中实现标准来创建支持。
- en: 1.8 A word of warning
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 一个警告
- en: '*Anyone, from the most clueless amateur to the best cryptographer, can create
    an algorithm that he himself can’t break*.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何人，从最无知的业余爱好者到最优秀的密码学家，都可以创建一个他自己无法破解的算法*。'
- en: —Bruce Schneier (“Memo to the Amateur Cipher Designer,” 1998)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: —布鲁斯·施奈尔（“给业余密码设计者的备忘录”，1998年）
- en: I must warn you, the art of cryptography is difficult to master. It would be
    unwise to assume that you can build complex cryptographic protocols once you’re
    done with this book. This journey should enlighten you, show you what is possible,
    and show you how things work, but it will not make you a master of cryptography.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须警告您，密码学的艺术很难掌握。一旦您完成了这本书，就假设您可以构建复杂的密码协议是不明智的。这段旅程应该启发您，向您展示可能性，并向您展示事物是如何运作的，但它不会使您成为密码学大师。
- en: This book is not the holy grail. Indeed, the last pages of this book take you
    through the most important lesson—do not go alone on a real adventure. Dragons
    can kill, and you need some support to accompany you in order to defeat them.
    In other words, cryptography is complicated, and this book alone does not permit
    you to abuse what you learn. To build complex systems, experts who have studied
    their trade for years are required. Instead, what you will learn is to recognize
    when cryptography should be used, or, if something seems fishy, what cryptographic
    primitives and protocols are available to solve the issues you’re facing, and
    how all these cryptographic algorithms work under the surface. Now that you’ve
    been warned, go to the next chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并非圣杯。事实上，本书的最后几页将带你走过最重要的一课——不要独自踏上真正的冒险。龙可以杀人，你需要一些支持来陪伴你以便击败它们。换句话说，密码学很复杂，而仅凭本书无法让您滥用所学知识。要构建复杂的系统，需要研究自己的行业多年的专家。相反，您将学到的是如何识别何时应使用密码学，或者，如果有什么不对劲，可以使用什么密码原语和协议来解决您面临的问题，以及所有这些密码算法在表面下是如何工作的。既然您已经被警告，请转到下一章。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A protocol is a step-by-step recipe where multiple participants attempt to achieve
    something like exchanging confidential messages.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议是一个逐步指南，在其中多个参与者尝试实现类似交换保密消息之类的目标。
- en: Cryptography is about augmenting protocols to secure them in adversarial settings.
    It often requires secrets.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学是关于增强协议以在对抗性环境中保护它们。它通常需要秘密。
- en: A cryptographic primitive is a type of cryptographic algorithm. For example,
    symmetric encryption is a cryptographic primitive, while AES is a specific symmetric
    encryption algorithm.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码原语是一种密码算法类型。例如，对称加密是一种密码原语，而 AES 是一种特定的对称加密算法。
- en: 'One way to classify the different cryptographic primitives is to split them
    into two types: symmetric and asymmetric cryptography. Symmetric cryptography
    uses a single key (as you saw with symmetric encryption), while asymmetric cryptography
    makes use of different keys (as you saw with key exchanges, asymmetric encryption,
    and digital signatures).'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对不同的密码原语进行分类的一种方法是将它们分为两种类型：对称和非对称密码学。对称密码学使用单一密钥（正如您在对称加密中所看到的），而非对称密码学则使用不同的密钥（正如您在密钥交换、非对称加密和数字签名中所看到的）。
- en: 'Cryptographic properties are hard to classify, but they often aim to provide
    one of these two properties: authentication or confidentiality. Authentication
    is about verifying the authenticity of something or someone, while confidentiality
    is about the privacy of data or identities.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学属性难以分类，但它们通常旨在提供以下两种属性之一：身份验证或保密性。身份验证涉及验证某物或某人的真实性，而保密性涉及数据或身份的隐私。
- en: Real-world cryptography matters because it is ubiquitous in technological applications,
    while theoretical cryptography is often less useful in practice.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界的密码学很重要，因为它在技术应用中无处不在，而理论密码学在实践中通常不那么有用。
- en: Most of the cryptographic primitives contained in this book were agreed on after
    long standardization processes.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中包含的大多数密码学基元是经过长时间的标准化过程达成一致的。
- en: Cryptography is complicated, and there are many dangers in implementing or using
    cryptographic primitives.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学很复杂，在实施或使用密码学基元时存在许多危险。
