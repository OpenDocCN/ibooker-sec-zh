- en: 5 Key exchanges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 密钥交换
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What key exchanges are and how they can be useful
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥交换是什么以及它们如何有用
- en: The Diffie-Hellman and Elliptic Curve Diffie-Hellman key exchanges
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Diffie-Hellman 和椭圆曲线 Diffie-Hellman 密钥交换
- en: Security considerations when using key exchanges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密钥交换时的安全考虑
- en: 'We are now entering the realm of *asymmetric cryptography* (also called *public
    key cryptography*) with our first asymmetric cryptographic primitive: the *key
    exchange*. A key exchange is, as the name hints, an exchange of keys. For example,
    Alice sends a key to Bob, and Bob sends a key to Alice. This allows the two peers
    to agree on a shared secret, which can then be used to encrypt communications
    with an authenticated encryption algorithm.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入了 *非对称加密* 领域（也称为 *公钥加密* ） ，我们的第一个非对称加密原语：*密钥交换*。密钥交换正如其名称所示，是密钥的交换。例如，Alice
    发送一个密钥给 Bob，Bob 发送一个密钥给 Alice。这使得两个对等方可以达成共识，产生一个共享密钥，然后可以使用认证加密算法对通信进行加密。
- en: Warning As I hinted in the introduction of this book, there is much more math
    involved in asymmetric cryptography; therefore, the next chapters are going to
    be a tad more difficult for some readers. Don’t get discouraged! What you will
    learn in this chapter will be helpful to understand many other primitives based
    on the same fundamentals.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 正如我在本书引言中所暗示的，非对称加密涉及更多的数学；因此，接下来的章节对某些读者来说可能会更加困难。不要气馁！本章学到的内容将有助于理解基于相同基础的许多其他原语。
- en: Note For this chapter, you’ll need to have read chapter 3 on message authentication
    codes and chapter 4 on authenticated encryption.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 对于本章，你需要已经阅读了第 3 章关于消息认证码和第 4 章关于认证加密。
- en: 5.1 What are key exchanges?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 什么是密钥交换？
- en: Let’s start by looking at a scenario where both Alice and Bob want to communicate
    privately but have never talked to each other before. This will motivate what
    key exchanges can unlock in the simplest of situations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一个场景，Alice 和 Bob 都想要私下交流，但之前从未互相交谈过。这将激发出在最简单的情况下密钥交换可以解锁什么。
- en: To encrypt communications, Alice can use the authenticated encryption primitive
    you learned about in chapter 4\. For this, Bob needs to know the same symmetric
    key so Alice can generate one and send it over to Bob. After that, they can simply
    use the key to encrypt their communications. But what if an adversary is passively
    snooping in on their conversation? Now the adversary has the symmetric key and
    can decrypt all encrypted content that Alice and Bob are sending to each other!
    This is where using a key exchange can be interesting for Alice and Bob (and for
    ourselves in the future). By using a key exchange, they can obtain a symmetric
    key that a passive observer won’t be able to reproduce.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密通信，Alice 可以使用你在第 4 章中了解到的认证加密原语。为此，Bob 需要知道相同的对称密钥，以便 Alice 可以生成一个并将其发送给
    Bob。之后，他们可以简单地使用该密钥来加密他们的通信。但是，如果有人窃听他们的对话怎么办？现在敌人拥有对称密钥，可以解密 Alice 和 Bob 互相发送的所有加密内容！这就是在这种情况下使用密钥交换可以对
    Alice 和 Bob（以及我们将来自己）有趣的地方。通过使用密钥交换，他们可以获得一个被动观察者无法复制的对称密钥。
- en: 'A *key exchange* starts with both Alice and Bob generating some keys. To do
    this, they both use a key generation algorithm, which generates a *key pair* :
    a private key (or secret key) and a public key. Alice and Bob then send their
    respective public keys to each other. *Public* here means that adversaries can
    observe those without consequences. Alice then uses Bob’s public key with her
    own private key to compute the shared secret. Bob can, similarly, use his private
    key with Alice’s public key to obtain the same shared secret. I illustrate this
    in figure 5.1.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*密钥交换* 从 Alice 和 Bob 生成一些密钥开始。为此，他们都使用一个密钥生成算法，生成一个*密钥对*：一个私钥（或秘密密钥）和一个公钥。然后
    Alice 和 Bob 将各自的公钥发送给对方。这里的 *公开* 意味着敌人可以观察到，但不会产生后果。然后 Alice 使用 Bob 的公钥和她自己的私钥计算共享密钥。同样地，Bob
    可以使用他的私钥和 Alice 的公钥来获得相同的共享密钥。我在图 5.1 中说明了这一点。'
- en: '![](../Images/05_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_01.jpg)'
- en: 'Figure 5.1 A key exchange provides the following interface: it takes your peer’s
    public key and your private key to produce a shared secret. Your peer can obtain
    the same shared secret by using your public key and their private key.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 一个密钥交换提供以下接口：它采用你的对等方的公钥和你的私钥生成一个共享密钥。你的对等方可以通过使用你的公钥和他们自己的私钥获得相同的共享密钥。
- en: Knowing how a key exchange works from a high level, we can now go back to our
    initial scenario and see how this helps. By starting their communication with
    a key exchange, Alice and Bob produce a shared secret to use as a key to an authenticated
    encryption primitive. Because any man-in-the-middle (MITM) adversaries observing
    the exchange cannot derive the same shared secret, they won’t be able to decrypt
    communications. I illustrate this in figure 5.2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次了解密钥交换的工作原理后，我们现在可以回到我们的初始情景，看看这如何帮助。通过以密钥交换开始他们的通信，Alice 和 Bob 生成了一个共享的密钥，用作身份验证加密原语的密钥。因为任何观察交换的中间人（MITM）对手都无法推导出相同的共享密钥，他们将无法解密通信。我在图
    5.2 中说明了这一点。
- en: '![](../Images/05_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_02.jpg)'
- en: Figure 5.2 A key exchange between two participants allows them to agree on a
    secret key, while a man-in-the-middle (MITM) adversary can’t derive the same secret
    key from passively observing the key exchange.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 两个参与者之间的密钥交换使他们能够就一个密钥达成一致，而中间人（MITM）对手无法通过被动观察密钥交换来推导出相同的密钥。
- en: Note that the MITM here is passive; an *active* MITM would have no problem intercepting
    the key exchange and impersonating both sides. In this attack, Alice and Bob would
    effectively perform a key exchange with the MITM, both thinking that they agreed
    on a key with each other. The reason this is possible is that none of our characters
    have a way to verify who the public key they receive really belongs to. The key
    exchange is *unauthenticated*! I illustrate the attack in figure 5.3.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的MITM是被动的；一个*主动的*MITM将没有问题拦截密钥交换并冒充双方。在这种攻击中，Alice 和 Bob 实际上将与MITM执行密钥交换，都认为他们已经就密钥达成了一致。之所以可能是因为我们的任何一个角色都没有办法验证他们收到的公钥真正属于谁。这个密钥交换是*未经身份验证*的！我在图
    5.3 中说明了这次攻击。
- en: '![](../Images/05_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_03.jpg)'
- en: Figure 5.3 An unauthenticated key exchange is vulnerable to an active MITM attacker.
    Indeed, the attacker can simply impersonate both sides of the connection and perform
    two separate key exchanges.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 一个未经身份验证的密钥交换容易受到主动的中间人攻击。事实上，攻击者可以简单地冒充连接的双方并执行两次单独的密钥交换。
- en: Let’s take a look at a different scenario to motivate *authenticated key exchanges*.
    Imagine that you want to run a service that gives you the time of day. Yet, you
    do not want this information to be modified by a MITM adversary. Your best bet
    is to authenticate your responses using the message authentication codes (MACs)
    you learned about in chapter 3\. As MACs require a key, you could simply generate
    one and share it manually with all of your users. But then, any user is now in
    possession of the MAC key you’re using with the others and might some day make
    use of it to perform the previously discussed MITM attack on someone else. You
    could set up a different key per user, but this is not ideal as well. For every
    new user that wants to connect to your service, you will need to manually provision
    both your service and the user with a new MAC key. It would be so much better
    if you didn’t have anything to do on the server side, wouldn’t it?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个不同的情景来激发*经过身份验证的密钥交换*。想象一下，你想运行一个给你提供当天时间的服务。然而，你不希望这个信息被中间人攻击者修改。你最好的选择是使用你在第三章学到的消息认证码（MACs）对你的响应进行身份验证。由于MACs需要一个密钥，你可以简单地生成一个并手动与所有用户共享。但是，现在任何用户都拥有与其他用户一起使用的MAC密钥，并且可能有一天会利用它对其他人执行前面讨论的MITM攻击。你可以为每个用户设置不同的密钥，但这也不理想。对于想要连接到你的服务的每个新用户，你都需要手动为你的服务和用户提供一个新的MAC密钥。如果服务器端不需要做任何事情就好多了，是不是？
- en: Key exchanges can help here! What you could do is have your service generate
    a key exchange key pair and provision any new user with the service’s public key.
    This is known as an *authenticated key exchange* ; your users know the server’s
    public key, and thus, an active MITM adversary cannot impersonate that side of
    the key exchange. What a malicious person can do, though, is to perform their
    own key exchange (as the client side of the connection is not authenticated).
    By the way, when both sides are authenticated, we call that a *mutually authenticated
    key exchange*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥交换可以在这里发挥作用！你可以做的是让你的服务生成一个密钥交换密钥对，并向服务的任何新用户提供服务的公钥。这被称为*身份验证密钥交换*；你的用户知道服务器的公钥，因此，主动的中间人对手无法冒充该密钥交换的一方。然而，一个恶意的人可以做的是执行他们自己的密钥交换（因为连接的客户端未经身份验证）。顺便说一句，当双方都经过身份验证时，我们称之为*双向身份验证密钥交换*。
- en: This scenario is extremely common, and the key exchange primitive allows it
    to scale well with an increase of users. But this scenario doesn’t scale well
    if the number of services increase as well! The internet is a good example of
    this. We have many browsers trying to communicate securely with many websites.
    Imagine if you had to hardcode the public key of all the websites you might one
    day visit in your browser and what happens when more websites come online?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况非常普遍，密钥交换原语使其能够随着用户数量的增加而扩展得很好。但是，如果服务数量也增加，这种情况就不容易扩展！互联网就是一个很好的例子。我们有许多浏览器试图与许多网站进行安全通信。想象一下，如果你不得不在浏览器中硬编码你可能有一天会访问的所有网站的公钥，以及当更多的网站上线时会发生什么？
- en: While key exchanges are useful, they do not scale well in all scenarios without
    their sister primitive—the *digital signature*. This is just a teaser though.
    In chapter 7, you will learn about that new cryptographic primitive and how it
    helps scaling trust in a system. Key exchanges are rarely used directly in practice,
    however. They are often just building blocks of a more complex protocol. That
    being said, they can still be useful on their own in certain situations (for example,
    as we saw previously against passive adversaries).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然密钥交换很有用，但在没有姊妹原语——*数字签名*的情况下，并不是所有情况下都能很好地扩展。不过这只是一个引子。在第 7 章中，你将了解到有关这种新的密码原语以及它如何帮助系统中的信任扩展的信息。密钥交换在实践中很少直接使用。它们通常只是更复杂协议的组成部分。话虽如此，在某些情况下它们仍然可以是有用的（例如，正如我们之前对抗被动对手时看到的）。
- en: Let’s now look at how you *would* use a key exchange cryptographic primitive
    in practice. libsodium is one of the most well known and widely used C/C++ libraries.
    The following listing shows how you would use libsodium in practice in order to
    perform a key exchange.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在实践中如何*使用*密钥交换密码原语。libsodium 是最知名和广泛使用的 C/C++ 库之一。以下示例显示了在实践中如何使用 libsodium
    来执行密钥交换。
- en: Listing 5.1 A key exchange in C
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 5.1 C 语言中的密钥交换示例
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Generates the client’s key pair
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成客户端的密钥对
- en: ❷ We assume that we have some way to obtain the server’s public key.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们假设我们有一种获取服务器公钥的方式。
- en: ❸ libsodium derives two symmetric keys instead of one per best practice; each
    key is used to encrypt a single direction.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ libsodium 根据最佳实践派生两个对称密钥，而不是一个；每个密钥用于加密单个方向。
- en: ❹ We perform a key exchange with our secret key and the server’s public key.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们使用我们的秘密密钥和服务器的公钥进行密钥交换。
- en: ❺ If the public key is malformed, the function returns an error.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果公钥格式错误，则函数返回错误。
- en: libsodium hides a lot of details from the developer while also exposing safe-to-use
    interfaces. In this instance, libsodium makes use of the *X25519 key exchange
    algorithm*, which you will learn more about later in this chapter. In the rest
    of this chapter, you will learn about the different standards used for key exchanges,
    as well as how they work under the hood.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: libsodium 将许多细节隐藏在开发者之外，同时还公开了安全可用的接口。在这种情况下，libsodium 使用 *X25519 密钥交换算法*，你将在本章后面更多了解这个算法。在本章的其余部分，你将了解有关密钥交换的不同标准以及它们在幕后的工作原理。
- en: 5.2 The Diffie-Hellman (DH) key exchange
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 Diffie-Hellman（DH）密钥交换
- en: In 1976, Whitfield Diffie and Martin E. Hellman wrote their seminal paper on
    the Diffie-Hellman (DH) key exchange algorithm entitled “New Direction in Cryptography.”
    What a title! DH was the first key exchange algorithm invented and one of the
    first formalizations of a public key cryptographic algorithm. In this section,
    I lay out the math foundations of this algorithm, explain how it works, and finally,
    talk about the standards that specify how to use it in a cryptographic application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1976年，Whitfield Diffie 和 Martin E. Hellman 发表了题为“密码学的新方向”的关键论文，介绍了 Diffie-Hellman（DH）密钥交换算法。多么响亮的标题啊！DH
    是第一个发明的密钥交换算法，也是第一个公钥加密算法的正式化之一。在本节中，我将阐述该算法的数学基础，解释其工作原理，并最终讨论规定如何在加密应用中使用它的标准。
- en: 5.2.1 Group theory
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 群论
- en: The DH key exchange is built on top of a field of mathematics called *group
    theory*, which is the base of most public key cryptography today. For this reason,
    I will spend some time in this chapter giving you the basics on group theory.
    I will do my best to provide good insights on how these algorithms work, but there’s
    no way around it, there is going to be some math.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: DH 密钥交换建立在一种称为*群论*的数学领域之上，这是当今大多数公钥加密的基础。因此，在本章中，我将花一些时间向你介绍群论的基础知识。我将尽力提供有关这些算法如何工作的深入见解，但无论如何，这都将涉及到一些数学。
- en: 'Let’s start with the obvious question: what’s a *group*? It’s two things:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个显而易见的问题开始：什么是*群*？它有两个方面：
- en: A set of elements
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组元素
- en: A special binary operation (like + or ×) defined on these elements
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些元素上定义的特殊二元运算（例如 + 或 ×）
- en: 'If the set and the operation manage to satisfy some properties, then we have
    a group. And, if we have a group, then we can do magical things . . . (more on
    that later). Note that DH works in a *multiplicative group* : a group where the
    multiplication is used as the defined binary operation. Due to this, the rest
    of the explanations use a multiplicative group as examples. I will also often
    omit the × symbol (for example, I will write *a* × *b* as *ab* instead).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合和运算能够满足一些属性，那么我们就有了一个群。如果我们有一个群，那么我们就可以做出神奇的事情......（稍后详述）。注意，DH 工作在一个*乘法群*中：一种使用乘法作为定义的二元运算的群。由于这一点，其余的解释使用乘法群作为示例。我也经常省略乘号符号（例如，我会将
    *a* × *b* 写成 *ab*）。
- en: I need to be a bit more specific here. For the set and its operation to be a
    group, they need the following properties. (As usual, I illustrate these properties
    in a more visual way in figure 5.4 to provide you with more material to grasp
    this new concept.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要在这里更加具体。为了使集合及其运算成为一个群，它们需要具有以下特性。（和往常一样，我会在图 5.4 中以更加视觉化的方式来说明这些特性，以提供更多材料来理解这个新概念。）
- en: '*Closure*—Operating on two elements results in another element of the same
    set. For example, for two elements of the group *a* and *b*, *a* × *b* results
    in another group element.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*封闭性*——对两个元素进行操作会得到同一集合的另一个元素。例如，对于群的两个元素 *a* 和 *b*，*a* × *b* 会得到另一个群元素。'
- en: '*Associativity*—Operating on several elements at a time can be done in any
    order. For example, for three elements of the group *a*, *b*, and *c*, then *a*(*bc*)
    and (*ab*)*c* result in the same group element.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结合性*——同时对几个元素进行操作可以按任意顺序进行。例如，对于群的三个元素 *a*、*b* 和 *c*，那么 *a*(*bc*) 和 (*ab*)*c*
    会得到相同的群元素。'
- en: '*Identity element*—Operating with this element does not change the result of
    the other operand. For example, we can define the identity element as 1 in our
    multiplicative group. For any group element *a*, we have *a* × 1 = *a*.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单位元素*——与此元素进行运算不会改变另一个操作数的结果。例如，我们可以在我们的乘法群中将单位元素定义为 1。对于任何群元素 *a*，我们有 *a*
    × 1 = *a*。'
- en: '*Inverse element*—Existing as an inverse to all group elements. For example,
    for any group element *a*, there’s an inverse element *a*^(–1) (also written as
    1/*a*) such that *a* × *a*^(–1) = 1 (also written as *a* × 1/*a* = 1).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逆元素*——存在一个逆元素与所有群元素相对应。例如，对于任何群元素 *a*，都存在一个逆元素 *a*^(–1)（也写作 1/*a*），使得 *a*
    × *a*^(–1) = 1（也写作 *a* × 1/*a* = 1）。'
- en: '![](../Images/05_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_04.jpg)'
- en: 'Figure 5.4 The four properties of a group: closure, associativity, identity
    element, and inverse element.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 群的四个属性：封闭性、结合性、单位元素和逆元素。
- en: 'I can imagine that my explanation of a group can be a bit abstract, so let’s
    see what DH uses as a group in practice. First, DH uses a group comprised of the
    set of strictly positive integers: 1, 2, 3, 4, ···, *p* – 1, where *p* is a prime
    number and 1 is the identity element. Different standards specify different numbers
    for *p*, but intuitively, it has to be a large prime number for the group to be
    secure.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想象我对群的解释可能有点抽象，所以让我们看看 DH 在实践中使用的群是什么。首先，DH 使用由严格正整数集合组成的群：1、2、3、4、····、*p*
    – 1，其中 *p* 是素数，1 是单位元素。不同的标准为 *p* 指定不同的数字，但直观地说，它必须是一个大素数，以确保群的安全性。
- en: Prime numbers
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 素数
- en: A *prime number* is a number that can only be divided by 1 or by itself. The
    first prime numbers are 2, 3, 5, 7, 11, and so on. Prime numbers are everywhere
    in asymmetric cryptography! And, fortunately, we have efficient algorithms to
    find large ones. To speed things up, most cryptographic libraries will instead
    look for *pseudo-primes* (numbers that have a high probability of being primes).
    Interestingly, such optimizations were broken several times in the past; the most
    infamous occurrence was in 2017, when the ROCA vulnerability uncovered more than
    a million devices generating incorrect primes for their cryptographic applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*素数* 是只能被 1 或它本身整除的数字。前几个素数是 2、3、5、7、11 等等。素数在非对称密码学中随处可见！而且，幸运的是，我们有高效的算法来找到大素数。为了加快速度，大多数密码库会寻找*伪素数*（有很高概率是素数的数字）。有趣的是，此类优化在过去几次被打破过；最臭名昭著的一次发生在
    2017 年，当时 ROCA 漏洞发现了超过一百万台设备为其密码应用生成了不正确的素数。'
- en: Second, DH uses the *modular multiplication* as a special operation. Before
    I can explain what modular multiplication is, I need to explain what *modular
    arithmetic* is. Modular arithmetic, intuitively, is about numbers that “wrap around”
    past a certain number called a *modulus*. For example, if we set the modulus to
    be 5, we say that numbers past 5 go back to 1; for example, 6 becomes 1, 7 becomes
    2, and so on. (We also note 5 as 0, but because it is not in our multiplicative
    group, we don’t care too much about it.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，DH 使用 *模乘法* 作为一种特殊操作。在我解释模乘法是什么之前，我需要解释什么是 *模算术*。直观地说，模算术是关于在达到一个称为*模数*的某个数后“环绕”的数字。例如，如果我们将模数设置为
    5，我们说超过 5 的数字回到 1；例如，6 变成 1，7 变成 2，依此类推。（我们也将 5 记为 0，但因为它不在我们的乘法群中，所以我们不太在乎它。）
- en: The mathematical way to express modular arithmetic is to take the *remainder*
    of a number and its *Euclidian division* with the modulus. Let’s take, for example,
    the number 7 and write its Euclidian division with 5 as 7 = 5 × 1 + 2\. Notice
    that the remainder is 2\. Then we say that 7 = 2 mod 5 (sometimes written as 7
    ≡ 2 (mod 5)). This equation can be read as 7 is congruent to 2 modulo 5\. Similarly
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表达模算术的数学方式是取一个数与其模数的*欧几里得除法*的余数。让我们以数字 7 为例，并将其与 5 进行欧几里得除法得到 7 = 5 × 1 + 2。注意余数为
    2。然后我们说 7 = 2 mod 5（有时写成 7 ≡ 2 (mod 5)）。这个方程可以读作 7 对模 5 同余于 2。同样地
- en: 8 = 1 mod 7
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 = 1 mod 7
- en: 54 = 2 mod 13
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 54 = 2 mod 13
- en: 170 = 0 mod 17
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 170 = 0 mod 17
- en: and so on
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等
- en: The classical way of picturing such a concept is with a clock. Figure 5.5 illustrates
    this concept.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 描绘这样一个概念的传统方式是用时钟。图 5.5 说明了这个概念。
- en: '![](../Images/05_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_05.jpg)'
- en: Figure 5.5 The group of integers modulo the prime number 5 can be pictured as
    a clock that resets to 0 after the number 4\. Thus 5 is represented as 0, 6 as
    1, 7 as 2, 8 as 3, 9 as 4, 10 as 0, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 整数模素数 5 的群可以被描绘成一个时钟，在数字 4 之后重新归零。因此 5 被表示为 0，6 被表示为 1，7 被表示为 2，8 被表示为
    3，9 被表示为 4，10 被表示为 0，依此类推。
- en: 'A modular multiplication is quite natural to define over such a set of numbers.
    Let’s take the following multiplication as an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一组数字上定义模乘法是相当自然的。让我们以以下乘法为例：
- en: 3 × 2 = 6
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 3 × 2 = 6
- en: 'With what you learned previously, you know that 6 is congruent to 1 modulo
    5, and thus the equation can be rewritten as:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你之前学到的知识，你知道 6 对模 5 同余于 1，因此方程可以重写为：
- en: 3 × 2 = 1 mod 5
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 3 × 2 = 1 mod 5
- en: 'Quite straightforward, isn’t it? Note that the previous equation tells us that
    3 is the inverse of 2 and vice versa. We could also write the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 相当直接，是吗？请注意，前一个方程告诉我们 3 是 2 的倒数，反之亦然。我们也可以写成以下形式：
- en: 3^(–1) = 2 mod 5
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 3^(–1) = 2 mod 5
- en: When the context is clear, the modulus part (mod 5 here) is often left out from
    equations. So don’t be surprised if I sometimes omit it in this book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文清晰时，方程中的模数部分（此处为 mod 5）通常会被省略。所以如果我在这本书中有时省略了它，请不要感到惊讶。
- en: Note It happens that when we use the positive numbers modulo a prime number,
    only the *zero* element lacks an inverse. (Indeed, can you find an element *b*
    such that 0 × *b* = 1 mod 5?) This is the reason why we do not include zero as
    one of our elements in the group.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注 事实上，当我们使用素数模下的正数时，只有*零*元素缺乏逆元。（确实，你能找到一个元素 *b* 使得 0 × *b* = 1 mod 5 吗？）这就是为什么我们不将零包含在群的元素中的原因。
- en: 'OK, we now have a group, which includes the set of strictly positive integers
    1, 2, ···, *p* – 1 for *p* a prime number, along with modular multiplication.
    The group we formed also happens to be two things:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有了一个组，其中包括严格正整数 1、2、···、*p* – 1，*p* 是一个素数，以及模乘法。我们形成的组也恰好是两者：
- en: '*Commutative*—The order of operations doesn’t matter. For example, given two
    group elements *a* and *b*, then *ab* = *ba*. A group that has this property is
    often called a *Galois group*.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交换性*——操作的顺序不重要。例如，给定两个群元素 *a* 和 *b*，则 *ab* = *ba*。具有此属性的群通常被称为*伽罗瓦群*。'
- en: '*A finite field*—A Galois group that has more properties, as well as an additional
    operation (in our example, we can also add numbers together).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有限域*——具有更多属性的伽罗瓦群，以及一个额外的运算（在我们的例子中，我们也可以将数字相加）。'
- en: Due to the last point, DH defined over this type of group is sometimes called
    *Finite Field Diffie-Hellman* (FFDH). If you understand what a group is (and make
    sure you do before reading any further), then a *subgroup* is just a group contained
    inside your original group. That is, it’s a subset of the group elements. Operating
    on elements of the subgroup results in another subgroup element, and every subgroup
    element has an inverse in the subgroup, etc.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最后一点，DH定义在这种类型的群上有时被称为*有限域Diffie-Hellman*（FFDH）。如果你理解什么是群（并确保在继续阅读之前理解），那么*子群*只是原始群中包含的一个群。也就是说，它是群元素的子集。在子群元素上操作会产生另一个子群元素，并且每个子群元素在子群中都有一个逆元素，等等。
- en: 'A *cyclic subgroup* is a subgroup that can be generated from a single *generator*
    (or *base*). A generator generates a cyclic subgroup by multiplying itself over
    and over. For example, the generator 4 defines a subgroup consisting of the numbers
    1 and 4:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环子群*是可以从单个*生成器*（或*基数*）生成的子群。生成器通过反复相乘来生成循环子群。例如，生成器4定义了由数字1和4组成的子群：'
- en: 4 mod 5 = 4
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 mod 5 = 4
- en: 4 × 4 mod 5 = 1
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 × 4 mod 5 = 1
- en: 4 × 4 × 4 mod 5 = 4 (we start again from the beginning)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 × 4 × 4 mod 5 = 4（我们从头开始）
- en: 4 × 4 × 4 × 4 mod 5 = 1
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 × 4 × 4 × 4 mod 5 = 1
- en: and so on
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以此类推
- en: Note  We can also write 4 × 4 × 4 as 43.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意  我们也可以将4 × 4 × 4写为43。
- en: It happens that when our modulus is prime, every element of our group is a generator
    of a subgroup. These different subgroups can have different sizes, which we call
    *orders*. I illustrate this in figure 5.6.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好当我们的模数是素数时，我们群中的每个元素都是一个子群的生成器。这些不同的子群可以有不同的大小，我们称之为*阶*。我在图5.6中进行了说明。
- en: '![](../Images/05_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_06.jpg)'
- en: Figure 5.6 The different subgroups of the multiplicative group modulo 5\. These
    all include the number 1 (called the *identity element*) and have different orders
    (number of elements).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 不同的模5乘法群的子群。这些都包括数字1（称为*单位元素*）并且具有不同的阶（元素数量）。
- en: All right, you now understand
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在你明白了
- en: A group is a set of numbers with a binary operation that respects some properties
    (closure, associativity, identity element, inverse element).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个群是一组具有二元运算的数字集合，遵守一些性质（封闭性，结合性，单位元素，逆元素）。
- en: DH works in the Galois group (a group with commutativity), formed by the set
    of strictly positive numbers up to a prime number (not included) and the modular
    multiplication.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DH在Galois群（一个具有交换性的群）中运行，由严格正数组成，直到一个素数（不包括在内）和模乘法形成。
- en: In a DH group, every element is a generator of a subgroup.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DH群中，每个元素都是一个子群的生成器。
- en: Groups are the center of a huge amount of different cryptographic primitives.
    It is important to have good intuitions about group theory if you want to understand
    how other cryptographic primitives work.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 群是大量不同加密原语的中心。如果你想要理解其他加密原语的工作原理，对群论有良好的直觉是很重要的。
- en: '5.2.2 The discrete logarithm problem: The basis of Diffie-Hellman'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 离散对数问题：Diffie-Hellman的基础
- en: The security of the DH key exchange relies on the *discrete logarithm problem*
    in a group, a problem believed to be hard to solve. In this section, I briefly
    introduce this problem.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: DH密钥交换的安全性依赖于群中的*离散对数问题*，这是一个被认为难以解决的问题。在本节中，我简要介绍这个问题。
- en: Imagine that I take a generator, let’s say 3, and give you a random element
    among the ones it can generate, let’s say 2 = 3^x mod 5 for some *x* unknown to
    you. Asking you “what is *x*?” is the same as asking you to find the discrete
    logarithm of 2 in base 3\. Thus, the discrete logarithm problem in our group is
    about finding out how many times we multiplied the generator with itself in order
    to produce a given group element. This is an important concept! Take a few minutes
    to think about it before continuing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我拿一个生成器，比如说3，然后给你一个它可以生成的随机元素，比如说2 = 3^x mod 5，其中*x*对你来说是未知的。问你“*x*是多少？”就等同于让你找到基于3的2的离散对数。因此，在我们的群中，离散对数问题就是找出我们将生成器与自身相乘多少次才能产生给定的群元素。这是一个重要的概念！在继续之前花几分钟思考一下。
- en: 'In our example group, you can quickly find that 3 is the answer (indeed, 3³
    = 2 mod 5). But if we picked a much larger prime number than 5, things get much
    more complicated: it becomes hard to solve. This is the secret sauce behind Diffie-Hellman.
    You now know enough to understand how to generate a key pair in DH:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例群中，你可以快速发现答案是3（确实，3³ = 2 mod 5）。但是，如果我们选择一个比5大得多的素数，事情就变得复杂得多：变得难以解决。这就是Diffie-Hellman背后的秘密。现在你已经了解如何在DH中生成密钥对了：
- en: All the participants must agree on a large prime *p* and a generator *g*.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有参与者都必须就一个大素数 *p* 和一个生成器 *g* 达成一致。
- en: Each participant generates a random number *x*, which becomes their private
    key.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个参与者都生成一个随机数 *x*，这个数就成了他们的私钥。
- en: Each participant derives their public key as *g*^x mod *p*.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个参与者都根据 *g*^x mod *p* 推导出他们的公钥。
- en: The fact that the discrete logarithm problem is *hard* means that no one should
    be able to recover the private key from the public key. I illustrate this in figure
    5.7.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 离散对数问题的“困难”意味着没有人应该能够从公钥中恢复出私钥。我在图 5.7 中进行了说明。
- en: '![](../Images/05_07.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_07.jpg)'
- en: Figure 5.7 Choosing a private key in Diffie-Hellman is like choosing an index
    in a list of numbers produced by a generator *g*. The discrete logarithm problem
    is to find the index from the number alone.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 在 Diffie-Hellman 中选择私钥就像在生成器 *g* 产生的数字列表中选择索引一样。离散对数问题就是仅凭数字找到索引的问题。
- en: 'While we do have algorithms to compute discrete logarithms, they are not efficient
    in practice. On the other hand, if I give you the solution *x* to the problem,
    you have extremely efficient algorithms at your disposal to check that, indeed,
    I provided you with the right solution: *g*^x mod *p*. If you are interested,
    the state-of-the-art technique to compute the modular exponentiation is called
    *square and multiply*. This computes the result efficiently by going through *x*
    bit by bit.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有算法来计算离散对数，但在实践中它们并不高效。另一方面，如果我给你问题的解 *x*，你就可以利用你手头上非常高效的算法来验证，确实我给你的是正确的解：*g*^x
    mod *p*。如果你感兴趣，计算模幂的最先进技术被称为“平方乘”。它通过逐位地遍历 *x* 来高效地计算结果。
- en: Note Like everything in cryptography, it is *not impossible* to find a solution
    by simply trying to guess. Yet, by choosing large enough parameters (here, a large
    prime number), it is possible to reduce the efficacy of such a search for a solution
    down to negligible odds. This means that even after hundreds of years of random
    tries, your odds of finding a solution should still be statistically close to
    zero.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意就像密码学中的一切一样，仅仅通过猜测来找到解决方案是*不可能*的。然而，通过选择足够大的参数（在这里，一个大素数），可以将寻找解决方案的效果降低到可以忽略的几率。这意味着即使经过数百年的随机尝试，你找到解决方案的几率仍然在统计上接近于零。
- en: Great. How do we use all of this math for our DH key exchange algorithm? Imagine
    that
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们如何利用所有这些数学知识来进行 DH 密钥交换算法呢？想象一下
- en: Alice has a private key *a* and a public key *A* = *g*^a mod *p*.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 有一个私钥 *a* 和一个公钥 *A* = *g*^a mod *p*。
- en: Bob has a private key *b* and a public key *B* = *g*^b mod *p*.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob 有一个私钥 *b* 和一个公钥 *B* = *g*^b mod *p*。
- en: 'With the knowledge of Bob’s public key, Alice can compute the shared secret
    as *B*^a mod *p*. Bob can do a similar computation with Alice’s public key and
    his own private key: *A*^b mod *p*. Naturally, we can see that these two calculations
    end up computing the same number:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 借助 Bob 的公钥，Alice 可以计算出共享秘密 *B*^a mod *p*。Bob 也可以利用 Alice 的公钥和他自己的私钥进行类似的计算：*A*^b
    mod *p*。自然地，我们可以看到这两个计算最终得到的结果是相同的：
- en: '*B*^a = (*g*^b)^a = *g*^(ab) = (*g*^a)^b = *A*^b mod *p*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*B*^a = (*g*^b)^a = *g*^(ab) = (*g*^a)^b = *A*^b mod *p*'
- en: And that’s the magic of DH. From an outsider’s point of view, just observing
    the public keys *A* and *B* does not help in any way to compute the result of
    the key exchange *g*^(ab) mod *p*. Next, you will learn about how real-world applications
    make use of this algorithm and the different standards that exist.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 DH 的魔力。从外部人士的角度来看，仅观察公钥 *A* 和 *B* 并不能以任何方式计算出密钥交换的结果 *g*^(ab) mod *p*。接下来，你将了解到现实世界的应用是如何利用这个算法以及存在的不同标准的。
- en: Computational and decisional Diffie-Hellman
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 计算和决策 Diffie-Hellman
- en: By the way, in theoretical cryptography, the idea that observing *g*^a mod *p*
    and *g*^b mod *p* does not help you to compute *g*^(ab) mod *p* is called the
    *computational Diffie-Hellman assumption* (CDH). It is often confused with the
    stronger *decisional Diffie-Hellman assumption* (DDH), which intuitively states
    that given *g*^a mod *p*, *g*^b mod *p*, and *z* mod *p*, nobody should be able
    to confidently guess if the latter element is the result of a key exchange between
    the two public keys (*g*^(ab) mod *p*) or just a random element of the group.
    Both are useful theoretical assumptions that have been used to build many different
    algorithms in cryptography.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在理论密码学中，观察*g*^a mod *p*和*g*^b mod *p*并不会帮助你计算*g*^(ab) mod *p*的想法被称为*计算Diffie-Hellman假设*（CDH）。它经常与更强的*决策Diffie-Hellman假设*（DDH）混淆，直观地说明了在给定*g*^a
    mod *p*，*g*^b mod *p*和*z* mod *p*的情况下，没有人应该能够自信地猜测后者是否是两个公钥之间的密钥交换结果（*g*^(ab)
    mod *p*）还是组中的随机元素。这两者都是有用的理论假设，已被用于构建密码学中的许多不同算法。
- en: 5.2.3 The Diffie-Hellman standards
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 Diffie-Hellman标准
- en: Now that you have seen how DH works, you can understand that participants need
    to agree on a set of parameters, specifically on a prime number *p* and a generator
    *g*. In this section, you’ll learn about how real-world applications choose these
    parameters and the different standards that exist.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了DH的工作原理，您可以理解参与者需要在一组参数上达成一致，具体来说是质数*p*和生成器*g*。在本节中，您将了解现实世界应用是如何选择这些参数以及存在的不同标准的。
- en: First things first is the prime number *p*. As I stated earlier, the bigger,
    the better. Because DH is based on the discrete logarithm problem, its security
    is directly correlated to the best attacks known on the problem. Any advances
    in this area can weaken the algorithm. With time, we managed to obtain a pretty
    good idea of how fast (or slow) these advances are and how much is enough security.
    The currently known best practices are to use a prime number of 2,048 bits.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是质数*p*。正如我之前所述，数字越大，效果越好。因为DH基于离散对数问题，其安全性与该问题已知的最佳攻击直接相关。该领域的任何进展都可能削弱算法。随着时间的推移，我们成功地对这些进展的速度（或缓慢程度）以及足够的安全性有了相当好的了解。目前已知的最佳实践是使用2048位的质数。
- en: Note In general, [https://keylength.com](https://keylength.com) summarizes recommendations
    on parameter lengths for common cryptographic algorithms. The results are taken
    from authoritative documents produced by research groups or government bodies
    like the ANSSI (France), the NIST (US), and the BSI (Germany). While they do not
    always agree, they often converge towards similar orders of magnitude.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 一般来说，[https://keylength.com](https://keylength.com) 总结了常见加密算法的参数长度建议。结果来自研究组织或政府机构（如法国国家信息安全局（ANSSI）、美国国家标准与技术研究所（NIST）和德国联邦信息安全办公室（BSI））发布的权威文件。虽然它们并不总是一致，但它们通常会趋于类似数量级。
- en: In the past, many libraries and software often generated and hardcoded their
    own parameters. Unfortunately, they were sometimes found to be either weak or,
    worse, completely broken. In 2016, someone found out that Socat, a popular command-line
    tool, had modified their default DH group with a broken one a year prior, raising
    the question whether this had been a mistake or an intentional backdoor. Using
    standardized DH groups might seem like a better idea, but DH is one of the unfortunate
    counterexamples. Only a few months after the Socat issue, Antonio Sanso, while
    reading RFC 5114, found that the standard had specified broken DH groups as well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，许多库和软件通常会生成和硬编码自己的参数。不幸的是，有时会发现它们要么是薄弱的，要么更糟，完全是破碎的。在2016年，有人发现了Socat，一个流行的命令行工具，一年前已经使用了一个损坏的默认DH组，这就引发了一个问题，这是一个错误还是一个有意的后门。使用标准化的DH组可能看起来像一个更好的主意，但是DH是不幸的反例之一。在Socat问题发生几个月后，安东尼奥·桑索（Antonio
    Sanso）在阅读RFC 5114时发现，该标准也指定了损坏的DH组。
- en: 'Due to all of these issues, newer protocols and libraries have converged towards
    either deprecating DH in favor of Elliptic Curve Diffie-Hellman (ECDH) or using
    the groups defined in the better standard, RFC 7919 ([https://www.rfc-editor.org/info/rfc7919](https://www.rfc-editor.org/info/rfc7919)).
    For this reason, best practice nowadays is to use RFC 7919, which defines several
    groups of different sizes and security. For example, ffdhe2048 is the group defined
    by the 2,048-bit prime modulus:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些问题，更新的协议和库已经趋于要么弃用DH以支持椭圆曲线Diffie-Hellman（ECDH），要么使用更好的标准RFC 7919（[https://www.rfc-editor.org/info/rfc7919](https://www.rfc-editor.org/info/rfc7919)）定义的群。因此，现在的最佳实践是使用RFC
    7919，它定义了几种不同大小和安全性的群。例如，ffdhe2048是由2,048位素数模定义的群：
- en: '*p*   =  3231700607131100730015351347782516336248805713348907517458843413926980683413621000279205636264016468'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*   =  3231700607131100730015351347782516336248805713348907517458843413926980683413621000279205636264016468'
- en: '54585563579353308169288290230805734726252735547424612457410262025279165729728627063003252634282131457669'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '54585563579353308169288290230805734726252735547424612457410262025279165729728627063003252634282131457669'
- en: '31414223654220941111348629991657478268034230553086349050635557712219187890332729569696129743856241741236'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '31414223654220941111348629991657478268034230553086349050635557712219187890332729569696129743856241741236'
- en: '23722519734640269185579776797682301462539793305801522685873076119753243646747585546071504389684494036613'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '23722519734640269185579776797682301462539793305801522685873076119753243646747585546071504389684494036613'
- en: 04976978128542959586595975670512838521327844685229255045682728791137200989318739591433741758378260002780
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 04976978128542959586595975670512838521327844685229255045682728791137200989318739591433741758378260002780
- en: '34973198552060607533234122603254684088120031105907484281003994966956119696956248629032338072839127039'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '34973198552060607533234122603254684088120031105907484281003994966956119696956248629032338072839127039'
- en: and with generator *g* = 2
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以及生成器*g* = 2
- en: Note It is common to choose the number 2 for the generator as computers are
    quite efficient at multiplying with 2 using a simple left shift (`<<`) instruction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 选择生成器的数字2是很常见的，因为计算机在使用简单的左移（`<<`）指令与2相乘时非常高效。
- en: The group size (or *order*) is also specified as *q* = (*p* – 1)/2\. This implies
    that both private keys and public keys will be around 2,048 bits size-wise. In
    practice, these are quite large sizes for keys (compare that with symmetric keys,
    for example, that are usually 128-bit long). You will see in the next section
    that defining a group over the elliptic curves allow us to obtain much smaller
    keys for the same amount of security.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 群大小（或*order*）也被指定为*q* = (*p* – 1)/2。这意味着私钥和公钥在大小上都会在2,048位左右。实际上，对于密钥来说，这些都是相当大的尺寸（例如，与通常为128位长的对称密钥相比）。您将在下一节中看到，通过定义椭圆曲线上的群，我们可以在相同的安全性下获得更小的密钥。
- en: 5.3 The Elliptic Curve Diffie-Hellman (ECDH) key exchange
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 椭圆曲线Diffie-Hellman（ECDH）密钥交换
- en: It turns out that the DH algorithm, which we just discussed, can be implemented
    in different types of groups, not just the multiplicative groups modulo a prime
    number. It also turns out that a group can be made from elliptic curves, a type
    of curves studied in mathematics. The idea was proposed in 1985 by Neal Koblitz
    and Victor S. Miller, independently, and much later in 2000, it was adopted when
    cryptographic algorithms based on elliptic curves started seeing standardization.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，我们刚刚讨论的DH算法可以在不同类型的群中实现，而不仅仅是模素数的乘法群。事实证明，一个群可以由数学中研究的一种曲线——椭圆曲线构成。这个想法是由Neal
    Koblitz和Victor S. Miller在1985年独立提出的，而在2000年，当基于椭圆曲线的加密算法开始标准化时，这个想法得到了采纳。
- en: The world of applied cryptography quickly adopted elliptic curve cryptography
    as it provided much smaller keys than the previous generation of public key cryptography.
    Compared to the recommended 2,048-bit parameters in DH, parameters of 256 bits
    were possible with the elliptic curve variant of the algorithm.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用密码学领域很快就采用了椭圆曲线密码学，因为它提供的密钥比上一代公钥密码学要小得多。与DH中建议的2,048位参数相比，椭圆曲线变体算法可以使用256位的参数。
- en: 5.3.1 What’s an elliptic curve?
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 什么是椭圆曲线？
- en: Let’s now explain how elliptic curves work. First and foremost, it is good to
    understand that elliptic curves are just curves! Meaning that they are defined
    by all the coordinates *x* and *y* that solves an equation. Specifically, this
    equation
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解释一下椭圆曲线是如何工作的。首先，首要的是要理解椭圆曲线只是曲线！这意味着它们由解方程的所有坐标*x*和*y*定义。具体来说，这个方程
- en: '*y*² + *a*[1]*xy* + *a*[3]*y* = *x*³ + *a*[2]*x*² + *a*[4]*x* + *a*[6]'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*² + *a*[1]*xy* + *a*[3]*y* = *x*³ + *a*[2]*x*² + *a*[4]*x* + *a*[6]'
- en: 'for some *a*[1], *a*[2], *a*[3], *a*[4], and *a*[6]. Note that for most practical
    curves today, this equation can be simplified as the *short Weierstrass equation*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些*a*[1]、*a*[2]、*a*[3]、*a*[4]和*a*[6]。注意，对于今天的大多数实用曲线，这个方程可以简化为*短Weierstrass方程*：
- en: '*y*² = *x*³ + *ax* + *b* (where 4*a*³ + 27*b*² ≠ 0)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*² = *x*³ + *ax* + *b*（其中4*a*³ + 27*b*² ≠ 0）'
- en: While the simplification is not possible for two types of curves (called *binary
    curves* and *curves of characteristic 3*), these are used rarely enough that we
    will use the Weierstrass form in the rest of this chapter. Figure 5.8 shows an
    example of an elliptic curve with two points taken at random.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于两种类型的曲线（称为*二进制曲线*和*特征3的曲线*），这种简化是不可能的，但这些曲线的使用频率很低，因此在本章的其余部分中我们将使用Weierstrass形式。图5.8显示了一个随机选取两个点的椭圆曲线示例。
- en: '![](../Images/05_08.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_08.jpg)'
- en: Figure 5.8 One example of an elliptic curve defined by an equation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 一个由方程定义的椭圆曲线示例。
- en: At some point in the history of elliptic curves, it was found that a *group*
    could be constructed over them. From there, implementing DH on top of these groups
    was straightforward. I will use this section to explain the intuition behind elliptic
    curve cryptography.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线的历史上的某个时候，人们发现可以在其上构建一个*群*。从那时起，在这些群上实现DH就变得简单了。我将利用这一节来解释椭圆曲线密码学背后的直觉。
- en: Groups over elliptic curves are often defined as *additive groups*. Unlike multiplicative
    groups defined in the previous section, the + sign is used instead.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线上的群通常被定义为*加法群*。与前一节中定义的乘法群不同，这里使用的是+号。
- en: Note Using an addition or a multiplication does not matter much in practice,
    it is just a matter of preference. While most of cryptography uses a multiplicative
    notation, the literature around elliptic curves has gravitated around an additive
    notation, and thus, this is what I will use when referring to elliptic curve groups
    in this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 在实践中，使用加法或乘法都没有太大关系，这只是一种偏好。虽然大多数密码学使用乘法符号，但围绕椭圆曲线的文献更倾向于使用加法符号，因此，在本书中提及椭圆曲线群时，我将使用这种表示法。
- en: This time, I will define the operation before defining the elements of the group.
    Our *addition operation* is defined in the following way. Figure 5.9 illustrates
    this process.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我会在定义群的元素之前定义操作。我们的*加法操作*定义如下。图5.9说明了这个过程。
- en: Draw a line going through two points that you want to add. The line hits the
    curve at another point.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一条穿过你想要相加的两个点的直线。这条直线在曲线上又碰到另一个点。
- en: Draw a vertical line from this newly found point. The vertical line hits the
    curve in yet another point.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个新找到的点画一条垂直线。垂直线在曲线上又碰到另一个点。
- en: This point is the result of adding the original two points together.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一点是将原始两点相加的结果。
- en: '![](../Images/05_09.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_09.jpg)'
- en: Figure 5.9 An addition operation can be defined over points of an elliptic curve
    by using geometry.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 通过几何方法可以在椭圆曲线的点上定义加法操作。
- en: 'There are two special cases where this rule won’t work. Let’s define these
    as well:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种特殊情况，这个规则不适用。我们也定义一下这两种情况：
- en: '*How do we add a point to itself ?* The answer is to draw the tangent to that
    point (instead of drawing a line between two points).'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们如何将一个点加到自身？*答案是画出该点的切线（而不是在两点之间画一条线）。'
- en: '*What happens if the line we draw in step 1 (or step 2) does not hit the curve
    at any other point?* Well, this is embarrassing, and we need this special case
    to work and produce a result. The solution is to define the result as a made-up
    point (something we make up). This newly invented point is called the *point at
    infinity* (that we usually write with a big letter *O*). Figure 5.10 illustrates
    these special cases.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果我们在第1步（或第2步）画的线不在曲线上碰到任何其他点会发生什么？*嗯，这很尴尬，我们需要这种特殊情况来产生一个结果。解决方案是将结果定义为一个虚构的点（我们自己编造的）。这个新发明的点称为*无穷远点*（通常用大写字母*O*表示）。图5.10说明了这些特殊情况。'
- en: '![](../Images/05_10.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_10.jpg)'
- en: Figure 5.10 Building on figure 5.9, addition on an elliptic curve is also defined
    when adding a point to itself or when two points cancel each other to result in
    the point at infinity (*O*).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 在图5.9的基础上构建，当将一个点与自身相加或当两个点相互抵消以得到无穷远点（*O*）时，也定义了在椭圆曲线上的加法。
- en: 'I know this point at infinity is some next-level weirdness, but don’t worry
    too much about it. It is really just something we came up with in order to make
    the addition operation work. Oh, and by the way, it behaves like a zero, and it
    is our identity element:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这个无穷点有些超级奇怪，但不要太担心。它实际上只是我们为了使加法运算有效而想出来的东西。哦，顺便说一下，它的行为就像一个零，它是我们的恒等元素：
- en: '*O* + *O* = *O*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*O* + *O* = *O*'
- en: and for any point *P* on the curve
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于曲线上的任意点*P*
- en: '*P* + *O* = *P*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* + *O* = *P*'
- en: All good. So far, we saw that to create a group on top of an elliptic curve,
    we need
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好。到目前为止，我们看到要在椭圆曲线上创建一个群，我们需要
- en: An elliptic curve equation that defines a set of valid points.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一组有效点的椭圆曲线方程。
- en: A definition of what addition means in this set.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个集合中定义加法的定义。
- en: An imaginary point called a point at infinity.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个称为无穷点的虚拟点。
- en: I know this is a lot of information to unpack, but we are missing one last thing.
    Elliptic curve cryptography makes use of the previously-discussed type of group
    defined over a *finite field*. In practice, what this means is that our coordinates
    are the numbers 1, 2, ···, *p* – 1 for some large prime number *p*. This should
    sound familiar! For this reason, when thinking of elliptic curve cryptography,
    you should think of a graph that looks much more like the one on the right in
    figure 5.11.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这是很多需要理解的信息，但我们还缺少最后一点。椭圆曲线密码学利用之前讨论过的在*有限域*上定义的一种群类型。在实践中，这意味着我们的坐标是数字1、2、···、*p*
    – 1，其中*p*是某个大素数。这应该听起来很熟悉！因此，当考虑椭圆曲线密码学时，您应该想象一个图形，它看起来更像图5.11右侧的图形。
- en: '![](../Images/05_11.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_11.jpg)'
- en: Figure 5.11 Elliptic curve cryptography (ECC), in practice, is mostly specified
    with elliptic curves in coordinates modulo a large prime number *p*. This means
    that what we use in cryptography looks much more like the right graph than the
    left graph.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 椭圆曲线密码学（ECC）在实践中，主要是通过模一个大素数*p*的坐标椭圆曲线来指定。这意味着在密码学中使用的内容更像右图而不是左图。
- en: And that’s it! We now have a group we can do cryptography on, the same way we
    had a group made with the numbers (excluding 0) modulo a prime number and a multiplication
    operation for Diffie-Hellman. How can we do Diffie-Hellman with this group defined
    on elliptic curves? Let’s see how the *discrete logarithm* works now in this group.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在有了一个可以进行密码学运算的群，就像我们之前使用的是模一个素数的数字（排除0）和Diffie-Hellman的乘法运算一样。我们如何在椭圆曲线上定义的这个群上进行Diffie-Hellman呢？现在让我们来看看在这个群中*离散对数*是如何工作的。
- en: Let’s take a point *G* and add it to itself *x* times to produce another point
    *P* via the addition operation we defined. We can write that as *P* = *G* + ···
    + *G* (*x* times) or use some mathematical syntactic sugar to write that as *P*
    = [*x*]*G*, which reads *x* times *G*. The *elliptic curve discrete logarithm
    problem* (ECDLP) is to find the number *x* from knowing just *P* and *G*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取一个点*G*，并将其加上自身*x*次以通过我们定义的加法操作产生另一个点*P*。我们可以写成*P* = *G* + ··· + *G*（*x*次）或者使用一些数学上的糖来写成*P*
    = [*x*]*G*，读作*x*倍的*G*。椭圆曲线离散对数问题（ECDLP）就是要从仅知道*P*和*G*的情况下找到数字*x*。
- en: Note We call [*x*]*G* scalar multiplication as *x* is usually called a scalar
    in such groups.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 我们将[*x*]*G*标量乘法称为在这种群中通常称为标量的*x*。
- en: 5.3.2 How does the Elliptic Curve Diffie-Hellman (ECDH) key exchange work?
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 椭圆曲线Diffie-Hellman（ECDH）密钥交换如何工作？
- en: 'Now that we built a group on elliptic curves, we can instantiate the same Diffie-Hellman
    key exchange algorithm on it. To generate a key pair in ECDH:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在椭圆曲线上构建了一个群，我们可以在其上实例化相同的Diffie-Hellman密钥交换算法。要在ECDH中生成密钥对：
- en: All the participants agree on an elliptic curve equation, a finite field (most
    likely a prime number), and a generator *G* (usually called a *base point* in
    elliptic curve cryptography).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有参与者都同意一个椭圆曲线方程，一个有限域（很可能是一个素数），以及一个生成元*G*（在椭圆曲线密码学中通常称为*基点*）。
- en: Each participant generates a random number *x*, which becomes their private
    key.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个参与者生成一个随机数*x*，这个随机数成为他们的私钥。
- en: Each participant derives their public key as [*x*]*G*.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个参与者将他们的公钥派生为[*x*]*G*。
- en: Because the elliptic curve discrete logarithm problem is hard, you guessed it,
    no one should be able to recover your private key just by looking at your public
    key. I illustrate this in figure 5.12.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为椭圆曲线离散对数问题很困难，你猜对了，没有人应该能够仅仅通过查看你的公钥就恢复出你的私钥。我在图5.12中有例证。
- en: '![](../Images/05_12.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_12.jpg)'
- en: Figure 5.12 Choosing a private key in ECDH is like choosing an index in a list
    of numbers produced by a generator (or base point) *G*. The Elliptic Curve Discrete
    Logarithm Problem (ECDLP) is to find the index from the number alone.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 在 ECDH 中选择一个私钥就像在由生成器（或基点）*G* 产生的数字列表中选择一个索引一样。椭圆曲线离散对数问题（ECDLP）是仅通过数字找到索引。
- en: All of this might be a bit confusing as the operation we defined for our DH
    group was the multiplication, and for an elliptic curve, we now use addition.
    Again, these distinctions do not matter at all because they are equivalent. You
    can see a comparison in figure 5.13.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可能有点令人困惑，因为我们为 DH 群定义的操作是乘法，而对于椭圆曲线，我们现在使用加法。再次强调，这些区别完全不重要，因为它们是等价的。您可以在图
    5.13 中看到比较。
- en: '![](../Images/05_13.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_13.jpg)'
- en: Figure 5.13 Some comparisons between the group used in Diffie-Hellman and the
    group used in Elliptic Curve Diffie-Hellman (ECDH).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 比较了在 Diffie-Hellman 中使用的群与在椭圆曲线 Diffie-Hellman（ECDH）中使用的群。
- en: You should now be convinced that the only thing that matters for cryptography
    is that we have a group defined with its operation, and that the discrete logarithm
    for this group is hard. For completion, figure 5.14 shows the difference between
    the discrete logarithm problem in the two types of groups we’ve seen.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该相信，对于密码学来说唯一重要的是我们有一个定义了操作的群，并且该群的离散对数是困难的。为了完整起见，图 5.14 展示了我们所见过的两种类型群中离散对数问题的差异。
- en: '![](../Images/05_14.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_14.jpg)'
- en: Figure 5.14 A comparison between the discrete logarithm problem modulo large
    primes and the discrete logarithm problem in elliptic curve cryptography (ECC).
    They both relate to the DH key exchange, as the problem is to find the private
    key from a public key.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 在大质数模下的离散对数问题与椭圆曲线密码学（ECC）中的离散对数问题的比较。它们都与 DH 密钥交换有关，因为问题是从公钥中找到私钥。
- en: A last note on the theory, the group we formed on top of elliptic curves differs
    with the group we formed with the strictly positive integers modulo a prime number.
    Due to some of these differences, the strongest attacks known against DH (known
    as *index calculus* or *number field sieve* attacks) do not work well on the elliptic
    curve groups. This is the main reason why parameters for ECDH can be much lower
    than the parameters for DH at the same level of security.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于理论的最后一点说明，我们在椭圆曲线之上形成的群与我们在严格正整数模素数之上形成的群不同。由于一些差异，已知的对 DH 的最强攻击（称为*索引演算法*或*数域筛*攻击）在椭圆曲线群上并不起作用。这是为什么
    ECDH 的参数可以远远低于相同安全级别下 DH 的参数的主要原因。
- en: OK, we are done with the theory. Let’s go back to defining ECDH. Imagine that
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经结束了理论部分。让我们回到定义 ECDH。想象一下
- en: Alice has a private key *a* and a public key *A* = [*a*]*G*.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 有一个私钥 *a* 和一个公钥 *A* = [*a*]*G*。
- en: Bob has a private key *b* and a public key *B* = [*b*]*G*.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob 有一个私钥 *b* 和一个公钥 *B* = [*b*]*G*。
- en: 'With the knowledge of Bob’s public key, Alice can compute the shared secret
    as [*a*]*B*. Bob can do a similar computation with Alice’s public key and his
    own private key: [*b*]*A*. Naturally, we can see that these two calculations end
    up computing the same number:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 Bob 的公钥知识后，Alice 可以计算出共享密钥为 [*a*]*B*。Bob 可以用 Alice 的公钥和他自己的私钥进行类似的计算：[*b*]*A*。自然地，我们可以看到这两个计算最终得到相同的数字：
- en: '[*a*]*B* = [*a*][*b*]*G* = [*ab*]*G* = [*b*][*a*]*G* = [*b*]*A*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[*a*]*B* = [*a*][*b*]*G* = [*ab*]*G* = [*b*][*a*]*G* = [*b*]*A*'
- en: No passive adversary should be able to derive the shared point just from observing
    the public keys. Looks familiar, right? Next, let’s talk about standards.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 没有被动的对手应该能够仅通过观察公钥来推导出共享点。听起来很熟悉，对吧？接下来，让我们谈谈标准。
- en: 5.3.3 The standards for Elliptic Curve Diffie-Hellman
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 椭圆曲线 Diffie-Hellman 的标准
- en: '*Elliptic curve cryptography has remained at its full strength since it was
    first presented in 1985\. [. . .] The United States, the UK, Canada and certain
    other NATO nations have all adopted some form of elliptic curve cryptography for
    future systems to protect classified information throughout and between their
    governments*.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*自 1985 年首次提出以来，椭圆曲线密码学一直保持着它的完整性。[...] 美国、英国、加拿大和某些其他北约国家都已经采用了某种形式的椭圆曲线密码学来保护政府之间和之内的机密信息*。'
- en: —NSA (“The Case for Elliptic Curve Cryptography,” 2005)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: —NSA（《椭圆曲线密码学的理由》，2005 年）
- en: The standardization of ECDH has been pretty chaotic. Many standardization bodies
    have worked to specify a large number of different curves, which was then followed
    by many flame wars over which curve was more secure or more efficient. A large
    amount of research, mostly led by Daniel J. Bernstein, pointed out the fact that
    a number of curves standardized by NIST could potentially be part of a weaker
    class of curves only known to NSA.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ECDH 的标准化过程相当混乱。许多标准化机构努力指定许多不同的曲线，然后引发了许多关于哪个曲线更安全或更高效的争论。由 Daniel J. Bernstein
    领导的大量研究指出了 NIST 标准化的一些曲线可能属于 NSA 所知的更弱的曲线类别。
- en: '*I no longer trust the constants. I believe the NSA has manipulated them through
    their relationships with industry*.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不再相信这些常数。我相信美国国家安全局通过与行业的关系来操纵它们*。'
- en: —Bruce Schneier (“The NSA Is Breaking Most Encryption on the Internet,” 2013)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ——Bruce Schneier（“美国国家安全局正在破解互联网上的大多数加密”，2013）
- en: 'Nowadays, most of the curves in use come from a couple standards, and most
    applications have fixated on two curves: P-256 and Curve25519\. In the rest of
    this section, I will go over these curves.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数使用的曲线都来自一对标准，大多数应用都固定在两条曲线上：P-256 和 Curve25519。在本节的其余部分，我将介绍这些曲线。
- en: 'NIST FIPS 186-4, “Digital Signature Standard,” initially published as a standard
    for signatures in 2000, contains an appendix specifying 15 curves for use in ECDH.
    One of these curves, P-256, is the most widely used curve on the internet. The
    curve was also specified in Standards for Efficient Cryptography (SEC) 2, v2,
    “Recommended Elliptic Curve Domain Parameters,” published in 2010 under a different
    name, secp256r1\. P-256 is defined with the short Weierstrass equation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: NIST FIPS 186-4，“数字签名标准”，最初作为 2000 年签名的标准发布，其中包含一个附录，指定了15个用于 ECDH 的曲线。其中一条曲线，P-256，在互联网上是最广泛使用的曲线。该曲线还在
    2010 年以不同名称 secp256r1 发布的 “高效密码标准” (SEC) 2，v2 中指定。P-256 使用短 Weierstrass 方程定义：
- en: '*y*² = *x*³ + *ax* + *b* mod *p*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*² = *x*³ + *ax* + *b* mod *p*'
- en: where *a* = –3 and
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* = –3，而
- en: '*b* = 41058363725152142129326129780047268409114441015993725554835256314039467401291'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*b* = 41058363725152142129326129780047268409114441015993725554835256314039467401291'
- en: and
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '*p* = 2^(256) – 2^(224) + 2^(192) + 2^(96) – 1'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*p* = 2^(256) – 2^(224) + 2^(192) + 2^(96) – 1'
- en: 'This defines a curve of prime order:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个素数阶的曲线：
- en: '*n* = 115792089210356248762697446949407573529996955224135760342422259061068512044369'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* = 115792089210356248762697446949407573529996955224135760342422259061068512044369'
- en: meaning that there are exactly *n* points on the curve (including the point
    at infinity). The base point is specified as
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着曲线上确切有 *n* 个点（包括无穷远处的点）。基点被指定为
- en: '*G* = (48439561293906451759052585252797914202762949526041747995844080717082404635286,
    36134250956749795798585127919587881956611106672985015071877198253568414405109)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*G* = (48439561293906451759052585252797914202762949526041747995844080717082404635286,
    36134250956749795798585127919587881956611106672985015071877198253568414405109)'
- en: The curve provides 128 bits of security. For applications that are using other
    cryptographic algorithms providing 256-bit security instead of 128 bits of security
    (for example, AES with a 256-bit key), P-521 is available in the same standard
    to match the level of security.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该曲线提供了128位的安全性。对于使用其他提供256位安全性而不是128位安全性的密码算法（例如，具有256位密钥的 AES）的应用程序，同样标准中还提供了
    P-521，以匹配安全级别。
- en: Can we trust P-256?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能相信 P-256 吗？
- en: Interestingly, P-256 and other curves defined in FIPS 186-4 are said to be generated
    from a *seed*. For P-256, the seed is known to be the byte string
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，FIPS 186-4 中定义的 P-256 和其他曲线据说是从一个 *seed* 生成的。对于 P-256，种子已知为字节字符串
- en: '0xc49d360886e704936a6678e1139d26b7819f7e90'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '0xc49d360886e704936a6678e1139d26b7819f7e90'
- en: I talked about this notion of “nothing-up-my-sleeve” numbers before—constants
    that aim to prove that there was no room for backdooring the design of the algorithm.
    Unfortunately, there isn’t much explanation behind the P-256 seed other than the
    fact that it is specified along the curve’s parameter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前谈过“什么都没有藏在我袖子里”的概念——旨在证明算法设计没有后门的常数。不幸的是，除了指定沿曲线参数的事实之外，对 P-256 种子几乎没有解释。
- en: 'RFC 7748, “Elliptic Curves for Security,” which was published in 2016, specifies
    two curves: Curve25519 and Curve448\. Curve25519 offers approximately 128 bits
    of security, while Curve448 offers around 224 bits of security for protocols that
    want to hedge against potential advances in the state of attacks against elliptic
    curves. I will only talk about Curve25519 here, which is a Montgomery curve defined
    by the equation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 7748，“用于安全的椭圆曲线”，于2016年发布，规定了两个曲线：Curve25519 和 Curve448。Curve25519 提供了大约128位的安全性，而
    Curve448 则提供了大约224位的安全性，用于协议希望对椭圆曲线的攻击潜力进行防范。我这里只会谈论 Curve25519，它是由以下方程定义的蒙哥马利曲线：
- en: '*y*² = *x*³ + 486662 *x*² + *x* mod *p*, where *p* = 2^(255) – 19'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*² = *x*³ + 486662 *x*² + *x* mod *p*，其中 *p* = 2^(255) – 19'
- en: Curve25519 has an order
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Curve25519 的阶数为
- en: '*n* = 2^(252) + 27742317777372353535851937790883648493'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* = 2^(252) + 27742317777372353535851937790883648493'
- en: and the base point used is
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的基点为
- en: '*G* = (9, 14781619447589544791020593568409986887264606134616475288964881837755586237401)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*G* = (9, 14781619447589544791020593568409986887264606134616475288964881837755586237401)'
- en: The combination of ECDH with Curve25519 is often dubbed *X25519*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ECDH 与 Curve25519 的结合常被称为 *X25519*。
- en: 5.4 Small subgroup attacks and other security considerations
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 小子群攻击和其他安全考虑
- en: Today, *I would advise you to use ECDH over DH* due to the size of the keys,
    the lack of known strong attacks, the quality of the available implementations,
    and the fact that elliptic curves are fixed and well standardized (as opposed
    to DH groups, which are all over the place). The latter point is quite important!
    Using DH means potentially using broken standards (like RFC 5114 mentioned previously),
    protocols that are too relaxed (many protocols, like older versions of TLS, don’t
    mandate what DH groups to use), software that uses broken custom DH groups (the
    socat issue mentioned previously), and so on.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，*我建议您使用 ECDH 而不是 DH*，原因是密钥的大小、已知强攻击的缺乏、可用实现的质量，以及椭圆曲线的固定性和良好的标准化（与 DH 群相反，后者随处可见）。后者一点非常重要！使用
    DH 可能意味着使用破损的标准（如前面提到的 RFC 5114），过于松散的协议（许多协议，如较旧版本的 TLS，不强制使用什么样的 DH 群），使用破损的自定义
    DH 群的软件（前面提到的 socat 问题），等等。
- en: 'If you do have to use Diffie-Hellman, make sure to *stick to the standards*.
    The standards I mentioned previously make use of safe primes as modulus: primes
    of the form *p* = 2*q* + 1 where *q* is another prime number. The point is that
    groups of this form only have two subgroups: a small one of size 2 (generated
    by –1) and a large one of size *q*. (This is the best you can get, by the way;
    there exist no prime-order groups in DH.) The scarcity of small subgroups prevent
    a type of attack known as *small subgroup attack* (more on that later). Safe primes
    create secure groups because of two things:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实必须使用 Diffie-Hellman，请确保*遵循标准*。我之前提到的标准使用安全素数作为模数：形式为 *p* = 2*q* + 1 的素数，其中
    *q* 是另一个素数。关键是，这种形式的群只有两个子群：大小为2的小子群（由–1生成）和大小为 *q* 的大子群。（顺便说一句，这是您能得到的最好的结果；在
    DH 中不存在素数阶群。）小子群的稀缺性防止了一种被称为*小子群攻击*的攻击（稍后详细说明）。安全素数创建了安全群，因为有两个因素：
- en: The order of a multiplicative group modulo a prime *p* is calculated as p –
    1.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模素数 *p* 的乘法群的阶数计算为 p – 1。
- en: The order of a group’s subgroups are the factors of the group’s order (this
    is the Lagrange theorem).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个群的子群的阶数是该群的阶数的因数（这就是拉格朗日定理）。
- en: Hence, the order of our multiplicative group modulo a safe prime is *p* – 1
    = (2*q* + 1) – 1 = 2*q* that has factors 2 and *q*, which means that its subgroups
    can only be of order 2 or *q*. In such groups, small subgroup attacks are not
    possible because there are not enough small subgroups. A *small subgroup attack*
    is an attack on key exchanges in which an attacker sends several invalid public
    keys to leak bits of your private key gradually, and where the invalid public
    keys are generators of small subgroups.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们模素数的乘法群的阶数是 *p* – 1 = (2*q* + 1) – 1 = 2*q*，它的因数为2和 *q*，这意味着它的子群只能是阶数为2或
    *q* 的子群。在这样的群中，小子群攻击是不可能的，因为没有足够的小子群。*小子群攻击* 是一种针对密钥交换的攻击，攻击者会逐渐发送几个无效的公钥来逐渐泄漏您的私钥的位，而无效的公钥是小子群的生成器。
- en: For example, an attacker could choose –1 (the generator of a subgroup of size
    2) as public key and send it to you. By doing your part of the key exchange, the
    resulting shared secret is an element of the small subgroup (–1 or 1). This is
    because you just raised the small subgroup generator (the attacker’s public key)
    to the power of your private key. Depending on what you do with that shared secret,
    the attacker could guess what it is, and leak some information about your private
    key.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，攻击者可以选择–1（大小为2的子群的生成器）作为公钥，并将其发送给你。通过执行你的密钥交换部分，结果的共享密钥是小子群的一个元素（–1或1）。这是因为你只是将小子群的生成器（攻击者的公钥）提升到你的私钥的幂。根据你对共享密钥的处理方式，攻击者可以猜测它是什么，并泄露关于你的私钥的一些信息。
- en: 'With our example of malicious public key, if your private key was even, the
    shared secret would be 1, and if your private key was odd, the shared secret would
    be –1\. As a result, the attacker learned one bit of information: the least significant
    bit of your private key. Many subgroups of different sizes can lead to more opportunities
    for the attacker to learn more about your private key until the entire key is
    recovered. I illustrate this issue in figure 5.15.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们恶意公钥的示例，如果你的私钥是偶数，则共享密钥将为1，如果你的私钥是奇数，则共享密钥将为–1。因此，攻击者了解了一个信息位：你的私钥的最低有效位。许多不同大小的子群可以导致攻击者有更多机会了解你的私钥，直到整个密钥被恢复。我在图5.15中说明了这个问题。
- en: '![](../Images/05_15.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05_15.jpg)'
- en: Figure 5.15 A small subgroup attack impacts DH groups that have many subgroups.
    By choosing generators of small subgroups as public keys, an attacker can leak
    bits of someone’s private key little by little.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15小子群攻击影响具有许多子群的DH群。通过选择小子群的生成器作为公钥，攻击者可以逐渐泄露某人的私钥的位。
- en: While it is always a good idea to verify if the public key you receive is in
    the correct subgroup, not all implementations do that. In 2016, a group of researchers
    analyzed 20 different DH implementations and found that none were validating public
    keys (see “Measuring small subgroup attacks against Diffie-Hellman” from Valenta
    et al.) Make sure that the DH implementations you’re using do! You can do this
    by raising the public key to the order of the subgroup, which should give you
    back the identity element if it is an element of that subgroup.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然始终验证接收到的公钥是否位于正确的子群中是一个好主意，但并不是所有的实现都这样做。2016年，一组研究人员分析了20种不同的DH实现，并发现没有一个在验证公钥（参见
    Valenta等人的“Measuring small subgroup attacks against Diffie-Hellman”）。确保你正在使用的DH实现是这样做的！你可以通过将公钥提升到子群的阶，如果它是该子群的元素，那么应该返回恒等元。
- en: On the other hand, elliptic curves allow for groups of prime order. That is,
    they have no small subgroups (besides the subgroup of size 1 generated by the
    identity element), and thus, they are secure against small subgroup attacks. Well,
    not so fast . . . In 2000, Biehl, Meyer, and Muller found that small subgroup
    attacks are possible even in such prime-order elliptic curve groups due to an
    attack called *invalid curve attack*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，椭圆曲线允许素数阶的群。也就是说，它们没有小子群（除了由恒等元素生成的大小为1的子群），因此它们对小子群攻击是安全的。好吧，不要那么快……在2000年，Biehl、Meyer和Muller发现即使在这样的素数阶椭圆曲线群中，也可能发生小子群攻击，原因是一种被称为*无效曲线攻击*的攻击。
- en: 'The idea behind invalid curve attacks is the following. First, the formulas
    to implement scalar multiplication for elliptic curves that use the short Weierstrass
    equation *y*² = *x*³ + *ax* + *b* (like NIST’s P-256) are independent of the variable
    *b*. This means that an attacker can find different curves with the same equation
    except for the value *b*, and some of these curves will have many small subgroups.
    You probably know where this is going: the attacker chooses a point in another
    curve that exhibits small subgroups and sends it to a targeted server. The server
    goes on with the key exchange by performing a scalar multiplication with the given
    point, effectively doing a key exchange on a different curve. This trick ends
    up re-enabling the small subgroup attack, even on prime-order curves.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 无效曲线攻击背后的思想是这样的。首先，为了实现使用短 Weierstrass 方程*y*² = *x*³ + *ax* + *b*（如NIST的P-256）的椭圆曲线的标量乘法，与变量*b*无关。这意味着攻击者可以找到具有相同方程的不同曲线，除了值*b*之外，其中一些曲线将具有许多小的子群。你可能知道这将导致什么：攻击者选择另一个曲线中具有小子群的点，并将其发送到目标服务器。服务器通过对给定点执行标量乘法来继续进行密钥交换，从而有效地在不同的曲线上进行密钥交换。这个技巧最终重新启用了小子群攻击，即使在素数阶曲线上也是如此。
- en: The obvious way to fix this is to, again, validate public keys. This can be
    done easily by checking if the public key is not the point at infinity and by
    plugging the received coordinates into the curve equation to see if it describes
    a point on the defined curve. Unfortunately, in 2015, Jager, Schwenk, and Somorovsky
    showed in “Practical Invalid Curve Attacks on TLS-ECDH” that several popular implementations
    did not perform these checks. If using ECDH, I would advise you to use the X25519
    key exchange due to the quality of the design (which takes into account invalid
    curve attacks), the quality of available implementations, and the resistance against
    timing attacks by design.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题的明显方法是再次验证公钥。这可以通过检查公钥不是无穷远点，并将接收到的坐标插入曲线方程中来轻松完成。看看它是否描述了定义曲线上的一个点。不幸的是，在
    2015 年，Jager、Schwenk 和 Somorovsky 在“Practical Invalid Curve Attacks on TLS-ECDH”中展示了几个流行实现没有执行这些检查。如果使用
    ECDH，我建议你使用 X25519 密钥交换，因为它考虑了无效曲线攻击，可用实现的质量以及设计上对抗时序攻击的抵抗力。
- en: 'Curve25519 has one caveat though—it is not a prime-order group. The curve has
    two subgroups: a small subgroup of size 8 and a large subgroup used for ECDH.
    On top of that, the original design did not prescribe validating received points,
    and libraries, in turn, did not implement these checks. This led to issues being
    found in different types of protocols that were making use of the primitive in
    more exotic ways. (One of these I found in the Matrix messaging protocol, which
    I talk about in chapter 11.)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Curve25519 有一个警告，即它不是一个素数阶群。该曲线有两个子群：一个大小为 8 的小子群和一个用于 ECDH 的大子群。此外，原始设计没有规定验证接收到的点，并且库也没有实现这些检查。这导致在使用原语的不同类型协议中发现问题。
    （其中一个我在 Matrix 消息协议中发现的问题，在第 11 章中有讨论。）
- en: 'Not verifying public keys can have unexpected behaviors with X25519\. The reason
    is that the key exchange algorithm does not have *contributory behavior*: it does
    not allow both parties to contribute to the final result of the key exchange.
    Specifically, one of the participants can force the outcome of the key exchange
    to be all zeros by sending a point in the small subgroup as public key. RFC 7748
    does mention this issue and proposes to check that the resulting shared secret
    is not the all zero output, yet lets the implementer decide to do the check or
    not! I would recommend making sure that your implementation performs the check,
    although it’s unlikely that you’re going to run into any issues unless you use
    X25519 in a nonstandard way.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不验证公钥可能会导致与 X25519 不符合预期的行为。原因在于密钥交换算法没有*贡献行为*：它不允许双方共同为密钥交换的最终结果做出贡献。具体来说，参与者之一可以通过发送一个小子群中的点作为公钥，强制密钥交换的结果为全零。RFC
    7748确实提到了这个问题，并建议检查生成的共享秘钥不是全零输出，但让实现者决定是否进行检查！我建议确保你的实现执行这个检查，尽管除非你以非标准方式使用 X25519，否则不太可能遇到任何问题。
- en: Because many protocols rely on Curve25519, this has been an issue for more than
    just key exchanges. *Ristretto*, the internet draft soon-to-be RFC, is a construction
    that adds an extra layer of encoding to Curve25519, effectively simulating a curve
    of prime order (see [https://tools.ietf.org/html/draft-hdevalence-cfrg-ristretto-01](https://tools.ietf.org/html/draft-hdevalence-cfrg-ristretto-01)).
    The construction has been gaining traction as it simplifies the security assumptions
    made by other types of cryptographic primitives that want to benefit from Curve25519
    but want a prime-order field.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多协议依赖于 Curve25519，这不仅仅是密钥交换的问题。*Ristretto*，即将成为 RFC 的互联网草案，是一种为 Curve25519
    添加额外编码层的构造，有效模拟了一个素数阶曲线（参见 [https://tools.ietf.org/html/draft-hdevalence-cfrg-ristretto-01](https://tools.ietf.org/html/draft-hdevalence-cfrg-ristretto-01)）。这种构造已经开始受到关注，因为它简化了其他类型的加密原语对
    Curve25519 的安全假设，但又希望得到素数阶域的好处。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: Unauthenticated key exchanges allow two parties to agree on a shared secret,
    while preventing any passive man-in-the-middle (MITM) attacker from being able
    to derive it as well.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未经身份验证的密钥交换允许两方达成共享秘钥，同时阻止任何被动中间人攻击者能够推导出它。
- en: An authenticated key exchange prevents an active MITM from impersonating one
    side of the connection, while a mutually authenticated key exchange prevents an
    active MITM from impersonating both sides.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证的密钥交换阻止主动中间人攻击者冒充连接的一方，而双向身份验证的密钥交换阻止主动中间人攻击者冒充双方。
- en: One can perform an authenticated key exchange by knowing the other party’s public
    key, but this doesn’t always scale and signatures will unlock more complex scenarios
    (see chapter 7).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过了解对方的公钥，可以执行经过身份验证的密钥交换，但这并不总是可扩展的，而签名将解锁更复杂的场景（见第7章）。
- en: Diffie-Hellman (DH) is the first key exchange algorithm invented and is still
    widely used.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迪菲-赫尔曼（DH）是第一个发明的密钥交换算法，仍然被广泛使用。
- en: The recommended standard to use for DH is RFC 7919, which includes several parameters
    to choose from. The smallest option is the recommended 2,048-bit prime parameter.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于DH的推荐标准是RFC 7919，其中包括几个可供选择的参数。最小选项是推荐的2,048位素数参数。
- en: Elliptic Curve Diffie-Hellman (ECDH) has much smaller key sizes than DH. For
    128 bits of security, DH needs 2,048-bit parameters, whereas ECDH needs 256-bit
    parameters.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆曲线迪菲-赫尔曼（ECDH）的密钥尺寸比DH小得多。对于128位的安全性，DH需要2,048位的参数，而ECDH只需要256位的参数。
- en: The most widely used curves for ECDH are P-256 and Curve25519\. Both provide
    128 bits of security. For 256-bit security, P-521 and Curve448 are available in
    the same standards.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECDH最广泛使用的曲线是P-256和Curve25519。两者都提供128位的安全性。对于256位的安全性，同一标准中还提供了P-521和Curve448。
- en: Make sure that implementations verify the validity of public keys you receive
    as invalid keys are the source of many bugs.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保实现验证你接收到的公钥的有效性，因为无效的密钥是许多错误的源头。
