- en: 8 Randomness and secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 随机性和秘密
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: What randomness is and why it’s important
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机性是什么以及为什么它很重要
- en: Obtaining strong randomness and producing secrets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取强随机性并生成秘密
- en: The pitfalls of randomness
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机性的陷阱
- en: This is the last chapter of the first part of this book, and I have one last
    thing to tell you before we move on to the second part and learn about actual
    protocols used in the real world. It is something I’ve grossly neglected so far
    — randomness.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书第一部分的最后一章，在我们转到第二部分并了解实际世界中使用的协议之前，我有最后一件事要告诉你。这是我迄今为止严重忽视的一点 —— 随机性。
- en: 'You must have noticed that in every cryptographic algorithm you’ve learned
    (with the exception of hash functions), you had to use randomness at some point:
    secret keys, nonces, IVs, prime numbers, challenges, and so on. As I was going
    through these different concepts, randomness always came from some magic black
    box. This is not atypical. In cryptography white papers, randomness is often represented
    by drawing an arrow with a dollar sign on top. But at some point, we need to ask
    ourselves the question, “Where does this randomness really come from?”'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了，在你学过的每个密码算法中（哈希函数除外），你都必须在某个时候使用随机性：秘密密钥、随机数、初始化向量、素数、挑战等等。当我讲解这些不同的概念时，随机性总是来自某个神奇的黑盒子。这并不罕见。在密码学白皮书中，随机性通常被用一个带有美元符号的箭头表示。但是在某些时候，我们需要问自己一个问题，“这个随机性到底来自哪里？”
- en: In this chapter, I will provide you with an answer as to what cryptography means
    when it mentions randomness. I will also give you pointers about the practical
    ways that exist to obtain randomness for real-world cryptographic applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将为你解释当密码学提到随机性时它意味着什么。我还将为你提供有关现实世界密码应用中获取随机性的实用方法的指引。
- en: Note For this chapter, you’ll need to have read chapter 2 on hash functions
    and chapter 3 on message authentication codes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 对于这一章，你需要已经阅读了第2章关于哈希函数和第3章关于消息认证码。
- en: 8.1 What’s randomness?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 什么是随机性？
- en: Everyone understands the concept of randomness to some degree. Whether playing
    with dice or buying some lottery tickets, we’ve all been exposed to it. My first
    encounter with randomness was at a very young age, when I realized that a RAND
    button on my calculator would produce a different number every time I pressed
    it. This troubled me to no end. I had little knowledge about electronics, but
    I thought I could understand some of its limitations. When I added 4 and 5 together,
    surely some circuits would do the math and give me the result. But a random button?
    Where were the random numbers coming from? I couldn’t wrap my head around it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人在某种程度上都理解随机性的概念。无论是玩骰子还是买彩票，我们都曾接触过它。我第一次遇到随机性是在很小的时候，当我意识到计算器上的一个RAND按钮每次按下都会产生不同的数字时。这让我感到非常困扰。我对电子学了解甚少，但我觉得我可以理解一些它的限制。当我将4和5相加时，肯定会有一些电路进行计算并给我结果。但是一个随机按钮？随机数从哪里来的？我无法理解。
- en: 'It took me some time to ask the right questions and to understand that calculators
    actually cheated! They would hardcode large lists of random numbers and go through
    those one by one. These lists would exhibit good randomness, meaning that if you
    looked at the random numbers you were getting, there’d be as many 1s as 9s, as
    many 1s as 2s, and so on. These lists would simulate a *uniform distribution*:
    the numbers were distributed in equal proportions (uniformly).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了一些时间才问出正确的问题，并且了解到计算器其实是作弊的！它们会硬编码大量随机数列表，并逐一遍历这些列表。这些列表会展现出良好的随机性，这意味着如果你看着得到的随机数，1的数量和9的数量相等，1的数量和2的数量相等，依此类推。这些列表会模拟*均匀分布*：数字均匀分布在等比例中。
- en: When random numbers are needed for security and cryptography purposes, then
    randomness must be *unpredictable*. Of course, at that time, nobody would have
    used those calculators’ “randomness” for anything related to security. Instead,
    cryptographic applications extract randomness from observing hard-to-predict physical
    phenomena.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要用于安全和密码学目的时，随机数必须是*不可预测*的。当然，在那个时候，没有人会将那些计算器的“随机性”用于与安全有关的任何事情。相反，密码应用从观察难以预测的物理现象中提取随机性。
- en: For example, it is hard to predict the outcome of a dice roll, even though throwing
    a die is a deterministic process; if you knew all the initial conditions (how
    you’re throwing the die, the die itself, the air friction, the grip of the table,
    and so on), you should be able to predict the result. That being said, all of
    these factors impact the end result so much that a slight imprecision in the knowledge
    of the initial conditions would mess with our predictions. The extreme sensitivity
    of an outcome to its initial conditions is known as *chaos theory*, and it is
    the reason why things like the weather are hard to predict accurately past a certain
    number of days.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，即使投掷骰子是一个确定性过程，预测其结果也很困难；如果你知道了所有的初始条件（你如何投掷骰子、骰子本身、空气摩擦、桌面的摩擦力等），你应该能够预测结果。话虽如此，所有这些因素对最终结果的影响如此之大，以至于对初始条件的知识有轻微的不准确性就会影响我们的预测。结果对初始条件的极度敏感性被称为*混沌理论*，这就是为什么像天气这样的事情很难在一定数量的天数后准确预测的原因。
- en: The following image is a picture that I snapped during one of my visits to the
    headquarters of Cloudflare in San Francisco. LavaRand is a wall of lava lamps,
    which are lamps that produce hard-to-predict shapes of wax. A camera is set in
    front of the wall to extract and convert the images to random bytes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图片是我在访问 Cloudflare 在旧金山总部期间拍摄的一张照片。LavaRand 是一堵熔岩灯墙，这些灯产生难以预测的蜡形状。一台摄像机放置在墙前，提取并将图像转换为随机字节。
- en: '![](../Images/08_001_UN01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_001_UN01.jpg)'
- en: Applications usually rely on the operating system to provide usable randomness,
    which in turn, gather randomness using different tricks, depending on the type
    of device it is run on. Common sources of randomness (also called *entropy sources*)
    can be the timing of hardware interrupts (for example, your mouse movements),
    software interrupts, hard disk seek time, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常依赖操作系统提供可用的随机性，而操作系统又根据运行的设备类型使用不同的技巧收集随机性。常见的随机性来源（也称为*熵源*）可以是硬件中断的时间（例如，您的鼠标移动）、软件中断、硬盘寻道时间等。
- en: Entropy
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 熵
- en: In information theory, the word *entropy* is used to judge how much randomness
    a string contains. The term was coined by Claude Shannon, who devised an entropy
    formula that would output larger and larger numbers as a string would exhibit
    more and more unpredictability (starting at 0 for completely predictable). The
    formula or the number itself is not that interesting for us, but in cryptography,
    you often hear “this string has low entropy” (meaning that it is predictable)
    or “this string has high entropy” (meaning that it is less predictable).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息理论中，*熵*一词用于判断一个字符串包含多少随机性。该术语是由克劳德·香农创造的，他设计了一个熵公式，该公式将随着字符串表现出越来越多的不可预测性而输出越来越大的数字（从完全可预测的0开始）。对于我们来说，公式或数字本身并不那么有趣，但在密码学中，你经常会听到“这个字符串的熵低”（意思是可预测的）或“这个字符串的熵高”（意思是不太可预测的）。
- en: Observing interrupts and other events to produce randomness is not great; when
    a device boots, these events tend to be highly predictable, and they can also
    be maliciously influenced by external factors. Today, more and more devices have
    access to additional sensors and hardware aids that provide better sources of
    entropy. These hardware random number generators are often called *true random
    number generators* (TRNGs) as they make use of external unpredictable physical
    phenomena like thermal noise to extract randomness.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 观察中断和其他事件以产生随机性并不理想；当设备启动时，这些事件往往是高度可预测的，它们也可能受到外部因素的恶意影响。如今，越来越多的设备可以访问额外的传感器和硬件辅助设备，提供更好的熵源。这些硬件随机数发生器通常称为*真随机数发生器*（TRNG），因为它们利用外部不可预测的物理现象（如热噪声）来提取随机性。
- en: The noise obtained via all these different types of input is usually not “clean”
    and sometimes does not provide enough entropy (if at all). For example, the first
    bit obtained from some entropy source could be 0 more often than not, or successive
    bits could be (more likely than chance) equal. Due to this, *randomness extractors*
    must clean and gather several sources of noise together before it can be used
    for cryptographic applications. This can be done, for example, by applying a hash
    function to the different sources and XORing the digests together.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些不同类型的输入获得的噪声通常不是“干净”的，有时甚至没有足够的熵（如果有的话）。例如，从某些熵源获得的第一个比特往往是0，或者连续的比特可能（比机会更大）相等。因此，在用于密码应用之前，*随机性提取器*必须清理和收集几种噪声源。例如，可以通过将不同源应用哈希函数并将摘要进行异或来完成此操作。
- en: Is this all there is to randomness? Unfortunately not. Extracting randomness
    from noise is a process that can be slow. For some applications that might need
    lots of random numbers quickly, it can become a bottleneck. The next section describes
    how OSs and real-world applications boost the generation of random numbers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性就只有这些吗？不幸的是不是。从噪声中提取随机性是一个可能会很慢的过程。对于一些可能需要快速生成大量随机数的应用程序，这可能成为瓶颈。下一节将描述操作系统和现实世界应用程序如何提高随机数的生成。
- en: 8.2 Slow randomness? Use a pseudorandom number generator (PRNG)
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 慢随机性？使用伪随机数生成器（PRNG）
- en: Randomness is used everywhere. At this point, you should be convinced that this
    is true at least for cryptography, but surprisingly, cryptography is not the only
    place making heavy use of random numbers. For example, simple Unix programs like
    ls require randomness too! As a bug in a program can be devastating if exploited,
    binaries attempt to defend against low-level attacks using a multitude of tricks;
    one of them is *ASLR* (address space layout randomization), which randomizes the
    memory layout of a process every time it runs and, thus, requires random numbers.
    Another example is the network protocol TCP, which makes use of random numbers
    every time it creates a connection to produce an unpredictable sequence of numbers
    and thwarts attacks attempting to hijack connections. While all of this is beyond
    the scope of this book, it is good to have an idea of how much randomness ends
    up being used for security reasons in the real world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性随处可见。此时，您应该至少相信这对于密码学是真实的，但令人惊讶的是，密码学并不是唯一一个大量使用随机数的地方。例如，像ls这样的简单Unix程序也需要随机性！由于程序中的错误如果被利用可能会产生灾难性后果，二进制文件试图通过多种技巧来防御低级攻击；其中之一是*ASLR*（地址空间布局随机化），它在每次运行时随机化进程的内存布局，因此需要随机数。另一个例子是网络协议TCP，每次创建连接时都使用随机数来产生不可预测的数字序列，并阻止试图劫持连接的攻击。虽然所有这些都超出了本书的范围，但了解现实世界中出于安全原因使用了多少随机性是很好的。
- en: I hinted in the last section that, unfortunately, obtaining unpredictable randomness
    is somewhat of a slow process. This is sometimes due to a source of entropy being
    slow to produce noise. As a result, OSs often optimize their production of random
    numbers by using *pseudorandom number generators* (PRNGs).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我暗示了，不幸的是，获得不可预测的随机性有点慢。这有时是因为熵源产生噪声的速度较慢。因此，操作系统通常通过使用*伪随机数生成器*（PRNGs）来优化它们的随机数生成过程。
- en: Note In order to contrast with random number generators that are not designed
    to be secure (and that are useful in different types of applications, like video
    games), PRNGs are sometimes called CSPRNGs for *cryptographically secure* PRNGs.
    NIST, wanting to do things differently (as usual), often calls their PRNGs *deterministic
    random bit generators* (DRBGs).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意为了与那些不设计为安全的随机数生成器进行对比（在不同类型的应用程序中很有用，比如视频游戏），PRNG有时被称为*CSPRNGs*，代表*密码学安全*PRNGs。NIST想要以不同的方式做事情（像往常一样），通常将他们的PRNG称为*确定性随机位生成器*（DRBGs）。
- en: A PRNG needs an initial secret, usually called a *seed*, that we can obtain
    from mixing different entropy sources together and can then produce lots of random
    numbers quickly. I illustrate a PRNG in figure 8.1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PRNG需要一个初始秘密，通常称为*种子*，我们可以通过混合不同的熵源来获得，然后可以快速产生大量随机数。我在图8.1中说明了一个PRNG。
- en: '![](../Images/08_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_01.jpg)'
- en: Figure 8.1 A pseudorandom number generator (PRNG) generates a sequence of random
    numbers based on a seed. Using the same seed makes the PRNG produce the same sequence
    of random numbers. It should be impossible to recover the state using knowledge
    of the random outputs (the function `next` is one way). It follows that it should
    also be impossible from observing the produced random numbers alone to predict
    future random numbers or to recover previously generated random numbers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 伪随机数生成器（PRNG）基于种子生成随机数序列。使用相同的种子使 PRNG 产生相同的随机数序列。应该不可能使用随机输出的知识来恢复状态（函数`next`是一种方式）。由此得出，仅从观察产生的随机数就不可能预测未来的随机数或恢复先前生成的随机数。
- en: 'Cryptographically secure PRNGs usually tend to exhibit the following properties:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 加密安全的 PRNG 通常具有以下属性：
- en: '*Deterministic*— Using the same seed twice produces the same sequence of random
    numbers. This is unlike the unpredictable randomness extraction I talked about
    previously: if you know a seed used by a PRNG, the PRNG should be completely predictable.
    This is why the construction is called *pseudo*random, and this is what allows
    a PRNG to be extremely fast.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定性*— 使用相同的种子两次会产生相同的随机数序列。这与我之前谈到的不可预测的随机性提取不同：如果你知道 PRNG 使用的种子，那么 PRNG 应该是完全可预测的。这就是为什么这种构造被称为*伪*随机的原因，这也是使
    PRNG 能够非常快速的原因。'
- en: '*Indistinguishable from random*— In practice, you should not be able to distinguish
    between a PRNG outputting a random number from a set of possible numbers and a
    little fairy impartially choosing a random number from the same set (assuming
    the fairy knows a magical way to pick a number such that every possible number
    can be picked with equal probability). Consequently, observing the random numbers
    generated alone shouldn’t allow anyone to recover the internal state of the PRNG.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与随机不可区分*— 在实践中，你不应该能够区分 PRNG 输出的随机数与一个小精灵公正地从相同集合中选择随机数的情况（假设该精灵知道一种魔法方式来选择一个数，以使每个可能的数都可以等概率地被选择）。因此，仅观察生成的随机数不应该允许任何人恢复
    PRNG 的内部状态。'
- en: The last point is important! A PRNG simulates picking a number *uniformly at
    random*, meaning that each number from the set has an equal chance of being picked.
    For example, if your PRNG produces random numbers of 8 bytes, the set is all the
    possible strings of 8 bytes, and each 8-byte value should have equal probability
    of being the next value that can be obtained from your PRNG. This includes values
    that have already been produced by the PRNG at some point in the past.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点非常重要！PRNG 模拟从*均匀随机*选择一个数字，这意味着集合中的每个数字都有相等的被选中的机会。例如，如果你的 PRNG 生成 8 字节的随机数，那么集合就是所有可能的
    8 字节字符串，每个 8 字节值都应该有相等的概率成为可以从你的 PRNG 获得的下一个值。这包括已经由 PRNG 在过去某个时候生成的值。
- en: In addition, many PRNGs exhibit additional security properties. A PRNG has *forward
    secrecy* if an attacker learning the state (by getting in your computer at some
    point in time, for example) doesn’t allow the PRNG to retrieve previously generated
    random numbers. I illustrate this in figure 8.2.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多 PRNG 还表现出其他安全性质。如果攻击者学习到状态（例如在某个时间点进入您的计算机），则 PRNG 不会允许其检索先前生成的随机数，那么
    PRNG 具有*正向保密性*。我在图 8.2 中进行了说明。
- en: '![](../Images/08_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_02.jpg)'
- en: Figure 8.2 A PRNG has forward secrecy if compromise of a state does not allow
    recovering previously generated random numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 如果 PRNG 的状态泄露不会导致恢复先前生成的随机数，则 PRNG 具有正向保密性。
- en: Obtaining the *state* of a PRNG means that you can determine all future pseudorandom
    numbers that it will generate. To prevent this, some PRNGs have mechanisms to
    “heal” themselves periodically (in case there was a compromise). This healing
    can be achieved by reinjecting (or re-seeding) new entropy after a PRNG was already
    seeded. This property is called *backward secrecy*. I illustrate this in figure
    8.3.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 PRNG 的*状态*意味着你可以确定它将生成的所有未来伪随机数。为了防止这种情况发生，一些 PRNG 具有定期“修复”自身的机制（以防出现泄密）。这种修复可以通过在
    PRNG 已经被种子化后重新注入（或重新播种）新的熵来实现。这种属性被称为*逆向保密性*。我在图 8.3 中进行了说明。
- en: '![](../Images/08_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_03.jpg)'
- en: Figure 8.3 A PRNG has backward secrecy if compromise of a state does not allow
    predicting future random numbers generated by the PRNG. This is true only once
    new entropy is produced and injected in the update function after the compromise.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 如果 PRNG 的状态被泄露，而这并不会导致能够预测 PRNG 生成的未来随机数，则 PRNG 具有逆向保密性。这仅在产生新的熵并在泄密后注入更新函数时才成立。
- en: Note The terms *forward* and *backward secrecy* are often sources of confusion.
    If you read this section thinking shouldn’t forward secrecy be backward secrecy
    and backward secrecy be forward secrecy instead, then you are not crazy. For this
    reason, backward secrecy is sometimes called *future secrecy* or even *post-compromise
    security* (PCS).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *前向* 和 *后向保密性* 这两个术语经常让人感到困惑。如果你读到这一部分时认为前向保密性应该是后向保密性，反之亦然，那么你并不疯狂。因此，后向保密性有时被称为*未来保密性*，甚至是*事后妥协安全*（PCS）。
- en: PRNGs can be extremely fast and are considered safe methods to generate large
    numbers of random values for cryptographic purposes if properly seeded. Using
    a predictable number or a number that is too small is obviously not a secure way
    to seed a PRNG. This effectively means that we have secure cryptographic ways
    for quickly stretching a secret of appropriate size to billions of other secret
    keys. Pretty cool, right? This is why most (if not all) cryptographic applications
    do not use random numbers directly extracted from noise, but instead use them
    to seed a PRNG in an initial step and then switch to generating random numbers
    from the PRNG when needed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适当地种子化，PRNGs可以非常快速，并被认为是生成大量用于加密目的的随机值的安全方法。使用可预测的数字或数字过小显然不是安全的种子PRNG的方式。这实际上意味着我们有安全的加密方式，可以快速地将适当大小的秘密扩展到数十亿个其他秘密密钥。很酷，对吧？这就是为什么大多数（如果不是全部）加密应用程序不直接使用从噪声中提取的随机数，而是在初始步骤中使用它们来种子PRNG，然后在需要时切换到从PRNG生成随机数。
- en: The Dual-EC backdoor
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 双重EC后门
- en: Today, PRNGs are mostly heuristic-based constructions. This is because constructions
    based on hard mathematical problems (like the discrete logarithm) are too slow
    to be practical. One notorious example is *Dual EC*, invented by NSA, which relies
    on elliptic curves. The Dual EC PRNG was pushed to various standards including
    some NIST publications around 2006, and not too long after, several researchers
    independently discovered a potential backdoor in the algorithm. This was later
    confirmed by the Snowden revelations in 2013, and a year later the algorithm was
    withdrawn from multiple standards.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，伪随机数生成器（PRNGs）主要是基于启发式构建的。这是因为基于困难数学问题（如离散对数）的构建方式速度太慢，不够实用。一个臭名昭著的例子是由NSA发明的*双重EC*，依赖于椭圆曲线。双重EC
    PRNG被推广到各种标准，包括2006年左右的一些NIST出版物，不久之后，几位研究人员独立发现了算法中的潜在后门。这在2013年斯诺登的披露中得到了确认，一年后，该算法被撤回了多个标准。
- en: To be secure, a PRNG must be seeded with an *unpredictable* secret. More accurately,
    we say that the PRNG takes a key of *n* bytes sampled uniformly at random. This
    means that we should pick the key randomly from the set of all possible *n* -byte
    strings, where each byte string has the same chance of being picked.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要保证安全，PRNG必须用一个*不可预测*的秘密种子。更准确地说，我们说PRNG以* n *字节的密钥均匀随机采样。这意味着我们应该从所有可能的* n
    * -字节字符串集中随机选择密钥，每个字节字符串被选中的机会相同。
- en: In this book, I talked about many cryptographic algorithms that produce outputs
    indistinguishable from random (from values that would be chosen uniformly at random).
    Intuitively, you should be thinking can we use these algorithms to generate random
    numbers then? And you would be right! Hash functions, XOFs, block ciphers, stream
    ciphers, and MACs can be used to produce random numbers. Hash functions and MACs
    are theoretically not defined as providing outputs that are indistinguishable
    from random, but in practice, they often are. Asymmetric algorithms like key exchange
    and signatures, on the other hand, are (almost all the time) not indistinguishable
    from random. For this reason, their output is often hashed before being used as
    random numbers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我谈到了许多产生与随机输出不可区分的密码算法（从将被均匀选择的值）。直觉上，你应该在想我们能否使用这些算法来生成随机数呢？你是对的！哈希函数、XOFs、块密码、流密码和MACs可以用来生成随机数。哈希函数和MACs在理论上并没有被定义为提供与随机不可区分的输出，但在实践中，它们经常是如此。另一方面，像密钥交换和签名这样的非对称算法（几乎总是）不可区分于随机。因此，它们的输出在被用作随机数之前经常被哈希。
- en: Actually, because AES is hardware-supported on most machines, it is customary
    to see AES-CTR being used to produce random numbers. The symmetric key becomes
    the seed, and the ciphertexts become the random numbers (for the encryption of
    an infinite string of 0s, for example). In practice, there is a bit more complexity
    added to these constructions in order to provide forward and backward secrecy.
    Fortunately, you now understand enough to go to the next section, which provides
    an overview of obtaining randomness for real.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，因为大多数计算机上都支持 AES，因此通常会看到使用 AES-CTR 来生成随机数。对称密钥成为种子，而密文成为随机数（例如，用于加密无限的 0
    字符串）。在实践中，为了提供前向和后向保密性，对这些构造添加了一些复杂性。幸运的是，您现在已经了解足够多的内容，可以进入下一节，该节提供了实际获取随机性的概述。
- en: 8.3 Obtaining randomness in practice
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 在实践中获取随机性
- en: 'You’ve learned about the three ingredients that an OS needs to provide cryptographically
    secure random numbers to its programs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了操作系统向其程序提供加密安全随机数所需的三个要素：
- en: '*Noise sources*— These are ways for the OS to obtain raw randomness from unpredictable
    physical phenomena like the temperature of the device or your mouse movements.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*噪声源* — 这些是操作系统从不可预测的物理现象（如设备温度或鼠标移动）中获取原始随机性的方法。'
- en: '*Cleaning and mixing*— Although raw randomness can be of poor quality (some
    bits might be biased), OSs clean up and mix a number of sources together in order
    to produce a good random number.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清理和混合* — 虽然原始随机性可能质量较差（一些位可能是偏倚的），但操作系统会清理并混合多个来源，以产生良好的随机数。'
- en: '*PRNGs*— Because the first two steps are slow, a single, uniformly random value
    can be used to seed a PRNG that can quickly produce random numbers.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PRNGs* — 因为前两个步骤很慢，所以可以使用单个、均匀分布的随机值来种子一个可以快速生成随机数的 PRNG。'
- en: In this section, I will explain how systems bundle the three concepts together
    to provide simplified interfaces to developers. These functions exposed by the
    OS usually allow you to generate a random number by issuing a system call. Behind
    these system calls is, indeed, a system bundling up noise sources, a mixing algorithm,
    and a PRNG (summarized in figure 8.4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释系统如何将这三个概念捆绑在一起，以向开发人员提供简化的接口。操作系统提供的这些函数通常允许您通过发出系统调用生成随机数。在这些系统调用背后，确实有一个系统将噪声源、混合算法和
    PRNG 捆绑在一起（在图 8.4 中总结）。
- en: '![](../Images/08_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08_04.jpg)'
- en: Figure 8.4 Generating random numbers on a system usually means that entropy
    was mixed together from different noise sources and used to seed a long-term PRNG.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 在系统上生成随机数通常意味着从不同的噪声源混合熵并用于种子长期 PRNG。
- en: 'Depending on the OS and on the hardware available, these three concepts might
    be implemented differently. In 2021, Linux uses a PRNG that’s based on the ChaCha20
    stream cipher, while macOS uses a PRNG that’s based on the SHA-1 hash function.
    In addition, the random number generator interface exposed to developers will
    be different depending on the OS. On Windows, the `BCryptGenRandom` system call
    can be used to produce random numbers, while on other platforms, a special file
    (usually called /dev/urandom) is exposed and can be read to provide randomness.
    For example, on Linux or macOS, one can read 16 bytes from the terminal using
    the `dd` command-line tool:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作系统和可用硬件的不同，这三个概念可能会以不同的方式实现。在 2021 年，Linux 使用基于 ChaCha20 流密码的 PRNG，而 macOS
    使用基于 SHA-1 散列函数的 PRNG。此外，向开发人员公开的随机数生成器接口将根据操作系统而异。在 Windows 上，可以使用 `BCryptGenRandom`
    系统调用生成随机数，而在其他平台上，则公开了一个特殊文件（通常称为 /dev/urandom），可以读取以提供随机性。例如，在 Linux 或 macOS
    上，可以使用 `dd` 命令行工具从终端读取 16 字节：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One problem with /dev/urandom is that it might not provide enough entropy (its
    numbers won’t be random enough) if used too early after booting the device. OSs
    like Linux and FreeBSD offer a solution called `getrandom`, which is a system
    call that pretty much offers the same functionality as reading from /dev/urandom.
    In rare cases, where not enough entropy is available for initializing its PRNG,
    `getrandom` will block the continuation of the program and wait until properly
    seeded. For this reason, I recommend that you use `getrandom` if it is available
    on your system. The following listing shows how one can securely use `getrandom`
    in C:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/urandom` 的一个问题是，如果在设备启动后太早使用，可能提供的熵不足（其数字不够随机）。像 Linux 和 FreeBSD 这样的操作系统提供了一种称为
    `getrandom` 的解决方案，它是一种系统调用，几乎提供与从 `/dev/urandom` 读取相同功能的功能。在很少的情况下，如果初始化其 PRNG
    的熵不足，`getrandom` 将阻止程序的继续运行，并等待适当的种子化。因此，如果系统可用，建议您使用 `getrandom`。以下清单显示了如何在 C
    中安全使用 `getrandom`：'
- en: Listing 8.1 Getting random numbers in C
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`8.1` 在 C 中获取随机数示例'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Fills a buffer with random bytes (note that getrandom is limited to up to
    256 bytes per call).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用随机字节填充缓冲区（请注意，`getrandom` 每次调用最多限制为 `256` 字节）。
- en: ❷ The default flags (0) is to not block, unless properly seeded.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 默认标志（`0`）是不阻塞的，除非适当种子化。
- en: ❸ It is possible that the function fails or returns less than the desired amount
    of random bytes. If this is the case, the system is corrupt and aborting might
    be the best thing to do.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 函数可能失败或返回少于所需的随机字节数。如果是这种情况，则系统已损坏，中止可能是最好的选择。
- en: With that example in mind, it is also good to point out that many programming
    languages have standard libraries and cryptographic libraries that provide better
    abstractions. It might be easy to forget that `getrandom` only returns up to 256
    bytes per call, for example. For this reason, you should always attempt to generate
    random numbers through the standard library of the programming language you’re
    using.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个例子，还要指出许多编程语言都有标准库和密码库，提供更好的抽象。例如，很容易忘记 `getrandom` 每次调用最多只返回 `256` 个字节。因此，您应该始终尝试通过所使用的编程语言的标准库生成随机数。
- en: Warning Note that many programming languages expose functions and libraries
    that produce predictable random numbers. These are not suited for cryptographic
    use! Make sure that you use random libraries that generate *cryptographically
    strong* random numbers. Usually the name of the library helps (for example, you
    can probably guess which one you should use between the `math/rand` and `crypto/rand`
    packages in Golang), but nothing replaces reading the manual!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 注意许多编程语言公开了产生可预测随机数的函数和库。这些不适用于密码学用途！确保使用生成*密码强度强*的随机数的随机库。通常库的名称有助于选择（例如，在
    Golang 中，您可能可以猜出应该使用 `math/rand` 和 `crypto/rand` 包之间的哪一个），但是阅读手册是无可替代的！
- en: Listing 8.2 shows how to generate some random bytes using PHP 7\. Any cryptographic
    algorithm can use these random bytes. For example, as a secret key to encrypt
    with an authenticated encryption algorithm. Every programming language does things
    differently, so make sure to consult your programming language’s documentation
    in order to find the standard way to obtain random numbers for cryptographic purposes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 `8.2` 显示了如何在 PHP `7` 中生成一些随机字节。任何密码算法都可以使用这些随机字节。例如，作为使用认证加密算法加密的秘密密钥。每种编程语言都有不同的做法，因此请务必查阅您的编程语言文档，以找到获取密码用途的随机数的标准方法。
- en: Listing 8.2 Getting random numbers in PHP
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`8.2` 在 PHP 中获取随机数示例'
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Produces a random integer between 0 and 10\. While fast, rand does not produce
    cryptographically secure random numbers so it is not suitable for cryptographic
    algorithms and protocols.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 产生 `0` 到 `10` 之间的随机整数。虽然快速，但 `rand` 不会产生密码学安全的随机数，因此不适用于密码算法和协议。
- en: ❷ random_bytes creates and fills a buffer with 16 random bytes. The result is
    suitable for cryptographic algorithms and protocols.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `random_bytes` 创建并填充一个包含 `16` 个随机字节的缓冲区。结果适用于密码算法和协议。
- en: Now that you’ve learned how you can obtain cryptographically secure randomness
    in your programs, let’s think about the security considerations you need to keep
    in mind when you generate randomness.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何在程序中获得密码学安全的随机性，让我们思考一下在生成随机性时需要牢记的安全考虑事项。
- en: 8.4 Randomness generation and security considerations
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`8.4` 随机性生成与安全考虑'
- en: It is good to remember at this point that any useful protocol based on cryptography
    requires good randomness and that a broken PRNG could lead to the entire cryptographic
    protocol or algorithm being insecure. It should be clear to you that a MAC is
    only as secure as the key used with it or that the slightest ounce of predictability
    usually destroys signature schemes like ECDSA, and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上记住是很好的，任何基于密码学的有用协议都需要良好的随机性，一个破损的PRNG可能导致整个密码协议或算法不安全。你应该清楚地知道，MAC只有与其一起使用的密钥一样安全，或者即使有微小的可预测性通常也会破坏ECDSA等签名方案，等等。
- en: 'So far, this chapter makes it sound like generating randomness should be a
    simple part of applied cryptography, but in practice, it is not. Randomness has
    actually been the source of many, many bugs in real-world cryptography due to
    a multitude of issues: using a noncryptographic PRNG, badly seeding a PRNG (for
    example, using the current time, which is predictable), and so on.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章让生成随机性听起来应该是应用密码学的一个简单部分，但实际上并非如此。由于多种问题：使用非密码学PRNG、错误地种子化PRNG（例如使用可预测的当前时间）等，随机性实际上是真实世界密码学中许多许多错误的根源。
- en: One example includes programs using *userland PRNGs* as opposed to *kernel PRNGs*,
    which are behind system calls. Userland PRNGs usually add unnecessary friction
    and if misused can, in the worst of cases, break the entire system. This was notably
    the case with the PRNG offered by the OpenSSL library that was patched into some
    OSs in 2006, inadvertently affecting all SSL and SSH generated keys using the
    vulnerable PRNG.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子包括使用*用户空间PRNG*而不是*内核PRNG*的程序，后者在系统调用后面。用户空间PRNG通常会增加不必要的摩擦，如果被误用，最坏的情况下可能会破坏整个系统。这在2006年某些操作系统中补丁到的OpenSSL库提供的PRNG中就是一个明显的例子，无意中影响了使用受影响PRNG生成的所有SSL和SSH密钥。
- en: '*Removing this code has the side effect of crippling the seeding process for
    the OpenSSL PRNG. Instead of mixing in random data for the initial seed, the only
    random value that was used was the current process ID. On the Linux platform,
    the default maximum process ID is 32,768, resulting in a very small number of
    seed values being used for all PRNG operations*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*删除这段代码的副作用是瘫痪了OpenSSL PRNG的种子过程。而不是混合随机数据用于初始种子，唯一使用的随机值是当前进程ID。在Linux平台上，默认的最大进程ID是32,768，导致所有PRNG操作只使用了很少的种子值*。'
- en: —H. D. Moore (“Debian OpenSSL Predictable PRNG Toys,” 2008)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: —H. D. Moore（“Debian OpenSSL可预测PRNG玩具”，2008）
- en: For this reason and others, I will mention later in this chapter that it is
    wise to avoid userland PRNG and to stick to randomness provided by the OS when
    available. In most situations, sticking to what the programming language’s standard
    library or what a good cryptography library provides should be enough.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因和其他原因，我将在本章后面提到明智的做法是避免使用用户空间PRNG，并在可用时坚持使用操作系统提供的随机性。在大多数情况下，坚持使用编程语言的标准库或一个良好的加密库提供的内容应该足够了。
- en: '*We cannot keep on adding ‘best practice’ after ‘best practice’ to what developers
    need to keep in the back of their heads when writing everyday code*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们不能在开发人员在编写日常代码时需要记住的‘最佳实践’之后不断添加更多内容*。'
- en: —Martin Boßlet (“OpenSSL PRNG Is Not (Really) Fork-safe,” 2013)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: —Martin Boßlet（“OpenSSL PRNG不是（真的）分叉安全的”，2013）
- en: 'Unfortunately, no amount of advice can really prepare you for the many pitfalls
    of acquiring good randomness. Because randomness is at the center of every cryptography
    algorithm, making tiny mistakes can lead to devastating outcomes. It is good to
    keep in mind the following edge cases should you run into them:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，任何建议都无法真正为你准备好获取良好随机性的许多陷阱。因为随机性是每个加密算法的核心，做出微小错误可能导致灾难性后果。如果你遇到以下边缘情况，记住以下内容是很好的：
- en: '*Forking processes*—When using a userland PRNG (some applications with extremely
    high performance requirements might have no other choice), it is important to
    keep in mind that a program that forks will produce a new child process that will
    have the same PRNG state as its parent. Consequently, both PRNGs will produce
    the same sequence of random numbers from there on. For this reason, if you really
    want to use a userland PRNG, you have to be careful to make forks use different
    seeds for their PRNGs.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分叉进程*——当使用用户空间伪随机数生成器（一些对性能要求极高的应用可能别无选择）时，重要的是要记住，一个分叉的程序会产生一个新的子进程，其PRNG状态与其父进程相同。因此，从那时起，两个PRNG将产生相同的随机数序列。因此，如果你真的想使用用户空间PRNG，你必须小心让分叉使用不同的种子来生成他们的PRNG。'
- en: '*Virtual machines (VMs)*—Cloning of PRNG state can also become a problem when
    using the OS PRNG. Think about VMs. If the entire state of a VM is saved and then
    started several times from this point on, every instance might produce the exact
    same sequence of random numbers. This is sometimes fixed by hypervisors and OSs,
    but it is good to look into what the hypervisor you’re using is doing before running
    applications that request random numbers in VMs.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚拟机（VMs）*—当使用操作系统PRNG时，克隆PRNG状态也可能成为一个问题。想想虚拟机。如果整个VM的状态被保存，然后从这一点开始多次启动，每个实例可能会产生完全相同的随机数序列。有时这可以通过虚拟化程序和操作系统来解决，但在运行请求在虚拟机中生成随机数的应用程序之前，最好了解一下您正在使用的虚拟化程序的操作。'
- en: '*Early boot entropy*— While OSs should have no trouble gathering entropy in
    user-operated devices due to the noise produced by the user’s interactions with
    the device, embedded devices and headless systems have more challenges to overcome
    in order to produce good entropy at boot time. History has shown that some devices
    tend to boot in a similar fashion and end up amassing the same initial noise from
    the system, leading to the same seed being used for their internal PRNGs and the
    same series of random numbers being generated.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*早期启动熵*—虽然操作系统在用户操作设备时应该没有问题收集熵，因为用户与设备的交互产生的噪声，但嵌入式设备和无头系统在启动时需要克服更多的挑战以产生良好的熵。历史表明，一些设备倾向于以类似的方式启动并从系统中积累相同的初始噪声，导致使用相同种子用于其内部PRNG并生成相同系列的随机数。'
- en: '*There is a window of vulnerability —a boot-time entropy hole —during which
    Linux’s urandom may be entirely predictable, at least for single-core systems.
    [. . .] When we disabled entropy sources that might be unavailable on a headless
    or embedded device, the Linux RNG produced the same predictable stream on every
    boot*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*存在一个漏洞窗口—启动时的熵空洞—在这个窗口期内，Linux的urandom可能是完全可预测的，至少对于单核系统来说。[...] 当我们禁用了可能在无头或嵌入式设备上不可用的熵源时，Linux
    RNG在每次启动时产生了相同可预测的流*。'
- en: '—Heninger et al. (“Mining Your Ps and Qs: Detection of Widespread Weak Keys
    in Network Devices,” 2012)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: —Heninger等人（“挖掘您的P和Q：检测网络设备中普遍存在的弱密钥”，2012）
- en: In these rare cases, where you really, really need to obtain random numbers
    early during boot, one can help the system by providing some initial entropy generated
    from another machine’s well-seeded `getrandom` or /dev/urandom. Different OSs
    might provide this feature, and you should consult their manuals (as usual) if
    you find yourself in this situation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些罕见的情况下，当您确实需要在启动过程中尽早获取随机数时，可以通过提供从另一台机器的良好种子的`getrandom`或/dev/urandom生成的初始熵来帮助系统。不同的操作系统可能提供此功能，如果您发现自己处于这种情况，请查阅它们的手册（像往常一样）。
- en: If available, a TRNG provides an easy solution to the problem. For example,
    modern Intel CPUs embed a special hardware chip that extracts randomness from
    thermal noise. This randomness is available through an instruction called `RDRAND`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可用，TRNG为这个问题提供了一个简单的解决方案。例如，现代英特尔CPU嵌入了一个特殊的硬件芯片，从热噪声中提取随机性。这种随机性可以通过一个名为`RDRAND`的指令获得。
- en: The `RDRAND` controversy
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`RDRAND`争议'
- en: Interestingly, Intel’s `RDRAND` has been quite controversial due to the fear
    of backdoors. Most OSs that have integrated `RDRAND` as a source of entropy mix
    it with other sources of entropy in a way that is *contributory*. Contributory
    here means that one source of entropy cannot force the outcome of the randomness
    generation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，英特尔的`RDRAND`由于存在后门的恐惧而引起了很大争议。大多数集成了`RDRAND`作为熵源的操作系统会将其与其他熵源混合在一起，以*协同*的方式。这里的协同意味着一个熵源不能强制影响随机数生成的结果。
- en: Exercise
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Imagine for a minute that mixing different sources of entropy was done by simply
    XORing them together. Can you see how this might fail to be contributory?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果将不同的熵源简单地通过异或操作在一起，您能看出这可能无法成为协同的吗？
- en: Finally, let me mention that one solution to avoid the randomness pitfalls is
    to use algorithms that rely *less* on randomness. For example, you saw in chapter
    7 that ECDSA requires you to generate a random nonce every time you sign, whereas
    EdDSA does not. Another example you saw in chapter 4 is AES-GCM-SIV, which does
    not catastrophically break down if you happen to reuse the same nonce twice, as
    opposed to AES-GCM, which will leak the authentication key and will then lose
    integrity of the ciphertexts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Public randomness
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, I’ve talked mostly about *private randomness*, the kind you might need
    for your private keys. Sometimes, privacy is not required and *public randomness*
    is needed. In this section, I briefly survey some ways to obtain such public randomness.
    I distinguish two scenarios:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '*One-to-many*—You want to produce randomness for others.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Many-to-many*—A set of participants want to produce randomness together.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let’s imagine that you want to generate a stream of randomness in a
    way that many participants can verify it. In other words, the stream should be
    unpredictable but impossible to alter from your perspective. Now imagine that
    you have a signature scheme that provides unique signatures based on a key pair
    and a message. With such a signature scheme, there exists a construction called
    a *verifiable random function* (VRF) to obtain random numbers in a verifiable
    way (figure 8.5 illustrates this concept). The following shows how this works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: You generate a key pair and publish the verifying key. You also publish a public
    seed.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate random numbers, you sign the public seed and hash the signature.
    The digest is your random number, and the signature is also published as proof.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify the random number, anyone can hash the signature to check if it matches
    the random number and verify that the signature is correct with the public seed
    and verifying key.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/08_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 A verifiable random function (VRF) generates verifiable randomness
    via public key cryptography. To generate a random number, simply use a signature
    scheme which produces unique signatures (like BLS) to sign a seed, then hash the
    signature to produce the public random number. To validate the resulting randomness,
    make sure that the hash of the signature is indeed the random number and verify
    the signature over the seed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This construction can be extended to produce many random numbers by using the
    public seed like a counter. Because the signature is unique and the public seed
    is fixed, there is no way for the signer to generate a different random number.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Signature schemes like BLS (mentioned in figure 8.5 and in chapter 7) produce
    unique signatures, but this is not true for ECDSA and EdDSA. Do you see why?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, the Internet Draft (a document that is meant to become an RFC)
    [https://tools.ietf.org/html/draft-irtf-cfrg-vrf-08](https://tools.ietf.org/html/draft-irtf-cfrg-vrf-08)
    specifies how to implement a VRF using ECDSA. In some scenarios (for example,
    a lottery game), several participants might want to randomly decide on a winner.
    We call them *decentralized randomness beacons* as their role is to produce the
    same verifiable randomness even if some participants decide not to take part in
    the protocol. A common solution is to use the previously discussed VRFs, not with
    a single key but with a *threshold distributed key*, a key that is split among
    many participants and that produces a unique valid signature for a given message
    only after a threshold of participants have signed the message. This might sound
    a bit confusing as this is the first time I’ve talked about distributed keys.
    Know that you will learn more about these later in this chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，互联网草案（一个旨在成为RFC的文档）[https://tools.ietf.org/html/draft-irtf-cfrg-vrf-08](https://tools.ietf.org/html/draft-irtf-cfrg-vrf-08)
    指定了如何使用ECDSA实现VRF。在某些场景中（例如，抽奖游戏），几个参与者可能希望随机决定一个赢家。我们称他们为*去中心化随机信标*，因为他们的角色是即使一些参与者决定不参与协议，也要产生相同的可验证随机性。一个常见的解决方案是使用先前讨论过的VRF，不是使用单一密钥，而是使用*阈值分布密钥*，即将密钥分割在许多参与者之间，只有在一定数量的参与者签署消息后才为给定消息生成唯一有效签名。这可能听起来有点混乱，因为这是我第一次谈到分布式密钥。请注意，您将在本章后面更多地了解这些内容。
- en: One popular decentralized randomness beacon is called *drand* and is run in
    concert by several organizations and universities. It is available at [https://leagueofentropy.com](https://tools.ietf.org/html/draft-irtf-cfrg-vrf-08).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的去中心化随机信标称为*drand*，由几个组织和大学共同运行。它可以在[https://leagueofentropy.com](https://tools.ietf.org/html/draft-irtf-cfrg-vrf-08)找到。
- en: '*The main challenge in generating good randomness is that no party involved
    in the randomness generation process should be able to predict or bias the final
    output. A drand network is not controlled by anyone of its members. There is no
    single point of failure, and none of the drand server operators can bias the randomness
    generated by the network*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成良好随机性的主要挑战在于参与随机性生成过程的任何一方都不应能够预测或偏向最终输出。drand网络不受其任何成员控制。没有单点故障，也没有任何drand服务器运营商可以偏向网络生成的随机性*。'
- en: —[https://drand.love](https://drand.love) (“How drand works,” 2021)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: —[https://drand.love](https://drand.love)（“drand的工作原理”，2021）
- en: Now that I’ve talked extensively about randomness and how programs obtain it
    nowadays, let’s move the discussion towards the role of secrets in cryptography
    and how one can manage those.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经广泛讨论了随机性以及程序如何获取它，让我们将讨论转向密码学中秘密的作用以及如何管理这些秘密。
- en: 8.6 Key derivation with HKDF
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 使用HKDF进行密钥派生
- en: 'PRNGs are not the only constructions one can use to derive more secrets from
    one secret (in other words, to stretch a key). Deriving several secrets from one
    secret is actually such a frequent pattern in cryptography that this concept has
    its own name: *key derivation*. So let’s see what this is about.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PRNG并不是唯一可以用来从一个秘密派生更多秘密（换句话说，拉伸密钥）的构造。从一个秘密派生多个秘密实际上是密码学中如此频繁的模式，以至于这个概念有自己的名字：*密钥派生*。所以让我们看看这是什么意思。
- en: A *key derivation function* (KDF) is like a PRNG in many ways, except for a
    number of subtleties as noted in the following list. The differences are summarized
    in figure 8.6.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*密钥派生函数*（KDF）在许多方面类似于PRNG，除了以下列表中指出的一些微妙之处。这些差异在图8.6中总结。'
- en: '*A KDF does not necessarily expect a uniformly random secret (as long as it
    has enough entropy).* This makes a KDF useful for deriving secrets from key exchange
    output, which produce high entropy but biased results (see chapter 5). The resulting
    secrets are, in turn, uniformly random, so you can use these in constructions
    that expect uniformly random keys.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*KDF并不一定需要一个均匀随机的秘密（只要有足够的熵）。* 这使得KDF可以从密钥交换输出中派生秘密，产生高熵但有偏差结果的密钥（参见第5章）。结果的秘密反过来是均匀随机的，因此您可以在需要均匀随机密钥的构造中使用这些密钥。'
- en: '*A KDF is generally used in protocols that require participants to rederive
    the same keys several times.* In this sense, a KDF is expected to be deterministic,
    while PRNGs sometimes provide backward secrecy by frequently reseeding themselves
    with more entropy.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*KDF通常用于需要参与者多次重新派生相同密钥的协议中。* 在这个意义上，KDF被期望是确定性的，而PRNG有时通过频繁地使用更多熵重新种子化自身来提供向后保密性。'
- en: '*A KDF is usually not designed to produce a LOT of random numbers.* Instead,
    it is normally used to derive a limited number of keys.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/08_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 A key derivation function (KDF) and a PRNG are two similar constructions.
    The main differences are that a KDF does not expect a fully uniformly random secret
    as input (as long as it has enough entropy) and is usually not used to generate
    too much output.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular KDF is the *HMAC-based key derivation function* (HKDF). You
    learned about HMAC (a MAC based on hash functions) in chapter 3\. HKDF is a light
    KDF built on top of HMAC and defined in RFC 5869\. For this reason, one can use
    HKDF with different hash functions, although, it is most commonly used with SHA-2\.
    HKDF is specified as two different functions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '*HKDF-Extract*—Removes biases from a secret input, producing a uniformly random
    secret.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*HKDF-Expand*—Produces an arbitrary length and uniformly random output. Like
    PRNGs, *it expects a uniformly random secret as input* and is, thus, usually ran
    after HKDF-Extract.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/08_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 HKDF-Expand is the second function specified by HKDF. It takes an
    optional `info` byte string and an input secret that needs to be uniformly random.
    Using different `info` byte strings with the same input secret produces different
    outputs. The length of the output is controlled by a `length` argument.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at HKDF-Extract first, which I illustrate in figure 8.7\. Technically,
    a hash function is enough to uniformize the randomness of an input byte string
    (remember, the output of a hash function is supposed to be indistinguishable from
    random), but HKDF goes further and accepts one additional input: a *salt*. As
    for password hashing, a salt differentiates different usages of HKDF-Extract in
    the same protocol. While this salt is optional and set to an all-zero byte string
    if not used, it is recommended that you do use it. Furthermore, HKDF does not
    expect the salt to be a secret; it can be known to everyone, including adversaries.
    Instead of a hash function, HKDF-Extract uses a MAC (specifically HMAC), which
    coincidentally has an interface that accepts two arguments.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at HKDF-Expand, which I illustrate in figure 8.8\. If your input
    secret is already uniformly random, you can skip HKDF-Extract and use HKDF-Expand.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 HKDF-Extract is the first function specified by HKDF. It takes an
    optional salt that is used as the key in HMAC and the input secret that might
    be nonuniformly random. Using different salts with the same input secret produces
    different outputs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Similar to HKDF-Extract, HKDF-Expand also accepts an additional and optional
    customization argument called `info`. While a salt is meant to provide some domain
    separation between calls within the same protocol for HKDF (or HKDF-Extract),
    `info` is meant to be used to differentiate your version of HKDF (or HKDF-Expand)
    from other protocols. You can also specify how much output you want, but keep
    in mind that HKDF is not a PRNG and is not designed to derive a large number of
    secrets. HKDF is limited by the size of the hash function you use; more precisely,
    if you use SHA-512 (which produces outputs of 512 bits) with HKDF, you are limited
    to 512 × 255 bits = 16,320 bytes of output for a given key and an `info` byte
    string.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Calling HKDF or HKDF-Expand several times with the same arguments, except for
    the output length, produces the same output truncated to the different length
    requested (see figure 8.9). This property is called *related outputs* and can,
    in rare scenarios, surprise protocol designers. It is good to keep this in mind.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 HKDF and HKDF-Expands provide related outputs, meaning that calling
    the function with different output lengths truncates the same result to the requested
    length.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Most cryptographic libraries combine HKDF-Extract and HKDF-Expand into a single
    call as figure 8.10 illustrates. As usual, make sure to read the manual (in this
    case, RFC 5869) before using HKDF.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 HKDF is usually found implemented as a single function call that
    combines both HKDF-Extract (to extract uniform randomness from an input key) and
    HKDF-Expand (to generate an arbitrary length output).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: HKDF is not the only way to derive multiple secrets from one secret. A more
    naive approach is to use *hash functions*. As hash functions do not expect a uniformly
    random input and produce uniformly random outputs, they are fit for the task.
    Hash functions are not perfect, though, as their interface does not take into
    account *domain separation* (no customization string argument) and their output
    length is fixed. Best practice is to avoid hash functions when you can use a KDF
    instead. Nonetheless, some well-accepted algorithms do use hash functions for
    this purpose. For example, you learned in chapter 7 about the Ed25519 signature
    scheme that hashes a 256-bit key with SHA-512 to produce two 256-bit keys.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Do these functions really produce random outputs?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In theory, a hash function’s properties do not say anything about the output
    being uniformly random; the properties only dictate that a hash function should
    be collision resistant, pre-image resistant, and second pre-image resistant. In
    the real world, though, we use hash functions all over the place to implement
    random oracles (as you learned in chapter 2), and thus, we assume that their outputs
    are uniformly random. This is the same with MACs, which are, in theory, not expected
    to produce uniformly random outputs (unlike PRFs as seen in chapter 3), but in
    practice, do for the most part. This is why HMAC is used in HKDF. In the rest
    of this book, I will assume that popular hash functions (like SHA-2 and SHA-3)
    and popular MACs (like HMAC and KMAC) produce random outputs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The extended output functions (XOFs) we saw in chapter 2 (SHAKE and cSHAKE)
    can be used as a KDF as well! Remember, a XOF
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Does not expect a uniformly random input
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can produce a practically infinitely large uniformly random output
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, KMAC (a MAC covered in chapter 3) does not have the related output
    issue I mentioned earlier. Indeed, KMAC’s length argument randomizes the output
    of the algorithm, effectively acting like an additional customization string.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there exists an edge case for inputs that have low entropy. Think about
    passwords, for example, that can be relatively guessable compared to a 128-bit
    key. The password-based key derivation functions used to hash passwords (covered
    in chapter 2) can also be used to derive keys as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Managing keys and secrets
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All right, all good, we know how to generate cryptographic random numbers, and
    we know how to derive secrets in different types of situations. But we’re not
    out of the woods yet.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re using all of these cryptographic algorithms, we end up having
    to maintain a lot of secret keys. How do we store these keys? And how do we prevent
    these extremely sensitive secrets from being compromised? And what do we do if
    a secret becomes compromised? This problem is commonly known as *key management*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '*Crypto is a tool for turning a whole swathe of problems into key management
    problems*.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: —Lea Kissner (2019, [http://mng.bz/eMrJ](http://mng.bz/eMrJ))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'While many systems choose to leave keys close to the application that makes
    use of them, this does not necessarily mean that applications have no recourse
    when bad things happen. To prepare against an eventual breach or a bug that would
    leak a key, most serious applications employ two defense-in-depth techniques:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '*Key rotation*— By associating an expiration date to a key (usually a public
    key) and by replacing your key with a new key periodically, you can “heal” from
    an eventual compromise. The shorter the expiration date and rotation frequency,
    the faster you can replace a key that might be known to an attacker.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Key revocation*— Key rotation is not always enough, and you might want to
    cancel a key as soon as you hear it has been compromised. For this reason, some
    systems allow you to ask if a key has been revoked before making use of it. (You
    will learn more about this in the next chapter on secure transport.)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation is often indispensable to successfully using these techniques as
    a well-oiled machine is much more apt to work correctly in times of crisis. Furthermore,
    you can also associate a particular role to a key in order to limit the consequences
    of a compromise. For example, you could differentiate two public keys in some
    fabricated application as public key 1, which is only for signing transactions,
    and public key 2, which is only for doing key exchanges. This allows a compromise
    of the private key associated with public key 2 to not impact transaction signing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: If one does not want to leave keys lying around on device storage media, hardware
    solutions exist that aim at preventing keys from being extracted. You will learn
    more about these in chapter 13 on hardware cryptography.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Finally, many ways exist for applications to delegate key management. This is
    often the case on mobile OSs that provide *key stores* or *key chains*, which
    will keep keys for you and will even perform cryptographic operations!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Applications living in the cloud can sometimes have access to cloud key management
    services. These services allow an application to delegate creation of secret keys
    and cryptographic operations and to avoid thinking about the many ways to attack
    those. Nonetheless, as with hardware solutions, if an application is compromised,
    it will still be able to do any type of request to the delegated service.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Note There are no silver bullets, and you should still consider what you can
    do to detect and respond to a compromise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Key management is a hard problem that is beyond the scope of this book, so I
    will not dwell on this topic too much. In the next section, I go over cryptographic
    techniques that attempt to avoid the key management problem.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Decentralize trust with threshold cryptography
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Key management is a vast field of study that can be quite annoying to invest
    in as users do not always have the resources to implement best practices, nor
    the tools available in the space. Fortunately, cryptography has something to offer
    for those who want to lessen the burden of key management. The first one I’ll
    talk about is *secret sharing* (or *secret splitting*). Secret splitting allows
    you to break a secret into multiple parts that can be shared among a set of participants.
    Here, a secret can be anything you want: a symmetric key, a signing private key,
    and so on.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a person called a *dealer* generates the secret, then splits it and
    shares the different parts among all participants before deleting the secret.
    The most famous secret splitting scheme was invented by Adi Shamir (one of the
    co-inventors of RSA) and is called *Shamir’s Secret Sharing* (SSS). I illustrate
    this process in figure 8.11.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08_11.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 Given a key and a number of shares *n*, the Shamir’s Secret Sharing
    scheme creates *n* partial keys of the same size as the original key.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: When the time comes and the secret is needed to perform some cryptographic operation
    (encrypting, signing, and so on), all share owners need to return their private
    shares back to the dealer who is in charge of reconstructing the original secret.
    Such a scheme prevents attackers from targeting a single user as each share is
    useless by itself and, instead, forces attackers to compromise all the participants
    before they can exploit a key! I illustrate this in figure 8.12.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08_12.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 The Shamir’s Secret Sharing scheme used to split a secret in *n*
    partial keys requires all of the *n* partial keys to reconstruct the original
    key.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The mathematics behind the scheme’s algorithm are actually not too hard to understand!
    So let me spare a few paragraphs here to give you a simplified idea of the scheme.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a random straight line on a 2-dimensional space, and let’s say that
    its equation—*y* = *ax* + *b*—is the secret. By having two participants hold two
    random points on the line, they can collaborate to recover the line equation.
    The scheme generalizes to polynomials of any degree and, thus, can be used to
    divide a secret into an arbitrary number of shares. This is illustrated in figure
    8.13.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08_13.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 The idea behind the Shamir’s Secret Sharing scheme is to see a polynomial
    defining a curve as the secret and random points on the curve as partial keys.
    To recover a polynomial of degree *n* that defines a curve, one needs to know
    *n* + 1 points on the curve. For example, *f*(*x*) = 3*x* + 5 is of degree 1,
    so you need any two points (*x*, *f*(*x*)) to recover the polynomial, and *f*(*x*)
    = 5*x*² + 2*x* + 3 is of degree 2, so you need any three points to recover the
    polynomial.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Secret splitting is a technique often adopted due to its simplicity. Yet, in
    order to be useful, key shares must be gathered into one place to recreate the
    key each and every time it is used in a cryptographic operation. This creates
    a window of opportunity in which the secret becomes vulnerable to robberies or
    accidental leaks, effectively getting us back to a *single point of failure* model.
    To avoid this single point of failure issue, there exist several cryptographic
    techniques that can be useful in different scenarios.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine a protocol that accepts a financial transaction only if
    it has been signed by Alice. This places a large burden on Alice, who might be
    afraid of getting targeted by attackers. In order to reduce the impact of an attack
    on Alice, we can, instead, change the protocol to accept (on the same transaction)
    a number *n* of signatures from *n* different public keys, including Alice’s.
    An attacker would have to compromise all *n* signatures in order to forge a valid
    transaction! Such systems are called *multi-signature* (often shortened as *multi-sig*)
    and are widely adopted in the cryptocurrency space.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Naive multi-signature schemes, though, can add some annoying overhead. Indeed,
    the size of a transaction in our example grows linearly with the number of signatures
    required. To solve this, some signature schemes (like the BLS signature scheme)
    can compress several signatures down to a single one. This is called *signature
    aggregation*. Some multi-signature schemes go even further in the compression
    by allowing the *n* public keys to be aggregated into a single public key. This
    technique is called *distributed key generation* (DKG) and is part of a field
    of cryptography called *secure multi-party computation*, which I will cover in
    chapter 15.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: DKG lets *n* participants collaboratively compute a public key without ever
    having the associated private key in the clear during the process (unlike SSS,
    there is no dealer). If participants want to sign a message, they can then collaboratively
    create a signature using each participant’s private shares, which can be verified
    using the public key they previously created. Again, the private key never exists
    physically, preventing the single point of failure problem SSS has. Because you
    saw Schnorr signatures in chapter 7, figure 8.14 shows the intuition behind a
    simplified Schnorr DKG scheme.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08_14.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 The Schnorr signature scheme can be decentralized into a distributed
    key generation scheme.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Each scheme I’ve mentioned can be made to work even when only a threshold *m*
    out of the *n* participants take part in the protocol. This is really important
    as most real-world systems must tolerate a number of malicious or inactive participants.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types of schemes can work with other asymmetric cryptographic algorithms.
    For example, using threshold encryption, a set of participants can collaborate
    to asymmetrically decrypt a message.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I review all these examples in figure 8.15.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/08_15.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 A recap of existing techniques to split the trust we have in one
    participant into several participants.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Threshold schemes are an important new paradigm in the key management world,
    and it is a good idea to follow their development. NIST currently has a threshold
    cryptography group, which organizes workshops and has the intent to standardize
    primitives and protocols in the long run.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number is taken uniformly and at random from a set if it was picked with equal
    probability compared to all the other numbers from that set.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entropy is a metric to indicate how much randomness a byte string has. High
    entropy refers to byte strings that are uniformly random, while low entropy refers
    to byte strings that are easy to guess or predict.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pseudorandom number generators (PRNGs) are algorithms that take a uniformly
    random seed and generate (in practice) a nearly infinite amount of randomness
    that can be used for cryptographic purposes (as cryptographic keys, for example)
    if the seed is large enough.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To obtain random numbers, one should rely on a programming language’s standard
    library or on its well-known cryptographic libraries. If these are not available,
    operating systems generally provide interfaces to obtain random numbers:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows offers the `BCryptGenRandom` system call.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux and FreeBSD offer the `getrandom` system call.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Unix-like operating systems usually have a special file called /dev/ urandom
    that exhibites randomness.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Key derivation functions (KDFs) are useful in scenarios where one wants to derive
    secrets from a biased but high entropy secret.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HKDF (HMAC-based key derivation function) is the most widely used KDF and is
    based on HMAC.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key management is the field of keeping secrets, well, secret. It mostly consists
    of finding where to store secrets, proactively expiring and rotating secrets,
    figuring out what to do when secrets are compromised, and so on.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To lessen the burden of key management, one can split the trust from one participant
    into multiple participants.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
