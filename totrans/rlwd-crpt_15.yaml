- en: 13 Hardware cryptography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 硬件加密
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Cryptography issues in highly adversarial environments
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度对抗性环境中的密码学问题
- en: Hardware solutions to increase the attacker’s cost
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加攻击者成本的硬件解决方案
- en: Side-channel attacks and software mitigations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧信道攻击和软件缓解措施
- en: 'Cryptographic primitives and protocols are often described as isolated building
    blocks as if they were running in a galaxy far, far away from any adversary. In
    practice, this is an unrealistic assumption that has often proven wrong. In the
    real world, cryptography runs in all kinds of environments and is subject to all
    sorts of threats. In this chapter, we’ll look at the more extreme scenarios—*the
    highly adversarial environments*—and what you can do to protect your keys and
    your data in these situations. (Spoiler alert: it involves using specialized hardware.)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学原语和协议经常被描述为孤立的构建模块，仿佛它们在远离任何对手的星系中运行。实际上，这是一个不切实际的假设，经常被证明是错误的。在现实世界中，密码学在各种环境中运行，并受到各种威胁的影响。在本章中，我们将研究更极端的场景——*高度对抗性环境*——以及您在这些情况下可以采取的措施以保护您的密钥和数据。（剧透警告：这涉及使用专门的硬件。）
- en: 13.1 Modern cryptography attacker model
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 现代密码学攻击模型
- en: '*Present-day computer and network security starts with the assumption that
    there is a domain that we can trust. For example: if we encrypt data for transport
    over the Internet, we generally assume the computer that’s doing the encrypting
    is not compromised and that there’s some other “endpoint” at which it can be safely
    decrypted*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*当今的计算机和网络安全始于这样一个假设，即存在一个我们可以信任的域。例如：如果我们为了在互联网上传输数据而加密数据，我们通常假设进行加密的计算机没有被损害，并且存在一些其他的“终点”，可以在那里安全地解密它*。'
- en: —Joanna Rutkowska (“Intel x86 considered harmful,” 2015)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: — Joanna Rutkowska（《Intel x86可恶之处》，2015）
- en: 'Cryptography used to be about “Alice wants to encrypt a message to Bob without
    Eve being able to intercept it.” Today, a lot of it has moved to something more
    like “Alice wants to encrypt a message to Bob, but Alice has been compromised.”
    It’s a totally different attacker model, which is often not anticipated for in
    theoretical cryptography. What do I mean by this? Let me give you some examples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学曾经是关于“爱丽丝想要将消息加密发送给鲍勃，而不让伊娃能够截获它”。如今，它的大部分内容已经转移到了更类似于“爱丽丝想要将消息加密发送给鲍勃，但爱丽丝已经受到了损害。”这是一个完全不同的攻击者模型，通常在理论密码学中没有被预料到。我这是什么意思？让我给你一些例子：
- en: Using your credit card on an automated teller machine (ATM) that might be augmented
    with a *skimmer*, which is a device that a thief can place on top of the card
    reader in order to copy the content of your bank card (see figure 13.1)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能装有*读取器假面*（skimmer）的自动取款机（ATM）上使用信用卡。读取器假面是窃贼可以放置在读卡器顶部的设备，用于复制您银行卡的内容（见图13.1）
- en: Downloading an application on your mobile phone that compromises the operating
    system (OS)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的手机上下载一个破坏操作系统（OS）的应用程序
- en: Hosting a web server in a shared web-hosting service, where another malicious
    customer might be sharing the same machine as you
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在共享网络托管服务中托管网站，另一个恶意客户可能与您共用同一台机器
- en: Managing highly sensitive secrets in a data center that gets visited by spies
    from a different country
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在被来自不同国家间谍访问的数据中心中管理高度敏感的机密
- en: '![](../Images/13_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_01.jpg)'
- en: Figure 13.1 A skimmer, a malicious device that can be placed in front of ATM
    or payment terminal card readers in order to copy data contained in the card magnetic
    stripe. The magnetic stripe usually contains the account number, the expiration
    date, and other metadata that’s used by you to pay online or in a number of payment
    terminals. Skimmers are sometimes accompanied with a hidden camera to obtain your
    PIN as well, potentially enabling the thief to use ATM withdrawals and payment
    terminals enforcing PIN entry.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 读取器假面，一种恶意设备，可放置在ATM或付款终端的读卡器前，以复制磁条中的数据。磁条通常包含账号、到期日期和其他元数据，您用于在线支付或在许多付款终端上支付。假面有时伴随着隐藏摄像头一起使用，以获取您的个人识别码（PIN），从而潜在地使窃贼能够进行取款和要求输入PIN的付款终端。
- en: All of these examples are a modern use of cryptography in a threat model that
    many cryptographers ignore or are totally unaware of. Indeed, most of the cryptographic
    primitives that you read about in the literature will just assume that Alice,
    for example, has total control of her execution environment, and only when ciphertext
    (or a signature or a public key or . . .) leaves her computer to go over the network
    will man-in-the-middle (MITM) attackers be able to perform their tricks. But,
    in reality and in these modern times, we often use cryptography in much more adversarial
    models.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都是在许多密码学家忽视或完全不了解的威胁模型中对密码学的现代应用。事实上，您在文献中读到的大多数密码学原语都假设例如，艾丽丝完全控制她的执行环境，只有当密文（或签名或公钥或……）离开她的计算机进入网络时，中间人攻击者才能执行他们的技巧。但是，在现实和现代，我们经常在更具对抗性的模型中使用密码学。
- en: Warning Security is, after all, a product of your assumptions and what you expect
    of a potential attacker. If your assumptions are wrong, you’re in for a bad time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 安全性毕竟是您的假设和对潜在攻击者的期望的产物。如果您的假设是错误的，那么您将度过糟糕的时光。
- en: How do real-world applications reconcile theoretical cryptography with these
    more powerful attackers? They make *compromises*. In other words, they try to
    make the attackers’ lives more difficult. The security of such systems is often
    calculated in *cost* (how much does the attacker have to spend to break the system?)
    rather than computational complexity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的应用如何将理论加密与这些更强大的攻击者相协调？它们做出*妥协*。换句话说，他们试图让攻击者的生活更加困难。这些系统的安全性通常是以*成本*（攻击者需要花费多少来破解系统？）而不是计算复杂性来计算的。
- en: A lot of what you’ll learn in this chapter will be *imperfect* cryptography,
    which in the real world, we call *defense in depth*. There’s a lot to learn, and
    this chapter comes with lots of new acronyms and different solutions that different
    vendors and their marketing teams and sales people have come up with. So let’s
    get started and learn about trusted systems in untrusted environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到很多*不完美的*加密技术，这在现实世界中我们称之为*深度防御*。有很多东西需要学习，这一章带来了许多新的缩略词和不同的解决方案，不同的供应商以及他们的营销团队和销售人员提出了。所以让我们开始学习在不受信任的环境中的可信系统。
- en: '13.2 Untrusted environments: Hardware to the rescue'
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 不受信任的环境：硬件拯救
- en: 'There are different ways to attack a system in practice. One way to categorize
    them is to think:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实践中攻击系统有不同的方法。将它们归类的一种方式是这样思考：
- en: '*Software attacks*—Attacks that leverage code run on your device'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*软件攻击*—利用在您设备上运行的代码的攻击。'
- en: '*Hardware attacks*—Attacks that require the adversary to be physically close
    to your device'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*硬件攻击*—需要攻击者物理接近您的设备的攻击方式。'
- en: While I already talked repeatedly about software attacks that target cryptography
    and how to mitigate them in previous chapters, there are some software attacks
    that are easier to defend if you leverage hardware solutions. For example, by
    generating and using cryptographic keys on a separate device connected to your
    computer, a virus hitting your computer wouldn’t be able to extract the keys.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我已经反复讨论了针对加密的软件攻击以及如何减轻它们的影响，但是如果利用硬件解决方案，有些软件攻击会更容易防御。例如，通过在连接到您计算机的独立设备上生成和使用加密密钥，一个感染您计算机的病毒将无法提取密钥。
- en: 'Hardware attacks, however, are more tricky because attackers who get access
    to a device can pretty much do anything they want: data on disk can be arbitrarily
    modified, lasers can be shot on targeted places to force a computation to produce
    an erroneous value (so-called *fault attacks*), chips can be opened to reveal
    their parts, focused ion beam (FIB) microscopes can be used to reverse-engineer
    components, and so on. The sky’s the limit, and it is hard to protect against
    such motivated attackers. Typically, the different solutions available boil down
    to adding as many layers of defenses as you can in an attempt to make the attacker’s
    life much more difficult. It is all about raising the costs!'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，硬件攻击更加棘手，因为获得设备访问权限的攻击者几乎可以为所欲为：磁盘上的数据可以任意修改，激光可以瞄准特定位置以迫使计算产生错误值（所谓的*故障攻击*），芯片可以打开以显示其部件，聚焦离子束（FIB）显微镜可用于逆向工程组件等等。天空是极限，保护免受这种有动机的攻击者是很困难的。通常，可用的不同解决方案归结为尽可能添加更多层次的防御以使攻击者的生活更加困难。这一切都是关于提高成本！
- en: Evil maid attacks
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意女佣攻击
- en: 'Not all hardware attackers are the same. For example, some attackers are able
    to spend some quality time with your devices, while others might have a limited
    amount of time. Imagine the following scenario: you leave your phone or laptop
    unattended in your hotel room, and a “malicious” maid comes in, opens the device,
    uses a low-budget, off-the-shelf tool to modify the system, and then leaves the
    device appearinguntouched where it was found before you get back to your room.
    In the literature, this is known as an *evil maid attack* and can be generalized
    for many situations (for example, carrying devices in check-in luggages while
    flying, storing sensitive keys in an insecure data center, and so forth).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的硬件攻击者都是一样的。例如，有些攻击者可以花费一些时间与您的设备相处，而其他人可能只有有限的时间。想象一下以下情景：您把手机或笔记本电脑放在酒店房间里不管，一个“恶意”的女佣进来，打开设备，使用低成本的现成工具修改系统，然后离开设备看起来未经触碰就回到您的房间之前的地方。在文献中，这被称为*恶毒女佣攻击*，并且可以推广到许多情况（例如，携带设备在飞行时的托运行李中，将敏感密钥存储在不安全的数据中心中等）。
- en: Of course, all systems don’t necessarily need to defend against the most powerful
    hardware attacks, and not all applications deal with the same level of threat.
    Different hardware solutions exist for different contexts, so the rest of this
    section is about understanding the differences between “such and such.”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有系统都必须防范最强大的硬件攻击，也不是所有应用程序都面对相同级别的威胁。不同的硬件解决方案适用于不同的情境，因此本节剩余内容是关于理解“这样那样”的区别。
- en: 13.2.1 White box cryptography, a bad idea
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 白盒密码学，一个糟糕的想法
- en: Before getting into hardware solutions for untrusted environments, why not use
    software solutions? Can cryptography provide primitives that do not leak their
    own keys?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及不受信任环境的硬件解决方案之前，为什么不使用软件解决方案呢？密码学能否提供不泄露自己密钥的原语？
- en: '*White box cryptography* is exactly this: a field of cryptography that attempts
    to scramble a cryptographic implementation with the key it uses. The goal is to
    prevent extraction of the key from observers. The attacker obtains the source
    code of some white box AES implementation with a fixed key, and it encrypts and
    decrypts just fine, but the key is mixed so well with the implementation that
    it is too hard for anyone to extract it from the algorithm. That’s the theory
    at least. In practice, no published white box crypto algorithm has been found
    to be secure, and most commercial solutions are closed-source due to this fact.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*白盒密码学*正是这样：密码学的一个领域，试图将其使用的密钥与加密实现混合在一起。目标是防止观察者从中提取密钥。攻击者获取了某个带有固定密钥的白盒AES实现的源代码，它可以很好地加密和解密，但是密钥与实现混合得太好了，以至于任何人都很难从算法中提取它。这至少是理论上的。在实践中，尚未发现任何已发布的白盒密码算法是安全的，大多数商业解决方案由于这个原因是闭源的。'
- en: Note *Security through obscurity and obfuscation* (scrambling code to make it
    look unintelligible) are techniques that are generally frowned on as they haven’t
    been proven to work effectively. That being said, in the real world, these techniques
    sometimes have their place and can be used to delay and frustrate adversaries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*安全通过模糊和混淆*（将代码混淆以使其看起来难以理解）是一种通常不受欢迎的技术，因为它们尚未被证明有效。尽管如此，在现实世界中，这些技术有时会有用，并且可以用来延迟和挫败对手。
- en: All in all, white box cryptography is a big industry that sells dubious products
    to businesses in need of *digital rights management* (DRM) solutions (tools that
    control how much access a customer can get to a product they bought). For example,
    you can find these white-box solutions in the hardware that plays movies you bought
    in a store or in the software that plays movies you are watching on a streaming
    service. In reality, DRM does not strongly prevent these attacks; it just makes
    the life of their customers more difficult. On a more serious note, there is a
    branch of cryptography called *indistinguishability obfuscation* (iO) that attempts
    to do this cryptographically. iO is a theoretical, impractical, and so far, not-a-really-proven
    field of research. We’ll see how that one goes, but I wouldn’t hold my breath.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，白盒密码学是一个大行业，向需要*数字版权管理*（DRM）解决方案的企业销售可疑的产品（控制客户对其购买的产品的访问权限的工具）。例如，您可以在播放您在商店购买的电影的硬件中找到这些白盒解决方案，或者在您正在观看的流媒体服务中播放电影的软件中找到这些解决方案。实际上，DRM并不能强力阻止这些攻击；它只是让他们的客户的生活变得更加困难。更严肃的是，有一个称为*不可区分混淆*（iO）的密码学分支试图在密码学上实现这一点。iO是一个理论上的、不切实际的、到目前为止还没有真正被证明的研究领域。我们将看看这个领域的发展如何，但我不会抱太大希望。
- en: '13.2.2 They’re in your wallet: Smart cards and secure elements'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 它们在你的钱包里：智能卡和安全元素
- en: 'White box cryptography is not great, but that’s pretty much the best software
    solution for defending against powerful adversaries. So let’s turn to the hardware
    side for solutions. (Spoiler alert: things are about to get much more complicated
    and confusing.) If you thought that real-world cryptography was messy and that
    there were too many standards or ways to do the same thing, wait until you read
    what’s going on in the hardware world. Different terms have been made up and used
    in different ways, and standards have, unfortunately, proliferated as much as
    (if not more than) cryptography standards.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒密码学并不是很好，但这几乎是对抗强大对手的最佳软件解决方案。因此，让我们转向硬件方面寻找解决方案。（剧透警告：事情即将变得更加复杂和令人困惑。）如果您认为现实世界的密码学很混乱，有太多的标准或做同样事情的方法，那么等到您了解硬件世界正在发生的事情时，您会感到更加惊讶。不同的术语已经被创造并以不同的方式使用，标准不幸地像密码学标准一样多样化（如果不是更多）。
- en: To understand what all of these hardware solutions are and how they differ from
    one another, let’s start with some necessary history. *Smart cards* are small
    chips usually seen packaged inside plastic cards (like bank cards) and were invented
    in the early 1970s following advances in microelectronics. Smart cards started
    out as a practical way to get everyone a pocket computer! Indeed, a modern smart
    card embeds its own CPU, different types of programmable or non-programmable memory
    (ROM, RAM, and EEPROM), inputs and outputs, a hardware random number generator
    (also called TRNG as you learned in chapter 8), and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解所有这些硬件解决方案以及它们之间的区别，让我们从一些必要的历史开始。*智能卡*是通常包装在塑料卡（如银行卡）内的小芯片，于20世纪70年代初在微电子技术的进步之后发明。智能卡最初是让每个人都有一个口袋计算机的实用方式！事实上，现代智能卡嵌入了自己的CPU、不同类型的可编程或不可编程存储器（ROM、RAM和EEPROM）、输入和输出、硬件随机数生成器（也称为TRNG，正如你在第8章中学到的），等等。
- en: They’re “smart” in the sense that they can run programs, unlike the not-so-smart
    cards that could only store data via a magnetic stripe, which could be easily
    copied via the skimmers I talked about previously. Most smart cards allow developers
    to write small, contained applications that can run on the card. The most popular
    standard supported by smart cards is *JavaCard*, which allows developers to write
    Java-like applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在“智能”方面是指它们可以运行程序，不像以前的不那么智能的卡片只能通过磁条存储数据，这些数据可以很容易通过我之前提到的偷取器复制。大多数智能卡允许开发人员编写可以在卡上运行的小型、独立的应用程序。智能卡支持的最流行的标准是*JavaCard*，它允许开发人员编写类似于Java的应用程序。
- en: To use a smart card, you first need to activate it by inserting it into a card
    reader. More recently, cards have been augmented with the Near Field Communication
    (NFC) protocol to achieve the same result via radio frequencies. This allows you
    to use the card by getting close to a card reader, as opposed to physically touching
    it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用智能卡，您首先需要通过将其插入读卡器来激活它。最近，卡片已经通过近场通信（NFC）协议进行了增强，以通过无线电频率实现相同的结果。这使您可以通过靠近读卡器来使用卡片，而不是物理接触。
- en: Banks and legacy cryptography
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 银行和传统密码学
- en: By the way, banks make use of smart cards to store a unique per-card secret
    that’s capable of saying, “I am indeed the card that you gave to this customer.”
    Intuitively, you might think that this is implemented via public key cryptography,
    but the banking industry is still stuck in the past and uses symmetric cryptography
    (due to the vast amount of legacy software and hardware still in use)!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，银行利用智能卡存储每张卡的唯一卡密，能够表明：“我确实是您给这位客户的卡。”直觉上，您可能认为这是通过公钥加密实现的，但银行业仍然停留在过去，使用对称加密（由于仍在使用的大量传统软件和硬件）！
- en: 'More specifically, most bank card stores a *triple-DES* (3DES) symmetric key,
    an old 64-bit block cipher that seeks to make the insecure Data Encryption Standard
    (DES) secure. The algorithm is used not to encrypt, but to produce a MAC (message
    authentication code) over some challenge. The bank who holds every customer’s
    current 3DES symmetric key can verify the MAC. This is an excellent example of
    what real-world cryptography is often about: legacy algorithms used all over the
    place in a risky way. (And this is also why key rotation is such an important
    concept and why you have to change your bank cards periodically.)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，大多数银行卡存储着一个*三重DES*（3DES）对称密钥，这是一个旧的64位分组密码，旨在使不安全的数据加密标准（DES）安全。该算法用于生成MAC（消息认证码）而不是加密，用于对某些挑战生成MAC。持有每位客户当前3DES对称密钥的银行可以验证MAC。这是现实世界加密通常涉及的一个绝佳例子：在许多地方以一种危险的方式使用的传统算法。（这也是为什么密钥轮换是一个如此重要的概念，以及为什么你必须定期更换银行卡。）
- en: 'Smart cards mix a number of physical and logical techniques to prevent observation,
    extraction, and modification of their execution environment and parts of their
    memory (where secrets are stored). There exist many attacks that attempt to break
    these cards and hardware devices in general. These attacks can be classified in
    three different categories:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡结合了许多物理和逻辑技术，以防止其执行环境和存储秘密的部分的观察、提取和修改。存在许多试图破解这些卡片和硬件设备的攻击。这些攻击可以分为三种不同的类别：
- en: '*Non-invasive attacks*—Attacks that do not affect the targeted device. For
    example, differential power analysis (DPA) attacks evaluate the power consumption
    of a smart card while it simultaneously performs cryptographic operations in order
    to extract its keys.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非侵入式攻击*—不会影响目标设备的攻击。例如，差分功耗分析（DPA）攻击评估智能卡在执行加密操作时的功耗，以提取其密钥。'
- en: '*Semi-invasive attacks*—Attacks that use access to the chip’s surface in a
    non-damaging way to mount exploits. For example, differential fault analysis (DFA)
    attacks make use of heat, lasers, and other techniques to modify the execution
    of a program running on the smart card in order to leak keys.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*半侵入式攻击*—利用对芯片表面的访问以非破坏性方式进行攻击以实施利用。例如，差分故障分析（DFA）攻击利用热量、激光等技术修改智能卡上运行的程序的执行，以泄露密钥。'
- en: '*Invasive attacks*—Attacks that open the chip to probe or modify the circuitry
    in the silicon itself in order to alter the chip’s function and reveal its secrets.
    These attacks are noticeable because they can damage devices and have a greater
    chance of rendering devices unusable.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*侵入式攻击*—打开芯片以探测或修改硅片电路，以改变芯片的功能并揭示其秘密的攻击。这些攻击是显著的，因为它们可能损坏设备，并且有更大的可能性使设备无法使用。'
- en: The fact that hardware chips are extremely small and tightly packaged can make
    attacks difficult. But specialized hardware usually goes much further by using
    different layers of materials to prevent depackaging and physical observation
    and by using hardware techniques to increase the inaccuracy of known attacks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件芯片非常小且紧密封装的事实可能使攻击变得困难。但专门的硬件通常通过使用不同层次的材料防止解封和物理观察，并使用硬件技术增加已知攻击的不准确性而进一步防范。
- en: 'Smart cards got really popular really fast, and it became obvious that having
    such a secure black box in other devices could be useful. The concept of a *secure
    element* was born: a tamper-resistant microcontroller that can be found in pluggable
    form (for example, the SIM card in your phone required to access your carrier’s
    network) or directly bonded on chips and motherboards (for example, the embedded
    secure element attached to an iPhone’s NFC chip for payments). A secure element
    is really just a small, separate piece of hardware meant to protect your secrets
    and their usage in cryptographic operations.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡迅速变得非常流行，很快就变得明显，将这样一个安全的黑匣子放入其他设备中可能是有用的。一个*安全元件*的概念诞生了：一个防篡改的微控制器，可以以可插拔的形式找到（例如，您手机中用于访问运营商网络所需的SIM卡）或直接粘贴在芯片和主板上（例如，连接到iPhone
    NFC芯片进行支付的嵌入式安全元件）。安全元件实际上只是一个小型、独立的硬件部件，旨在保护您的机密信息及其在加密操作中的使用。
- en: Secure elements are an important concept to protect cryptographic operations
    in the *Internet of Things* (IoT), a colloquial (and overloaded) term referring
    to devices that can communicate with other devices (think credit cards, phones,
    biometric passports, garage keys, smart home sensors, and so on). You can see
    all of the solutions that follow in this section as secure elements implemented
    in different form factors, using different techniques to achieve pretty much the
    same thing, but providing different levels of security and speed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安全元件是保护*物联网*（IoT）中的加密操作的重要概念，这是一个口头上的（并且有点过载的）术语，指的是可以与其他设备通信的设备（比如信用卡、手机、生物识别护照、车库钥匙、智能家居传感器等等）。您可以将本节中的所有解决方案视为以不同形式实现的安全元素，使用不同的技术来实现几乎相同的功能，但提供不同级别的安全性和速度。
- en: The main definitions and standards around secure elements have been produced
    by Global Platform, a nonprofit association created from the need of the different
    players in the industry to facilitate interoperability among different vendors
    and systems. There exist more standards and certifications that focus on the security
    claims of secure elements from standard bodies like Common Criteria (CC), NIST,
    or the EMV (for Europay, Mastercard, and Visa).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安全元素的主要定义和标准是由Global Platform制定的，这是一个由行业内不同参与者的需求而创建的非营利性协会，旨在促进不同供应商和系统之间的互操作性。还有更多关于安全元素的安全声明的标准和认证，来自Common
    Criteria（CC）、NIST或EMV（欧洲支付、万事达卡和Visa）等标准机构。
- en: As secure elements are highly secretive recipes, integrating them in your product
    means that you will have to sign nondisclosure agreements and use closed-source
    hardware and firmware. For many projects, this is seen as a serious limitation
    in transparency, but can be understood, as part of the security in these chips
    come from the obscurity of their design.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全元素是高度保密的配方，将它们集成到您的产品中意味着您将不得不签署保密协议并使用闭源硬件和固件。对于许多项目来说，这被视为透明度的严重限制，但可以理解，因为这些芯片的安全性部分来自于其设计的模糊性。
- en: '13.2.3 Banks love them: Hardware security modules (HSMs)'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 银行喜欢它们：硬件安全模块（HSM）
- en: If you understood what a secure element is, well a *hardware security module*
    (HSM) is basically a bigger and faster secure element, and like some secure elements,
    some HSMs can run arbitrary code as well. This is not always true, however. Some
    HSMs are small (like the YubiHSM, a tiny USB dongle that resembles a YubiKey),
    and the term *hardware security module* can be used to mean different things by
    different people.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解什么是安全元件，那么*硬件安全模块*（HSM）基本上就是一个更大更快的安全元件，而且像一些安全元件一样，一些HSM也可以运行任意代码。然而，这并不总是正确的。一些HSM很小（比如YubiHSM，一个微型USB
    dongle，类似于YubiKey），而术语*硬件安全模块*可能会因人而异地被用来表示不同的事物。
- en: Many would argue that all of the hardware solutions discussed so far are HSMs
    of different forms and that secure elements are just HSMs specified by GlobalPlatform,
    while TPMs (Trusted Platform Modules) are HSMs specified by the Trusted Computing
    Group. But most of the time, when people talk about HSMs, they mean the big stuff.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人会认为到目前为止讨论的所有硬件解决方案都是不同形式的HSM，并且安全元素只是由GlobalPlatform指定的HSM，而TPM（可信平台模块）是由Trusted
    Computing Group指定的HSM。但大多数时候，当人们谈论HSM时，他们指的是大型设备。
- en: 'HSMs are often classified according to FIPS 140-2, “Security Requirements for
    Cryptographic Modules.” The document is quite old, published in 2001, and naturally,
    does not take into account a number of attacks discovered after its publication.
    Fortunately, in 2019, it was superseded by the more modern version, FIPS 140-3\.
    FIPS 140-3 now relies on two international standards:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: HSM 经常根据 FIPS 140-2 进行分类，“加密模块的安全要求”。该文档相当古老，于 2001 年出版，自然而然地，并未考虑在其出版后发现的许多攻击。幸运的是，在
    2019 年，它被更现代的版本 FIPS 140-3 所取代。FIPS 140-3 现在依赖于两个国际标准：
- en: '*ISO/IEC 19790:2012*—Defines four security levels for hardware security modules.
    Level 1 HSMs do not provide any protection against physical attacks (you can think
    of these as pure software implementations), while level 3 HSMs wipe their secrets
    if they detect any intrusion!'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO/IEC 19790:2012*—为硬件安全模块定义了四个安全等级。一级 HSM 不提供任何防御措施（你可以将其视为纯软件实现），而三级 HSM
    如果检测到任何入侵，就会擦除其秘密！'
- en: '*ISO 24759:2017*—Defines how HSMs must be tested in order to standardize certifications
    for HSM products.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO 24759:2017*—定义了 HSM 必须如何测试以标准化 HSM 产品的认证。'
- en: Unfortunately, the two standards are not free. You’ll have to pay if you want
    to read them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这两个标准都不是免费的。如果你想阅读它们，就得付费。
- en: The US, Canada, and some other countries mandate certain industries like banks
    to use devices that have been certified according to the FIPS 140 levels. Many
    companies worldwide follow these same recommendations as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 美国、加拿大和一些其他国家规定某些行业（如银行）必须使用根据 FIPS 140 等级认证的设备。全球许多公司也遵循这些建议。
- en: Note Wiping secrets is a practice called *zeroization*. Unlike level 3 HSMs,
    level 4 HSMs can overwrite secret data multiple times, even in cases of power
    outages, thanks to backup internal batteries.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：擦除秘密是一种叫做 *零化* 的做法。与三级 HSM 不同，四级 HSM 可以多次覆盖秘密数据，即使在停电情况下也是如此，这要归功于备份内部电池。
- en: Typically, you find an HSM as an external device with its own shelf on a rack
    (see figure 13.2) plugged to an enterprise server in a data center, as a PCIe
    card plugged into a server’s motherboard, or even as small dongles that resemble
    hardware security tokens. They can be plugged into your hardware via USB devices
    (if you don’t mind the lower performance). To go full circle, some of these HSMs
    can be administered using smart cards to install applications, to back up secret
    keys, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现 HSM 是一个外部设备，有自己的货架放在机架上（见图 13.2），插入到数据中心中的企业服务器上，作为插入到服务器主板上的 PCIe 卡，或者甚至是类似硬件安全令牌的小型
    dongle。它们可以通过 USB 设备插入到你的硬件中（如果你不介意较低的性能）。回到原点，其中一些 HSM 可以使用智能卡进行管理，用于安装应用程序，备份密钥等等。
- en: '![](../Images/13_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_02.jpg)'
- en: Figure 13.2 An IBM 4767 HSM as a PCI card. Photo from Wikipedia ([http://mng.bz/XrAG](http://mng.bz/XrAG)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 作为 PCI 卡的 IBM 4767 HSM。来自维基百科的照片（[http://mng.bz/XrAG](http://mng.bz/XrAG)）。
- en: 'Some industries highly utilize HSMs. For example, every time you enter your
    PIN in an ATM, the PIN ends up being verified by an HSM somewhere. Whenever you
    connect to a website via HTTPS, the root of trust comes from a certificate authority
    (CA) that stores its private key in an HSM, and the TLS connection is possibly
    terminated by an HSM. Do you have an Android or iPhone? Chances are that Google
    or Apple keep a backup of your phone safe with a fleet of HSMs. This last case
    is interesting because the threat model is reversed: the user does not trust the
    cloud with its data and, thus, the cloud service provider claims that its service
    can’t see the user’s encrypted backup nor can it access the keys used to encrypt
    it.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些行业高度利用 HSM。例如，每当你在 ATM 中输入你的 PIN 时，PIN 最终都会由某个地方的 HSM 进行验证。每当你通过 HTTPS 连接到网站时，信任的根源来自存储其私钥在
    HSM 中的证书颁发机构（CA），而 TLS 连接可能是由 HSM 终止的。你有安卓手机或 iPhone 吗？谷歌或苹果很有可能使用一批 HSM 来安全地备份你的手机。最后一种情况很有趣，因为威胁模型被颠倒了：用户不信任云端的数据，因此，云服务提供商声称其服务无法查看用户的加密备份，也无法访问用于加密的密钥。
- en: HSMs don’t really have a standard interface, but most of them will, at least,
    implement *Public Key Cryptography Standard 11* (PKCS#11), one of the old standards
    that were started by the RSA company and that were progressively moved to the
    OASIS organization in 2012 to facilitate adoption of the standards. While the
    last version of PKCS#11 (v2.40) was released in 2015, it is merely an update of
    a standard that originally started in 1994\. For this reason, it specifies a number
    of old cryptographic algorithms, or old ways of doing things, which can lead to
    vulnerabilities. Nevertheless, it is good enough for many uses and specifies an
    interface that allows different systems to easily interoperate with each other.
    The good news is that PKCS#11 v3.0 was released in 2020, including a lot of modern
    cryptographic algorithms like Curve25519, EdDSA, and SHAKE to name a few.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: HSM 实际上没有标准的接口，但其中大多数至少会实现*公钥密码标准 11*（PKCS＃11），这是由 RSA 公司发起的一个古老标准，2012 年逐渐转移到
    OASIS 组织，以促进标准的采用。虽然 PKCS＃11 的最新版本（v2.40）发布于 2015 年，但它只是一个标准的更新，最初始于 1994 年。因此，它规定了许多旧的加密算法或旧的操作方式，这可能会导致漏洞。尽管如此，对于许多用途来说它已经足够好，并且指定了一个允许不同系统轻松互操作的接口。好消息是，PKCS＃11
    v3.0 在 2020 年发布，包括许多现代加密算法，例如 Curve25519、EdDSA 和 SHAKE 等。
- en: While the real goal for HSMs is to make sure nobody can extract key material
    from them, their security is not always shining. A lot about the security of these
    hardware solutions really relies on their high price, the hardware defense techniques
    not being disclosed, and the certifications (like FIPS and Common Criteria) that
    mostly focus on the hardware side of things. In practice, devastating software
    bugs were found, and it is not always straightforward if the HSM you use is at
    risk to any of these vulnerabilities. In 2018, Jean-Baptiste Bédrune and Gabriel
    Campana showed in their research (“Everybody be Cool, This is a Robbery”) a software
    attack to extract keys out of popular HSMs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: HSM 的真正目标是确保没有人可以从中提取密钥材料，但它们的安全性并不总是闪耀的。关于这些硬件解决方案的安全性很大程度上依赖于它们的高价格、未公开的硬件防御技术以及主要关注硬件方面的认证（如
    FIPS 和 Common Criteria）。实际上，已经发现了严重的软件漏洞，而且你使用的 HSM 是否受到这些漏洞的威胁并不总是一目了然。2018 年，Jean-Baptiste
    Bédrune 和 Gabriel Campana 在他们的研究中展示了一种软件攻击方法（“Everybody be Cool, This is a Robbery”），可以从流行的
    HSM 中提取密钥。
- en: Note Not only is the price of one HSM high (it can easily be tens of thousands
    of dollars depending on the security level), but in addition to one HSM, you often
    have at least another HSM you use for testing and at least one more for backup
    (in case your first HSM dies with its keys in it). It can add up!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一个 HSM 的价格不仅高（根据安全级别，它可能轻松达到数万美元），而且除了一个 HSM 外，您通常至少还有另一个用于测试的 HSM，以及至少还有一个用于备份（以防您的第一个
    HSM 因密钥而损坏）。这可能会加起来！
- en: 'Furthermore, I still haven’t touched on the “elephant in the room” with all
    of these solutions: while you might prevent most attackers from reaching your
    secret keys, you can’t prevent attackers from compromising the system and making
    their own calls to the HSM (unless the HSM has logic that requires several signatures
    or the presence of a threshold of smart cards to operate). But, in most cases,
    the only service that an HSM provides is to prevent an attacker from stealthily
    stealing secrets and using those at some other time. When integrating hardware
    solutions like HSMs, it is good to first understand your threat model, the types
    of attacks you’re looking to thwart, and if threshold schemes like the multi-signatures
    I mentioned in chapter 8 aren’t a better solution.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还没有涉及所有这些解决方案中的“大象在房间里”：虽然你可能会阻止大多数攻击者获取你的秘密密钥，但你无法阻止攻击者破坏系统并对 HSM 进行自己的调用（除非
    HSM 具有需要多个签名或存在阈值智能卡的逻辑才能运行）。但是，在大多数情况下，HSM 提供的唯一服务是防止攻击者偷偷窃取秘密并在其他时间使用它们。在集成像
    HSM 这样的硬件解决方案时，首先了解您的威胁模型、您要防范的攻击类型以及我在第 8 章中提到的多签名等阈值方案是否更好。
- en: '13.2.4 Trusted Platform Modules (TPMs): A useful standardization of secure
    elements'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.4 可信平台模块（TPM）：安全元素的有用标准化
- en: While secure elements and HSMs prove to be useful, they are limited to specific
    use cases, and the process to write custom applications is known to be tedious.
    For this reason, the *Trusted Computing Group* (TCG) (another nonprofit organization
    formed by industry players) came up with a ready-to-use alternative that targets
    personal as well as enterprise computers. This is known as the *Trusted Platform
    Module* (TPM).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管安全元件和 HSM（硬件安全模块）被证明是有用的，但它们仅限于特定用例，并且编写自定义应用程序的过程被认为是乏味的。 出于这个原因，*可信计算组*（TCG）（由行业参与者组成的另一个非营利组织）提出了一个可用的替代方案，旨在面向个人和企业计算机。
    这就是*可信平台模块*（TPM）。
- en: The TPM is not a chip but, instead, a standard (the TPM 2.0 standard); any vendor
    who so chooses can implement it. A TPM complying with the TPM 2.0 standard is
    a secure microcontroller that carries a hardware random number generator, secure
    memory for storing secrets, can perform cryptographic operations, and the whole
    thing is tamper-resistant. This description might sound familiar, and indeed,
    it is common to see TPMs implemented as a repackaging of secure elements. You
    usually find a TPM directly soldered or plugged into the motherboard of enterprise
    servers, laptops, and desktop computers (see figure 13.3).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TPM 不是芯片，而是一个标准（TPM 2.0 标准）；任何选择都可以实现它的供应商。 符合 TPM 2.0 标准的 TPM 是一个安全微控制器，具有硬件随机数生成器、用于存储机密的安全存储器，可以执行加密操作，整个系统是防篡改的。
    这个描述可能听起来很熟悉，确实，常见的 TPM 实现方式是作为安全元件的重新打包。 通常情况下，您会在企业服务器、笔记本电脑和台式电脑的主板上直接焊接或插入一个
    TPM（见图 13.3）。
- en: '![](../Images/13_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_03.jpg)'
- en: Figure 13.3 A chip implementing the TPM 2.0 standard, plugged into a motherboard.
    This chip can be called by the system’s motherboard components as well as user
    applications running on the computer’s OS. Photo from Wikipedia ([http://mng.bz/Q2je](http://mng.bz/Q2je)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 实现 TPM 2.0 标准的芯片，插入主板。 该芯片可以被系统的主板组件以及运行在计算机操作系统上的用户应用程序调用。 来自维基百科的照片（[http://mng.bz/Q2je](http://mng.bz/Q2je)）。
- en: Unlike smart cards and secure elements, a TPM does not run arbitrary code. Instead,
    it offers a well-defined interface that a greater system can take advantage of.
    TPMs are usually pretty cheap, and today many commodity laptops carry one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与智能卡和安全元件不同，TPM 不运行任意代码。 相反，它提供了一个明确定义的接口，一个更大的系统可以利用它。 TPM 通常相当便宜，今天许多普通笔记本电脑都携带一个。
- en: 'Now the bad: the communication channel between a TPM and a processor is usually
    just a bus interface, which can easily be intercepted if you manage to steal or
    gain temporary physical access to the device. While many TPMs provide a high level
    of resistance against physical attacks, the fact that their communication channel
    is somewhat open does reduce their use cases to mostly defending against software
    attacks.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看坏消息：TPM 和处理器之间的通信渠道通常只是一个总线接口，如果您设法窃取或获得临时物理访问权限，这个通道很容易被截取。 尽管许多 TPM
    提供了高度抵抗物理攻击的水平，但它们的通信渠道有些开放的事实确实将它们的用例大部分限制在防御软件攻击上。
- en: To solve these issues, there’s been a move to TPM-like chips that are integrated
    directly into the main processor. For example, Apple has the Secure Enclave and
    Microsoft has Pluton. Unfortunately, none of these security processors seem to
    follow a standard, which means it could be difficult, perhaps impossible, for
    user applications to leverage their functionalities. Let’s see some examples to
    get an idea of what hardware security chips like TPMs can do.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，已经出现了将类似 TPM 的芯片直接集成到主处理器中的趋势。 例如，苹果有安全信封，微软有 Pluton。 不幸的是，这些安全处理器似乎没有遵循标准，这意味着用户应用程序可能很难，甚至不可能利用它们的功能。
    让我们看一些例子，了解像 TPM 这样的硬件安全芯片可以做些什么。
- en: 'The simplest use case for TPMs is to protect data. To protect keys, it’s easy:
    just generate them in the secure chip and disallow extraction. If you need the
    keys, ask the chip to perform the cryptographic operations. To protect data, encrypt
    it. That concept is called *file-based encryption* (FBE) if you’re encrypting
    individual files and *full-disk encryption* (FDE) if it’s the whole disk. FDE
    sounds much better as it’s an all or nothing approach. That’s what most laptops
    and desktops use. In practice, FDE is not that great though: it doesn’t take into
    account how we, human beings, use our devices. We often leave our devices locked,
    as opposed to turned off, so that background functionalities can keep running.
    Computers deal with this by keeping the data-encryption key (DEK) around, even
    if your computer is locked. (Think about that the next time you go to the restroom
    at Starbucks, leaving your locked computer unattended.) Modern phones offer more
    security, encrypting different types of files depending on whether your phone
    is locked or turned off.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: TPM的最简单的用例是保护数据。要保护密钥很简单：只需在安全芯片中生成它们，并禁止提取。如果您需要密钥，请要求芯片执行加密操作。要保护数据，就对其进行加密。如果你加密单个文件，那概念就叫做*基于文件的加密*（FBE）；如果是整个磁盘，那就叫做*全盘加密*（FDE）。FDE听起来要好得多，因为它是一种全盘加密的方法。这是大多数笔记本电脑和台式机使用的方式。但实际上，FDE并不那么好：它没有考虑到我们人类如何使用我们的设备。我们经常将设备锁定，而不是关闭，以便后台功能可以继续运行。计算机通过保留数据加密密钥（DEK）来处理这一点，即使您的计算机已锁定也是如此。
    （下次你在星巴克上厕所时，留下你锁定的电脑不受监管时，请考虑一下这一点。）现代手机提供了更多的安全性，根据手机是锁定还是关闭，对不同类型的文件进行加密。
- en: 'Note In practice, both FDE and FBE have many implementation issues. In 2019,
    Meijer and Gastel (in “Self-encrypting deception: Weaknesses in the encryption
    of solid state drives (SSDs)”) showed that several SSD vendors had completely
    insecure solutions. In 2021, Zinkus et al., (in “Data Security on Mobile Devices:
    Current State of the Art, Open Problems, and Proposed Solutions”) found that phone
    disk encryption also had many issues.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，FDE和FBE都有许多实施问题。2019年，Meijer和Gastel（在“自我加密的欺骗：固态硬盘（SSD）加密中的弱点”中）表明，几个SSD供应商完全没有安全的解决方案。2021年，Zinkus等人（在“移动设备上的数据安全：现状、存在的问题和提出的解决方案”中）发现手机磁盘加密也存在许多问题。
- en: Of course, the user should be authenticated before data can be decrypted. This
    is often done by asking the user for a PIN or password. A PIN or password is not
    enough though, as it would allow simple brute force attacks (especially on 4-
    or 6-digit PINs). In general, solutions try to tie the DEK to both a user credential
    and a symmetric key kept on the enclave.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在解密数据之前，用户应该经过身份验证。通常通过要求用户输入PIN码或密码来实现。但是仅仅使用PIN码或密码是不够的，因为这会导致简单的暴力攻击（尤其是对于4位或6位PIN码）。一般来说，解决方案尝试将DEK与用户凭据和保留在围栏上的对称密钥绑定起来。
- en: 'But a chip manufacturer can’t hardcode the same key in every device they produce;
    it leads to attacks like the DUHK attack ([https://duhkattack.com](https://duhkattack.com)),
    where thousands of devices were found hardcoding the same secret. This, in turn,
    means that the compromise of one device leads to the compromise of all the devices!
    The solution is a per-device key that is either fused into the chip at manufacturing
    time or created by the chip itself via hardware components called *physical unclonable
    functions*. For example, each Apple Secure Enclave has a UID, each TPM has a unique
    endorsement key and attestation key, etc. To prevent brute force attacks, Apple’s
    Secure Enclave mixes both the UID key and the user PIN with a password-based key
    derivation function (we covered this in chapter 2) to derive the DEK. Except that
    I lied: to allow users to change their PIN quickly, the DEK is not derived directly,
    but instead encrypted by a key encryption key (KEK).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是芯片制造商不能在他们生产的每个设备中硬编码相同的密钥；这会导致像DUHK攻击（[https://duhkattack.com](https://duhkattack.com)）这样的攻击，其中发现数千个设备都硬编码了相同的秘密。这反过来意味着一个设备的妥协会导致所有设备的妥协！解决方案是每个设备都有一个设备密钥，该密钥可以在制造时被熔入芯片中，或者由芯片自己通过称为*物理不可克隆函数*的硬件组件创建。例如，每个苹果安全围栏都有一个UID，每个TPM都有一个唯一的认证密钥和证书密钥，等等。为了防止暴力攻击，苹果的安全围栏将UID密钥和用户PIN与基于密码的密钥导出函数混合（我们在第2章中介绍了这一点）以导出DEK。除了我撒了个谎：为了允许用户快速更改他们的PIN，DEK并不直接派生，而是由一个密钥加密密钥（KEK）加密。
- en: Another example is *secure boot*. When booting your computer, there are different
    stages that run until you finally get to the screen you want. One problem users
    face are viruses and malwares, and how if they infect the boot process, you then
    run on an evil OS.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是*安全启动*。当启动计算机时，会经过不同的阶段，直到最终进入想要的屏幕。用户面临的一个问题是病毒和恶意软件，如果它们感染了启动过程，那么你就会运行在一个邪恶的操作系统上。
- en: 'To protect the integrity of boot, TPMs and integrated secure chips provide
    a root of trust, something that we trust 100% and that allows us to trust other
    stuff down the line. This root of trust is generally some read-only memory (ROM)
    that cannot be overwritten (also called *one-time programmable memory* as it’s
    written during manufacturing and can’t be changed). For example, when powering
    up a recent Apple device, the first code that gets executed is the boot ROM, located
    inside the Apple’s Secure Enclave ROM. That boot ROM is tiny, so usually the only
    thing it does is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护引导的完整性，TPM和集成的安全芯片提供了一个信任根，这是我们百分之百信任的东西，它使我们能够信任后续的其他东西。这个信任根通常是一些只读存储器（ROM），无法被覆盖（也称为*一次可编程存储器*，因为它在制造过程中被写入，不能更改）。例如，当最近的苹果设备上电时，首先执行的代码是位于苹果安全区ROM内部的引导ROM。这个引导ROM非常小，所以通常它所做的唯一的事情就是：
- en: Prepare some protected memory and load the next program to run there (usually
    some other boot loader)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一些受保护的内存，并加载下一个要运行的程序（通常是另一个引导加载程序）
- en: Hash the program and verify its signature against the hardcoded public key in
    the ROM
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对程序进行哈希处理，并针对ROM中的硬编码公钥验证其签名
- en: Execute the program
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序
- en: The next boot loader does the same thing, and so on, until finally a boot loader
    starts the OS. This is, by the way, how OS updates that are not signed by Apple
    can’t be installed on your phone.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引导加载程序也会执行相同的操作，依此类推，直到最终一个引导加载程序启动操作系统。顺便说一句，这就是为什么没有经过苹果签名的操作系统更新无法安装到您的手机上的原因。
- en: TPMs and integrated TPM-like chips are an interesting development, and they
    greatly increased the security of our devices in recent years. As they become
    cheaper and a winning standard arises, more devices will be able to benefit from
    them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: TPM和集成了类似TPM的芯片是一个有趣的发展，它们在最近几年极大地增加了我们设备的安全性。随着它们变得更便宜，以及一个胜出的标准出现，越来越多的设备将能够从中受益。
- en: 13.2.5 Confidential computing with a trusted execution environment (TEE)
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.5 受信执行环境（TEE）的机密计算
- en: Smart cards, secure elements, HSMs, and TPMs are standalone chips or modules;
    they carry their own CPU, memory, TRNG, and so on, and other components can talk
    to them via some wires or radio frequency in NFC-enabled chips. TPM-like chips
    (Microsoft’s Pluton and Apple’s Secure Enclave) are standalone chips as well,
    although tightly coupled with the main processor inside of a system on chip (SoC).
    In this section, I will talk about the next logical step you can take in this
    taxonomy of security hardware, *integrated security*, hardware-enforced security
    within the main processor itself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡、安全元件、HSM和TPM是独立的芯片或模块；它们带有自己的CPU、内存、TRNG等，其他组件可以通过一些导线或NFC启用芯片中的无线电频率与它们通信。类似TPM的芯片（微软的Pluton和苹果的安全区）也是独立的芯片，尽管与系统片上的主处理器紧密耦合。在本节中，我将讨论在这种安全硬件分类法中您可以采取的下一个逻辑步骤，*集成安全*，硬件强制执行安全性在主处理器内部。
- en: Processors that integrate security are said to create a *trusted execution environment*
    (TEE) for user code by extending the instruction set of a processor to allow for
    programs to run in a separate, secure environment. The separation between this
    secure environment and the ones we are used to dealing with already (often called
    a *rich execution environment*) is done via hardware. What ends up happening is
    that modern CPUs run both a normal OS as well as a secure OS simultaneously. Both
    have their own set of registers but share most of the rest of the CPU architecture.
    By using CPU-enforced logic, data from the secure world cannot be accessed from
    the normal world. For example, a CPU usually splits its memory, giving one part
    for the exclusive use of the TEE. Because a TEE is implemented directly on the
    main processor, not only does this mean a TEE is a faster and cheaper product
    than a TPM or secure element, it also comes for free in a lot of modern CPUs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 集成安全功能的处理器被称为为用户代码创建了一个*受信任执行环境*（TEE），通过扩展处理器的指令集，允许程序在一个单独的安全环境中运行。这个安全环境与我们通常处理的环境（通常称为*富执行环境*）之间的分离是通过硬件实现的。最终发生的是，现代
    CPU 同时运行正常的操作系统和安全操作系统。两者都有自己的寄存器集，但大部分 CPU 结构是共享的。通过使用 CPU 强制逻辑，来自安全世界的数据无法从正常世界访问。例如，CPU
    通常会分割其内存，将一部分专门用于 TEE 的专用。因为 TEE 直接在主处理器上实现，这不仅意味着 TEE 比 TPM 或安全元件更快、更便宜，而且在许多现代
    CPU 中都是免费的。
- en: The TEE, like all other hardware solutions, is a concept developed independently
    by different vendors and a standard (by Global Platform) trying to play catch-up.
    The most known TEEs are Intel’s Software Guard Extensions (SGX) and ARM’s TrustZone.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他硬件解决方案一样，TEE 是由不同供应商独立开发的概念，标准（由全球平台）试图追赶发展。最知名的 TEE 是英特尔的软件保护扩展（SGX）和
    ARM 的 TrustZone。
- en: 'What are TEEs good for? Let’s look at an example. For the last few years, there’s
    a new paradigm—the cloud—with big companies running servers to host your data.
    Amazon has AWS, Google has GCP, and Microsoft has Azure. Another way to put this
    is that people are moving from running things themselves to running things on
    someone else’s computer. This creates some issues in some scenarios where privacy
    is important. To fix that, *confidential computing* attempts to offer solutions
    to run client code without being able to see it or modify its behavior. SGX’s
    primary use case seems to be exactly that these days: clients running code that
    servers can’t see or tamper with.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: TEE 有什么用？让我们举个例子。在过去的几年里，有了一个新的范式——云计算——大公司运行服务器来托管您的数据。亚马逊有 AWS，谷歌有 GCP，微软有
    Azure。换句话说，人们正在从自己运行事物转向在别人的计算机上运行事物。在一些需要保护隐私的场景中，这会带来一些问题。为了解决这个问题，*机密计算*试图提供解决方案，以便运行客户端代码而无法查看或修改其行为。SGX
    的主要用例似乎正是这些天的客户端运行代码，而服务器不能查看或篡改。
- en: 'One interesting problem that arises is how can one trust that the response
    from a request came from SGX, for example, and not from some impersonator. This
    is what *attestation* tries to solve. There are two kinds of attestation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的问题是，如何确信响应来自 SGX，例如，而不是来自某个冒充者。这就是 *认证*试图解决的问题。认证有两种类型：
- en: '*Local attestation*—Two enclaves running on the same platform need to communicate
    and prove to each other that they are secure enclaves.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本地认证*——在同一平台上运行的两个隔离区需要进行通信并向对方证明它们是安全的隔离区。'
- en: '*Remote attestation*—A client queries a remote enclave and needs to make sure
    that it is the legitimate enclave that produced the result from the request.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*远程认证*——客户端查询远程隔离区，并需要确保它是生成请求结果的合法隔离区。'
- en: Each SGX chip is provided with unique key pairs (the *Root Sealing Keys*) at
    manufacturing time. The public key part is then signed by some Intel CA. The first
    assumption, if we ignore the assumption that the hardware is secure, is that Intel
    is correctly signing public keys for secure SGX chips only. With that in mind,
    you can now obtain a signed attestation from Intel’s CA that you’re talking to
    a real SGX enclave and that it is running some specific code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 SGX 芯片在制造时都提供了唯一的密钥对（*根密封密钥*）。公钥部分然后由一些英特尔 CA 签名。首先假设，如果忽略硬件安全的假设，那么就是 Intel
    正确地为安全 SGX 芯片签署公钥。有了这个前提，现在您可以从 Intel 的 CA 获取签名的认证，证明您正在与真实的 SGX 隔离区通信，并且它正在运行某些特定的代码。
- en: TEE’s goal is to first and foremost thwart *software attacks*. While the claimed
    software security seems to be attractive, it is, in practice, hard to segregate
    execution on the same chip due to the extreme complexity of modern CPUs and their
    dynamic states. This is attested to by the many software attacks against SGX and
    TrustZone ([https://foreshadowattack.eu](https://foreshadowattack.eu), [https://mdsattacks.com](https://mdsattacks.com),
    [https://plundervolt.com](https://plundervolt.com), and [https://sgaxe.com](https://sgaxe.com)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TEE的首要目标是防止*软件攻击*。虽然声称的软件安全看起来很吸引人，但实际上，由于现代CPU的极端复杂性和动态状态，难以在同一芯片上分隔执行。这可以通过针对SGX和TrustZone的许多软件攻击来证明（[https://foreshadowattack.eu](https://foreshadowattack.eu)，[https://mdsattacks.com](https://mdsattacks.com)，[https://plundervolt.com](https://plundervolt.com)和[https://sgaxe.com](https://sgaxe.com)）。
- en: TEE as a concept provides some resistance against physical attacks because things
    at this microscopic level are way too tiny and tightly packaged together to analyze
    without expensive equipment. Against a motivated attacker, things might be different.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概念的TEE提供了一定程度的抵抗物理攻击，因为在这个微观层面上的东西太小、太紧密地包装在一起，以至于没有昂贵的设备无法分析。对于一个积极进取的攻击者，情况可能会不同。
- en: 13.3 What solution is good for me?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 什么解决方案适合我？
- en: 'You have learned about many hardware products in this chapter. As a recap,
    here’s the list, which I illustrate in figure 13.4 as well:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了许多硬件产品。作为总结，这里是列表，我也在图13.4中加以说明：
- en: '*Smart cards are microcomputers that need to be turned on by an external device
    like a payment terminal.* They can run small custom Java-like applications. Bank
    cards are an example of a widely used smart card.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*智能卡是需要外部设备（如支付终端）打开的微型计算机。* 它们可以运行小型自定义类似Java的应用程序。银行卡就是广泛使用的智能卡的一个例子。'
- en: '*Secure elements are a generalization of smart cards, which rely on a set of
    Global Platform standards.* SIM Cards are an example of secure elements.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全元件是智能卡的一种泛化，依赖于一组全球平台标准。* SIM卡是安全元件的一个例子。'
- en: '*HSMs (hardware security modules) can be seen as larger pluggable secure elements
    for enterprise servers.* They are faster and more flexible and are seen mostly
    in data centers to store secret keys, making attacks on keys more obvious.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HSMs（硬件安全模块）可以看作是企业服务器的较大的可插拔安全元件。* 它们更快、更灵活，主要用于数据中心存储秘密密钥，使密钥攻击更加明显。'
- en: '*TPMs (Trusted Platform Modules) are repackaged secure elements plugged into
    personal and enterprise computer motherboards.* They follow a standardized API
    by the Trusted Computing Group that can provide functionalities for operating
    systems and end users.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TPM（可信平台模块）是插入个人和企业计算机主板的重新打包的安全元件。* 它们遵循由可信计算组织制定的标准API，可以为操作系统和最终用户提供功能。'
- en: '*Security processors are TPM-like chips built extremely close to the main processor
    and are not programmable.* They follow no standards, and different players have
    come out with different technologies.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全处理器是建立在主处理器极为接近的TPM样式芯片，不可编程。* 它们不遵循任何标准，不同的参与者推出了不同的技术。'
- en: '*TEEs (trusted execution environments) like TrustZone and SGX can be thought
    of as programmable secure elements implemented within the CPU instruction set.*
    They are faster and cheaper, mostly providing resistance against software attacks.
    Most modern CPUs ship with TEEs and various levels of defense against hardware
    attacks.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信任执行环境（TEEs，如TrustZone和SGX）可以被视为实现在CPU指令集内的可编程安全元件。* 它们更快、更便宜，主要提供对软件攻击的抵抗。大多数现代CPU都配备了TEE，并提供各种级别的硬件攻击防御。'
- en: '![](../Images/13_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_04.jpg)'
- en: Figure 13.4 The different hardware solutions you learned in this chapter and
    an idea of what they look like.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 你在本章学到的不同硬件解决方案以及它们的外观概念。
- en: 'What is the best solution for you? Try to narrow your choice by asking yourself
    some questions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是最适合你的解决方案？通过自问一些问题来缩小你的选择范围：
- en: '*In what form factor?* For example, the need for a secure element in a small
    device dictates what solutions you won’t be able to use.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*采用何种形态？* 例如，在小型设备中需要安全元件的需求决定了你不能使用哪些解决方案。'
- en: '*How much speed do you need?* Applications that need to perform a high number
    of cryptographic operations per second will be highly constrained in the solutions
    they can use, probably limited to HSMs and TEEs.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你需要多快的速度？* 需要每秒执行大量加密操作的应用程序将在可以使用的解决方案上受到严格的限制，可能仅限于HSM和TEE。'
- en: '*How much security do you need?* Certifications and claims by vendors correspond
    to different levels of software or hardware security. The sky’s the limit.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你需要多少安全性？* 供应商的认证和声明对应于不同级别的软件或硬件安全性。天空是极限。'
- en: Keep in mind that no hardware solution is the panacea; you’re only increasing
    the attack’s cost. Against a sophisticated attacker all of this is pretty much
    useless. Design your system so that one compromised device doesn’t imply that
    all devices are compromised.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，没有硬件解决方案是万灵药；你只是增加了攻击的成本。对于一个复杂的攻击者来说，所有这些都几乎没有用。设计你的系统，以便一个被 compromized
    的设备不意味着所有的设备都被 compromized。
- en: 13.4 Leakage-resilient cryptography or how to mitigate side-channel attacks
    in software
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 泄漏弹性密码学或如何在软件中减轻侧信道攻击
- en: We saw how hardware attempts to prevent direct observation and extraction of
    secret keys, but there’s only so much that hardware can do. At the end of the
    day, it is possible for the software to not care and give out the key despite
    all of this hardware hardening. The software can do so somewhat directly (like
    a backdoor) or it can do it indirectly by leaking enough information for someone
    to reconstruct the key. This latter option is called a *side channel*, and side-channel
    vulnerabilities are unintentional bugs most of the time (at least one would hope).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到硬件试图防止直接观察和提取秘密密钥，但硬件能做的事情有限。归根结底，软件可能会不在乎并且尽管所有这些硬件加固，仍然提供密钥。软件可以直接这样做
    (像后门) ，或者它可以间接地泄漏足够的信息，让某人重构密钥。后者被称为 *侧信道*，侧信道漏洞大多数情况下是不经意的漏洞 (至少人们希望如此)。
- en: I mentioned timing attacks in chapter 3, where you learned that MAC authentication
    tags had to be compared in constant time; otherwise, attackers could infer the
    correct tag after sending you many incorrect ones and measuring how long they
    waited for you to respond. Timing attacks are usually taken seriously in all areas
    of real-world cryptography as they can potentially be remotely performed over
    the network, unlike physical side channels.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第三章提到了定时攻击，你在那里学到了 MAC 认证标签必须在恒定的时间内进行比较；否则，攻击者可以在发送了许多不正确的标签并测量等待你回复的时间后，推断出正确的标签。定时攻击在现实世界中的所有领域通常都受到严肃对待，因为它们可以在网络上潜在地远程执行，而不像物理侧信道那样。
- en: The most important and known side channel is *power consumption*, which I mentioned
    earlier in this chapter. This was discovered as an attack, called *differential
    power analysis* (DPA), by Kocher, Jaffe, and Jun in 1998, when they realized that
    they could hook an oscilloscope to a device and observe variance in the electricity
    consumed by the device over time while performing encryptions of known plaintexts.
    This variance clearly depends on the bits of the key used, and the fact that operations
    like XORing would consume more or less power, depending if the operand bits were
    set or not. This observation led to a *key-extraction attack* (so-called *total
    breaks*).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的和已知的侧信道是 *电源消耗*，我在本章前面提到过。这被发现是一种攻击，称为 *差分电源分析* (DPA)，由 Kocher、Jaffe 和 Jun
    在 1998 年发现，当他们意识到他们可以将示波器连接到设备并观察设备随时间变化的电力消耗，同时执行已知明文的加密。这种变化显然取决于所使用的密钥位，以及像异或这样的操作是否会消耗更多或更少的电力，这取决于操作数位是否设置。这个观察结果导致了一种
    *密钥提取攻击* (所谓的 *完全破解*)。
- en: This concept can be illustrated with *simple power analysis* (SPA) attack. In
    ideal situations and when no hardware or software mitigations are implemented
    against power analysis attacks, it suffices to measure and analyze the power consumption
    of a single cryptographic operation involving a secret key. I illustrate this
    in figure 13.5.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以用 *简单的功耗分析* (SPA) 攻击来说明。在理想的情况下，并且没有硬件或软件对抗功耗分析攻击的实施，只需测量和分析涉及秘密密钥的单个加密操作的功耗消耗即可。我在图
    13.5 中说明了这一点。
- en: '![](../Images/13_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_05.jpg)'
- en: Figure 13.5 Some cryptographic algorithms leak so much information via their
    power consumption that a simple power analysis of a single power trace (a measure
    of the power consumed in time) can leak the private key of the algorithm. For
    example, this figure represents a trace of an RSA exponentiation (the message
    being exponentiated to the private exponent; see chapter 6). The RSA exponentiation
    is implemented with a square-and-multiply algorithm that iterates through the
    bits of the private exponent; for each bit it applies a square operation followed
    by a multiply operation only if the bit is set. In this example, multiplication
    is obviously consuming more power; hence, the clarity of the power trace.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 一些加密算法通过其功耗泄露了大量信息，以至于对单个功耗跟踪（一段时间内的功耗测量）进行简单的功耗分析就可以泄漏算法的私钥。例如，本图表示了
    RSA 指数运算的跟踪（消息被指数化为私钥指数；见第 6 章）。RSA 指数运算采用了一个通过私钥指数的位来迭代的平方乘算法；对于每一位，它只在该位被设置时应用一个平方运算，然后是一个乘法运算。在这个例子中，乘法显然消耗了更多的功耗；因此，功耗跟踪的清晰度。
- en: Power is not the only physical side channel. Some attacks rely on electromagnetic
    radiations, vibrations, and even the sound emitted by the hardware. Let me still
    mention two other nonphysical side-channels. I know we are in a hardware-focused
    chapter, but these nonphysical side-channel attacks are important as they need
    to be mitigated in many real-world cryptographic applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 电源并不是唯一的物理侧信道。一些攻击依赖于电磁辐射、振动，甚至是硬件发出的声音。让我再提到另外两种非物理侧信道。我知道我们处于一个硬件为主的章节，但这些非物理侧信道攻击同样重要，因为它们需要在许多现实世界的加密应用中得到缓解。
- en: First, returned errors can sometimes leak critical information. For example,
    in 2018, the ROBOT attack figured out a way to exploit the Bleichenbacher attack
    (mentioned in chapter 6) on a number of servers that implemented RSA PKCS#1 v1.5
    decryption in the TLS protocol (covered in chapter 9). Bleichenbacher’s attack
    only works if you can distinguish if an RSA ciphertext has a valid padding or
    not. To protect against that attack, safe implementations perform the padding
    validation in constant time and avoid returning early if they detects that the
    padding is invalid. For example, in an RSA key exchange in TLS, the server has
    to fake its response as if it completed a successful handshake if the padding
    of the RSA payload is incorrect. Yet, if at the end of the padding validation
    an implementation decides to return a different error to the client (based on
    the validity of the padding), then this was all for nothing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，返回的错误有时可能泄漏关键信息。例如，在 2018 年，ROBOT 攻击找到了一种利用 Bleichenbacher 攻击（在第 6 章提到）的方法，攻击了许多实现
    RSA PKCS#1 v1.5 解密的服务器，在 TLS 协议中（在第 9 章中有所涉及）。Bleichenbacher 的攻击只在你可以区分 RSA 密文是否具有有效填充时才有效。为了防止该攻击，安全实现在常量时间内执行填充验证，并且在检测到填充无效时避免提前返回。例如，在
    TLS 中的 RSA 密钥交换中，如果 RSA 载荷的填充不正确，服务器必须伪造其响应，使其看起来像是已经完成了成功的握手。然而，如果在填充验证的最后，实现决定根据填充的有效性向客户端返回不同的错误，那么这一切都是徒劳的。
- en: Second, accessing memory can take more or less time, depending if the data was
    previously accessed or not. This is due to the numerous layers of caching that
    exist in a computer. For example if the CPU needs something, it first checks if
    it has been cached in its internal memory. If not, it then reaches into caches
    that are further and further away from it. The further away the cache, the more
    time it’ll take. Not only that, but some caches are specific to a core (L1 cache,
    for example), while some caches are shared among cores in a multicore machine
    (L3 cache, RAM, disk).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，访问内存可能需要更多或更少的时间，这取决于数据是否之前已被访问过。这是由于计算机中存在着众多层次的缓存。例如，如果 CPU 需要某些东西，它首先会检查它是否已经被缓存在其内部存储器中。如果没有，它就会到更远的缓存中去寻找。缓存越远，花费的时间就越长。不仅如此，一些缓存是特定于核心的（例如
    L1 缓存），而一些缓存是在多核机器中共享的（例如 L3 缓存、RAM、磁盘）。
- en: '*Cache attacks* exploit the fact that it is possible for a malicious program
    to run on the same machine, using the same cryptographic library as a sensitive
    cryptographic program. For example, many cloud services host different virtual
    servers on the same machine, and many servers use the OpenSSL library for cryptographic
    operations or for serving TLS pages. Malicious programs find ways to evict parts
    of the library that have been loaded in a cache shared with the victim’s process
    and then periodically measure the time it takes to reread some parts of that library.
    If it takes a long time, then the victim did not execute this part of the program;
    if it doesn’t take a long time, then the victim accessed this part of the program
    and repopulated the cache to avoid having to fetch again the program to a far
    away cache or worse from disk. What you obtain is a trace that resembles a power
    trace, and it is indeed exploitable in similar ways!'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓存攻击*利用了一个事实：恶意程序有可能在同一台计算机上运行，使用与敏感密码程序相同的密码库。例如，许多云服务在同一台计算机上托管不同的虚拟服务器，许多服务器使用
    OpenSSL 库进行密码操作或提供 TLS 页面。恶意程序找到方法将已加载到与受害者进程共享的缓存中的库的部分逐出，然后定期测量重新读取该库的某些部分所需的时间。如果花费了很长时间，那么受害者没有执行该程序的这部分；如果不花费很长时间，则受害者访问了该程序的这部分并重新填充了缓存，以避免再次将程序从远处的缓存中获取或者更糟的是从磁盘获取。您获得的是类似于功率跟踪的跟踪，而且确实可以以类似的方式进行利用！'
- en: OK, that’s enough for side-channel attacks. If you’re interested in attacking
    cryptography via these side channels, there are better resources than this book.
    In this section, I want to only talk about software mitigations that cryptographic
    implementations can and should implement to protect against side-channel attacks
    in general. This whole field of study is called *leakage-resilient cryptography*,
    as the cryptographer’s goal here is to not leak anything.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，侧信道攻击就说到这里。如果您对通过这些侧信道攻击攻击密码学感兴趣，那么有比本书更好的资源。在本节中，我只想讨论密码实现可以和应该实施的软件缓解措施，以保护免受侧信道攻击的影响。这个研究领域整体被称为*泄漏韧性密码学*，因为密码学家在这里的目标是不泄漏任何信息。
- en: Defending against physical attackers is an endless battle, which explains why
    many of these mitigations are proprietary and akin to obfuscation. This section
    is obviously not exhaustive but should give you an idea of the type of things
    applied cryptographers are working on to address side-channel attacks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 防御物理攻击者是一场永无止境的战斗，这解释了为什么许多这些缓解措施是专有的且类似于混淆。这一部分显然不是详尽无遗的，但应该让您了解应用密码学家正在致力于解决侧信道攻击的类型。
- en: 13.4.1 Constant-time programming
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量时间编程
- en: The first line of defense for any cryptographic implementation is to implement
    its cryptographic sensitive parts (think any computation that involves a secret)
    in constant time. It is obvious that implementing something in constant time cancels
    timing attacks, but this also gets rid of many classes of attacks like cache attacks
    and simple power analysis attacks.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 任何密码学实现的第一道防线是在常量时间内实现其密码学敏感部分（考虑任何涉及秘密的计算）。显而易见，以常量时间实现某事会取消时间攻击，但这也会摆脱许多攻击类别，如缓存攻击和简单的电源分析攻击。
- en: How do you implement something in constant time? Never *branch*. In other words,
    no matter what the input is, always do the same thing. For example, listing 13.1
    shows how the Golang language implements a constant-time comparison of authentication
    tags for the HMAC algorithm. Intuitively, if two bytes are equal, then their XOR
    will be 0\. If this property is verified for every pair of bytes we compare, then
    ORing them will also lead to a 0 value (and a nonzero value otherwise). Note that
    it can be quite disconcerting to read this code if this is the first time you’re
    looking at constant-time tricks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如何以常量时间实现某事？永远不要*分支*。换句话说，无论输入是什么，始终执行相同的操作。例如，列表 13.1 显示了 Golang 语言如何实现 HMAC
    算法的认证标签的常量时间比较。直觉上，如果两个字节相等，那么它们的异或将是 0。如果我们比较的每一对字节都满足这个属性，那么对它们进行 OR 运算也将导致一个
    0 值（否则是一个非零值）。请注意，如果这是您第一次看到常量时间技巧，那么阅读这段代码可能会令人困惑。
- en: Listing 13.1 How Golang implements a constant-time comparison between two bytearrays
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[Golang 如何实现两个字节数组之间的常量时间比较](https://wiki.example.org/constant_time_comparison_in_golang)'
- en: '[PRE0]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ There is no point comparing two strings in constant time if they are of different
    lengths.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果两个字符串长度不同，那么在常量时间内比较它们就没有意义。
- en: ❷ Here is where the magic happens. The loop OR accumulates the XOR of every
    byte into a value v.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这就是魔法发生的地方。循环 OR 将每个字节的异或值累加到一个值 v 中。
- en: ❸ Returns 0 only if v is equal to 0 and returns a nonzero value otherwise
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当v等于0时仅返回0，否则返回非零值
- en: For a MAC authentication tag comparison, it is enough to stop here to check
    if the result is 0 or not by branching (using a conditional expression such as
    `if`). Another interesting example is *scalar multiplication* in elliptic curve
    cryptography, which, as you learned in chapter 5, consists of adding a point to
    itself *x* number of times, where *x* is what we call a scalar. This process can
    be somewhat slow, and thus clever algorithms exist to speed up this part. One
    of the popular ones is called Montgomery’s ladder and is pretty much the equivalent
    to the RSA’s square-and-multiply algorithm I mentioned earlier (but in a different
    group).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MAC身份验证标签比较，仅需要在此处停止通过分支（使用条件表达式，如`if`）来检查结果是否为0或非0。另一个有趣的例子是椭圆曲线密码中的*标量乘法*，正如你在第5章中学到的那样，它包括将一个点添加到自身*x*次数，其中*x*是我们称之为标量的值。这个过程可能有点慢，因此存在一些聪明的算法来加速这部分。其中一个流行的算法称为蒙哥马利阶梯，基本上等同于我之前提到的RSA的平方乘算法（但在不同的群中）。
- en: '*Montgomery ladder’s algorithm* alternates between the addition of two points
    and doubling of a point (adding the point to itself). Both the RSA’s square-and-multiply
    and Montgomery ladder’s algorithms have a simple way to mitigate timing attacks:
    they do not branch and always perform both operations. (And this is why the RSA
    exponentiation algorithm in constant time is usually referred to as *square and
    multiply always*.)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*蒙哥马利阶梯算法*在两点相加和一个点加倍之间交替进行（将点加到自身）。RSA的平方乘和蒙哥马利阶梯算法都有一种简单的方法来缓解时间攻击：它们不分支并且总是执行两个操作。
    （这就是为什么RSA指数算法通常称为*square and multiply always*的原因。）'
- en: Note In chapter 7, I mentioned that signature schemes can go wrong in multiple
    ways and that key recovery attacks exist against implementations that leak a few
    bytes of the nonces they use (in signature schemes like ECDSA). This is what happened
    in the Minerva and TPM-Fail attacks, which happened around the same time. Both
    attacks found that a number of devices were vulnerable due to the amount of timing
    variation the signing operation takes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 在第7章中，我提到签名方案可能以多种方式出错，并且针对泄漏它们使用的一些字节（在ECDSA等签名方案中）的非ces存在密钥恢复攻击。这就是Minerva和TPM-Fail攻击发生的情况，它们发生在同一时间。这两次攻击发现了许多设备由于签名操作所花费的时间变化量而易受攻击。
- en: In practice, mitigating timing attacks is not always straightforward as it is
    not always clear if CPU instructions for multiplications or conditional moves
    are in constant time. Additionally, it is not always clear how the compiler will
    compile high-level code when used with different compilation flags. For this reason,
    a manual review of the assembly generated is sometimes performed in order to obtain
    more confidence in the constant-time code written. Different tools to analyze
    constant-time code exist (like ducdect, ct-verif, SideTrail, and so on), but they
    are rarely used in practice.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，缓解时间攻击并不总是直截了当的，因为CPU指令是否用于乘法或条件移动并不总是在恒定的时间内。此外，当使用不同的编译标志时，高级代码如何被编译成机器代码并不总是清楚的。因此，有时会对生成的汇编进行手动审核，以便更加信任编写的恒定时间代码。存在用于分析恒定时间代码的不同工具（如ducdect、ct-verif、SideTrail等），但它们在实践中很少被使用。
- en: 13.4.2 Don’t use the secret! Masking and blinding
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 不要使用秘密！屏蔽和blinding
- en: Another common way of thwarting or at least confusing attackers is to add layers
    of indirection to any operation involving secrets. One of these techniques is
    called *blinding*, which is often possible thanks to the arithmetic structure
    of public key cryptography algorithms. You saw blinding used in oblivious algorithms
    like password-authenticated key exchange algorithms in chapter 11, and we can
    use blinding in the same way where we want the oblivious party to be the attacker
    observing leaks from our computations. Let’s talk about RSA as an example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的阻止或至少混淆攻击者的方法是在涉及秘密的任何操作中添加间接层。其中一种技术称为*blinding*，这通常得益于公钥密码算法的算术结构。你在第11章看到了类似于密码认证密钥交换算法的遗忘算法中使用了blinding，我们可以在我们想要让遗忘的一方成为攻击者观察我们计算中的泄漏的地方同样使用blinding。让我们以RSA为例。
- en: 'Remember, RSA decrypts by taking a ciphertext *c* and raising it to the private
    exponent *d*, where the private exponent *d* cancels the public exponent *e*,
    which was used to compute the ciphertext as *m*^e mod *N*. If you don’t remember
    the details, make sure to consult chapter 6\. One way to add indirection is to
    perform the decryption operation on a value that is not the ciphertext known to
    the attacker. This method is called *base blinding* and goes like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，RSA解密是通过将密文*c*提升到私有指数*d*来完成的，其中私有指数*d*取消了用于计算密文的公共指数*e*，该公共指数*e*被用于计算密文为*m*^e
    mod *N*。如果你不记得细节，请务必查阅第6章。增加间接性的一种方法是在攻击者所知的不是密文的值上执行解密操作。这种方法称为*基础掩码*，操作如下：
- en: Generate a random blinding factor *r*
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个随机的掩盲因子*r*。
- en: Compute *message* = (*ciphertext* × *r*^e)^d mod *N*
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算*message* = (*ciphertext* × *r*^e)^d mod *N*。
- en: Unblind the result by computing *real_message* = *message* × *r*^(–1) mod *N*,
    where *r*^(–1) is the inverse of *r*
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算*real_message* = *message* × *r*^(–1) mod *N*来解除掩码，其中*r*^(–1)是*r*的逆。
- en: 'This method blinds the value being used with the secret, but we can also blind
    the secret itself. For example, elliptic curve scalar multiplication is usually
    used with a secret scalar. But as computations take place in a cyclic group, adding
    a multiple of order to that secret does not change the computation result. This
    technique is called *scalar blinding* and goes like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对正在使用的值进行了掩盲，但我们也可以对秘密本身进行掩盲。例如，椭圆曲线标量乘法通常与秘密标量一起使用。但是由于计算发生在一个循环群中，将阶的倍数添加到该秘密中不会改变计算结果。这种技术称为*标量掩码*，操作如下：
- en: Generate a random value *k*[1]
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成随机值*k*[1]。
- en: Compute a scalar *k*[2] = *d* + *k*[1] × *order*, where *d* is the original
    secret scalar and *order* is its order
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算标量*k*[2] = *d* + *k*[1] × *order*，其中*d*是原始的秘密标量，*order*是它的阶数。
- en: To compute *Q* = *P*, instead compute *Q* = [*k*[2]] *P*, which results in the
    same point
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算*Q* = *P*，而不是计算*Q* = [*k*[2]] *P*，结果是相同的点。
- en: All of these techniques have been proven to be more or less efficient and are
    often used in combinations with other software and hardware mitigations. In symmetric
    cryptography, another somewhat similar technique, called *masking*, is used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都被证明多多少少是有效的，并且通常与其他软件和硬件缓解措施组合使用。在对称密码中，另一种有些类似的技术称为*掩码*。
- en: The concept of masking is to transform the input (the plaintext or ciphertext
    in the case of a cipher) before passing it to the algorithm. For example, by XORing
    the input with a random value. The output is then unmasked in order to obtain
    the final correct output. As any intermediate state is thus masked, this provides
    the cryptographic computation some amount of decorrelation from the input data
    and makes side-channel attacks much more difficult. The algorithm must be aware
    of this masking to correctly perform internal operations while keeping the correct
    behavior of the original algorithm.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码的概念是在将输入（在密码中为明文或密文）传递给算法之前对其进行转换。例如，通过将输入与随机值进行异或操作。然后解除掩码以获得最终正确的输出。由于任何中间状态都被掩码，因此这为密码计算提供了一定程度的与输入数据的去相关性，并使得侧信道攻击变得更加困难。算法必须意识到这种掩码，以便在保持原始算法的正确行为的同时正确执行内部操作。
- en: 13.4.3 What about fault attacks?
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 关于故障攻击的问题？
- en: I previously talked about *fault attacks*, a more intrusive type of side-channel
    attacks that modify the execution of the algorithm by inducing faults. Injecting
    faults can be done in many creative ways, physically, by increasing the heat of
    the system, for example, or even by shooting lasers at calculated points in the
    targeted chip.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前谈到了*故障攻击*，这是一种更具侵入性的侧信道攻击类型，它通过引入故障来修改算法的执行。注入故障可以通过许多创造性的方式来实现，例如通过物理方式，例如增加系统的热量，或者甚至通过向目标芯片的计算点发射激光。
- en: Surprisingly, faults can also be induced via software. An example was found
    independently in the Plundervolt and V0LTpwn attacks, which managed to change
    the voltage of a CPU to introduce natural faults. This also happened in the infamous
    rowhammer attack, which discovered that repeatedly accessing memory of some DRAM
    devices could flip nearby bits. These types of attacks can be difficult to achieve
    but are extremely powerful. In cryptography, computing a bad result can sometimes
    leak the key. This is, for example, the case with RSA signatures that are implemented
    with some specific optimizations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，故障也可以通过软件引起。例如，在Plundervolt和V0LTpwn攻击中独立发现了一个例子，它们成功地改变了CPU的电压以引入自然故障。这也发生在臭名昭著的rowhammer攻击中，该攻击发现了在一些DRAM设备上重复访问内存可以翻转附近的位。这些类型的攻击可能很难实现，但非常强大。在密码学中，计算出错误结果有时可能会泄漏密钥。这就是例如使用一些特定优化实现的RSA签名的情况。
- en: While it is impossible to fully mitigate these attacks, some techniques exist
    that can increase the complexity of a successful attack; for example, by computing
    the same operation several times and comparing the results to make sure they match
    before releasing it or by verifying the result before releasing it. For signatures,
    one can verify the signature via the public key before returning it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无法完全消除这些攻击，但存在一些技术可以增加成功攻击的复杂性；例如，多次计算相同的操作并在发布之前比较结果以确保它们匹配，或者在发布之前验证结果。对于签名，可以在返回之前通过公钥验证签名。
- en: Fault attacks can also have dramatic consequences against random number generators.
    One easy solution is to use algorithms that do not use new randomness every time
    they run. For example, in chapter 7, you learned about EdDSA, a signature algorithm
    that requires no new randomness to sign as opposed to the ECDSA signature algorithm.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 故障攻击也可能对随机数生成器产生严重后果。一个简单的解决方案是使用不在每次运行时使用新随机性的算法。例如，在第7章中，您了解到了EdDSA，这是一种签名算法，签名时不需要新的随机性，与ECDSA签名算法相比。
- en: All in all, none of these techniques are foolproof. Doing cryptography in highly
    adversarial environments is always about how much more cost you can afford to
    incur to the attackers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些技术都不是绝对可靠的。在高度敌对的环境中进行密码学始终是关于你能承受多大成本以应对攻击者的问题。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The threat today is not just an attacker intercepting messages over the wire,
    but an attacker stealing or tampering with the device that runs your cryptography.
    Devices in the so-called Internet of Things (IoT) often run into threats and are,
    by default, unprotected against sophisticated attackers. More recently, cloud
    services are also considered in the threat model of their users.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天的威胁不仅是攻击者拦截信息传输，而且是攻击者窃取或篡改运行您的密码学的设备。所谓的物联网设备通常会遇到威胁，并且默认情况下不受复杂攻击者的保护。最近，云服务也被认为是用户威胁模型的一部分。
- en: Hardware can help protect cryptography applications and their secrets in a highly
    adversarial environment. One of the ideas is to provide a device with a tamper-resistant
    chip to store and perform crypto operations. That is, if the device falls in the
    hands of an attacker, extracting keys or modifying the behavior of the chip will
    be difficult.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件可以帮助保护密码应用程序及其密钥在高度敌对的环境中。其中一个想法是提供一个具有防篡改芯片的设备来存储和执行加密操作。也就是说，如果设备落入攻击者手中，提取密钥或修改芯片行为将会很困难。
- en: It is generally accepted that one has to combine different software and hardware
    techniques to harden cryptography in adversarial environments. But hardware-protected
    cryptography is not a panacea; it is merely defense in-depth, effectively slowing
    down and increasing the cost of an attack. Adversaries with unlimited time and
    money will always break your hardware.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们普遍认为，必须结合不同的软件和硬件技术来加固密码学以应对敌对环境。但硬件保护的密码学并非万能药；它只是多层防御，有效地减慢和增加了攻击的成本。有无限时间和金钱的对手总是能够破坏你的硬件。
- en: Decreasing the impact of an attack can also help deter attackers. This must
    be done by designing a system well (for example, by making sure that the compromise
    of one device does not imply a compromise of all devices).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少攻击的影响也可以帮助吓阻攻击者。这必须通过良好设计系统来完成（例如，确保一个设备的妥协不意味着所有设备都妥协）。
- en: 'While there are many hardware solutions, the most popular ones are as follows:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然有很多硬件解决方案，但最流行的是以下几种：
- en: Smart cards were one of the first such secure microcontrollers that could be
    used as a microcomputer to store secrets and perform cryptographic operations.
    They are supposed to use a number of techniques to discourage physical attackers.
    The concept of a smart card was generalized as a secure element, which is a term
    employed differently in different domains, but boils down to a smart card that
    can be used as a coprocessor in a greater system that already has a main processor.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能卡是最早的这种安全微控制器之一，可用作微型计算机来存储机密信息并执行加密操作。 它们应该使用多种技术来阻止物理攻击者。 智能卡的概念被概括为安全元素，这是一个在不同领域中以不同方式使用的术语，但归结为可以用作辅助处理器的智能卡，用于已经具有主处理器的更大系统中。
- en: Hardware security modules (HSMs) are often referred to as pluggable cards that
    act like secure elements. They do not follow any standard interface but usually
    implement the PKCS#11 standard for cryptographic operations. HSMs can be certified
    with different levels of security via some NIST standard (FIPS 140-3).
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件安全模块（HSM）通常被称为行为类似安全元素的可插拔卡。 它们不遵循任何标准接口，但通常实现PKCS#11标准用于加密操作。 HSM可以通过一些NIST标准（FIPS
    140-3）获得不同级别的安全认证。
- en: Trusted Platform Modules (TPMs) are similar to secure elements with a specified
    interface standardized as TPM 2.0\. A TPM is usually seen plugged into a laptop
    or server motherboard.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受信平台模块（TPM）类似于具有规定接口的安全元素，标准化为TPM 2.0。 TPM通常被视为插入笔记本电脑或服务器主板中。
- en: Trusted execution environment (TEE) is a way to segregate an execution environment
    between a secure one and a potentially insecure one. TEEs are usually implemented
    as an extension of a CPU’s instruction set.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受信执行环境（TEE）是在安全环境和潜在不安全环境之间隔离执行环境的一种方式。 TEE通常作为CPU指令集的扩展来实现。
- en: 'Hardware is not enough to protect cryptographic operations in highly adversarial
    environments as software and hardware side-channel attacks can exploit leakage
    that occurs in different ways (timing, power consumption, electromagnetic radiations,
    and so on). In order to defend against side-channel attacks cryptographic algorithms
    implement software mitigations:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高度对抗环境中，硬件不足以保护加密操作，因为软件和硬件侧信道攻击可以利用以不同方式发生的泄漏（时间、功耗、电磁辐射等）。 为了抵御侧信道攻击，加密算法实施软件减轻措施：
- en: Serious cryptographic implementations are based on constant-time algorithms
    and avoid all branching as well as memory accesses that depend on secret data.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严肃的加密实现基于恒定时间算法，并避免所有分支以及依赖于秘密数据的内存访问。
- en: Mitigation techniques based on blinding and masking decorrelate sensitive operations
    from either the secret or the data known to be operated on.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模糊和掩蔽的减轻技术使敏感操作与秘密或已知要操作的数据脱钩。
- en: Fault attacks are harder to protect against. Mitigations include computing an
    operation several times and comparing and verifying the result of an operation
    (for example, verifying a signature with the public key) before releasing the
    result.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障攻击更难以防范。 减轻措施包括多次计算一个操作，并在发布结果之前比较和验证操作的结果（例如，使用公钥验证签名）。
- en: Hardening cryptography in adversarial settings is a never-ending battle. One
    should use a combination of software and hardware mitigations to increase the
    cost and the time for a successful attack up to a desired accepted risk. One should
    also decrease the impact of an attack by using unique keys per device and, potentially,
    unique keys per cryptographic operation.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对抗环境中加固加密是一场永无止境的战斗。 人们应该使用软件和硬件减轻措施的组合，将成功攻击的成本和时间增加到可接受的风险水平。 人们还应该通过为每个设备使用唯一密钥以及可能为每个加密操作使用唯一密钥来减少攻击的影响。
