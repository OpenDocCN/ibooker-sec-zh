- en: 15 Is this it? Next-generation cryptography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 这就是全部吗？下一代密码学
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Getting rid of trusted third parties via secure multi-party computation (MPC)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过安全多方计算（MPC）摆脱信任的第三方
- en: Allowing others to act on encrypted data via fully homomorphic encryption (FHE)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许他人对加密数据进行操作通过全同态加密（FHE）
- en: Hiding parts of a program execution via zero-knowledge proofs (ZKPs)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过零知识证明（ZKPs）隐藏程序执行的部分
- en: I started this book with the idea that readers who would get through most of
    the chapters would also be interested in the future of real-world cryptography.
    While you’re reading an applied and practical book with a focus on what is in
    use today, the field of cryptography is rapidly changing (as we saw in recent
    years with cryptocurrencies, for example).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始写这本书的时候，认为大部分章节读完的读者也会对现实世界密码学的未来感兴趣。虽然您正在阅读一个侧重于当今使用的应用和实用书籍，但密码学领域正在迅速变化（例如，最近几年我们看到的加密货币）。
- en: 'As you’re reading this book, a number of theoretical cryptographic primitives
    and protocols are making their ways into the applied cryptography world—maybe
    because these theoretical primitives are finally finding a use case or because
    they’re finally becoming efficient enough to be used in real-world applications.
    Whatever the reason, the real world of cryptography is definitely growing and
    getting more exciting. In this chapter, I give you a taste of what the future
    of real-world cryptography might look like (perhaps in the next 10 to 20 years)
    by briefly introducing three primitives:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读本书时，许多理论密码原语和协议正在进入应用密码学领域——也许是因为这些理论原语终于找到了用例，或者是因为它们终于变得足够高效，可以用于实际应用。无论原因是什么，密码学的现实世界肯定在增长并变得更加令人兴奋。在本章中，我通过简要介绍三种原语，为您展示了未来实际密码学可能会是什么样子（也许在未来10到20年内）：
- en: '*Secure multi-party computation* (MPC)—A subfield of cryptography that allows
    different participants to execute a program together without necessarily revealing
    their own input to the program.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全多方计算*（MPC）—密码学的一个子领域，允许不同参与者一起执行程序，而不必向程序透露自己的输入。'
- en: '*Fully homomorphic encryption* (FHE)—The holy grail of cryptography, a primitive
    used to allow arbitrary computations on encrypted data.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全同态加密*（FHE）—密码学的圣杯，一种用于允许对加密数据进行任意计算的原语。'
- en: '*General-purpose zero-knowledge proofs* (ZKPs)—The primitive you learned about
    in chapter 7 that allows you to prove that you know something without revealing
    that something, but this time, applied more generally to more complex programs.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通用零知识证明*（ZKPs）—您在第7章学到的原语，允许您证明自己知道某事而不泄露该事情，但这次更普遍地应用于更复杂的程序。'
- en: This chapter contains the most advanced and complicated concepts in the book.
    For this reason, I recommend that you glance at it and then move on to chapter
    16 to read the conclusion. When you are motivated to learn more about the inners
    of these more advanced concepts, come back to this chapter. Let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了本书中最先进和复杂的概念。因此，我建议您先浏览一下，然后转到第16章阅读结论。当您有动力想要了解这些更高级概念的内部机制时，请回到这一章。让我们开始吧！
- en: '15.1 The more the merrier: Secure multi-party computation (MPC)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 人越多越热闹：安全多方计算（MPC）
- en: Secure multi-party computation (MPC) is a field of cryptography that came into
    existence in 1982 with the famous Millionaires’ problem. In his 1982 paper “Protocols
    for Secure Computations,” Andrew C. Yao wrote, “Two millionaires wish to know
    who is richer; however, they do not want to find out inadvertently any additional
    information about each other’s wealth. How can they carry out such a conversation?”
    Simply put, MPC is a way for multiple participants to compute a program together.
    But before learning more about this new primitive, let’s see why it’s useful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安全多方计算（MPC）是密码学领域的一个子领域，始于1982年的著名百万富翁问题。在他1982年的论文“用于安全计算的协议”中，Andrew C. Yao写道：“两位百万富翁想知道谁更富有；然而，他们不想无意中获得有关对方财富的任何额外信息。他们如何进行这样的对话？”简而言之，MPC是多个参与者一起计算程序的一种方式。但在了解更多关于这种新原语之前，让我们看看它为什么有用。
- en: We know that with the help of a trusted third party, any distributed computation
    can easily be worked out. This trusted third party can perhaps maintain the privacy
    of each participant’s input, as well as possibly restricting the amount of information
    revealed by the computation to specific participants. In the real world, though,
    we don’t like trusted third parties too much; we know that they are pretty hard
    to come by, and they don’t always respect their commitments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在可信第三方的帮助下，任何分布式计算都可以轻松解决。这个可信第三方可以可能维护每个参与者输入的隐私，同时可能限制计算所透露给特定参与者的信息量。然而，在现实世界中，我们不太喜欢可信第三方；我们知道它们很难找到，并且它们并不总是遵守自己的承诺。
- en: MPC allows us to completely remove trusted third parties from a distributed
    computation and enables participants to compute the computation by themselves
    without revealing their respective inputs to one another. This is done through
    a cryptographic protocol. With that in mind, using MPC in a system is pretty much
    the equivalent to using a trusted third party (see figure 15.1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MPC允许我们完全将可信第三方从分布式计算中移除，并使参与者能够自行计算计算，而不会向彼此透露各自的输入。这是通过一个加密协议完成的。考虑到这一点，在系统中使用MPC基本上等同于使用一个可信第三方（见图15.1）。
- en: '![](../Images/15_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_01.jpg)'
- en: Figure 15.1 A secure multi-party computation (MPC) protocol turns a distributed
    computation that can be calculated via a trusted third party (image on the left)
    into a computation that doesn’t need the help of a trusted third party (image
    on the right).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 安全多方计算（MPC）协议将一个可以通过可信第三方进行计算的分布式计算（左侧图像）转变为一个不需要可信第三方帮助的计算（右侧图像）。
- en: Note that you already saw some MPC protocols. Threshold signatures and distributed
    key generations, covered in chapter 8, are examples of MPC. More specifically,
    these examples are part of a subfield of MPC called *threshold cryptography*,
    which has been receiving a lot of love in more recent years with, for example,
    NIST in mid-2019 kicking off a standardization process for threshold cryptography.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您已经看到了一些MPC协议。阈值签名和分布式密钥生成，涵盖在第8章中，是MPC的示例。更具体地说，这些示例是MPC的一个子领域，称为*阈值密码学*，在近年来受到了很多关注，例如，2019年中期NIST启动了阈值密码学的标准化过程。
- en: 15.1.1 Private set intersection (PSI)
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.1 私有集合交集（PSI）
- en: 'Another well-known subfield of MPC is the field of *private set intersection*
    (PSI), which poses the following problem: Alice and Bob have a list of words,
    and they want to know which words (or perhaps just how many) they have in common
    without revealing their respective list of words. One way to solve this problem
    is to use the oblivious pseudorandom function (OPFR) construction you learned
    about in chapter 11\. (I illustrate this protocol in figure 15.2.) If you recall'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个众所周知的MPC子领域是*私有集合交集*（PSI）的领域，它提出了以下问题：Alice和Bob有一组单词，他们想知道他们有哪些单词（或者可能只是有多少）是共同的，而不暴露各自的单词列表。解决这个问题的一种方法是使用你在第11章学到的遗忘伪随机函数（OPFR）构造。（我在图15.2中说明了这个协议。）如果您回忆起来
- en: Bob generates a key for the OPRF.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob为OPRF生成一个密钥。
- en: Alice obtains the random values, *PRF*(*key*, *word*), for every word in her
    list using the OPRF protocol (so she doesn’t learn the PRF key and Bob doesn’t
    learn the words).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice使用OPRF协议为她列表中的每个单词获取随机值*PRF*（*key*，*word*）（因此她不会得知PRF密钥，Bob也不会得知这些单词）。
- en: Bob then can compute the list of *PRF* (*key*, *word*) values for his own words
    and send it to Alice, who is then able to compare it with her own PRF outputs
    to see if any of Bob’s PRF outputs matches.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后Bob可以计算他自己单词的*PRF*（*key*，*word*）值列表，并将其发送给Alice，然后Alice可以将其与她自己的PRF输出进行比较，以查看Bob的任何PRF输出是否匹配。
- en: '![](../Images/15_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_02.jpg)'
- en: Figure 15.2 Private set intersection (PSI) allows Alice to learn what words
    she has in common with Bob. First, she blinds every word she has in her list and
    uses the OPRF protocol with Bob to apply a PRF using Bob’s key on each of her
    words. Finally, Bob sends her the PRF of his key with his words. Alice can then
    see if anything matches to learn what words they have in common.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 私有集合交集（PSI）允许Alice了解她与Bob有哪些共同的单词。首先，她会对她列表中的每个单词进行盲化，并使用OPRF协议与Bob一起对每个单词应用PRF，使用Bob的密钥。最后，Bob发送给她他的单词与其密钥的PRF。然后，Alice可以查看是否有任何匹配项，以了解他们共有哪些单词。
- en: PSI is a promising field that is starting to see more and more adoption in recent
    years, as it has shown to be much more practical than it used to be. For example,
    Google’s Password Checkup feature integrated into the Chrome browser uses PSI
    to warn you when some of your passwords have been detected in password dumps following
    password breaches without actually seeing your passwords. Interestingly, Microsoft
    also does this for its Edge browser but uses fully homomorphic encryption (which
    I’ll introduce in the next section) to perform the private set intersection. On
    the other hand, the developers of the Signal messaging application (discussed
    in chapter 10) decided that PSI was too slow to perform contact discovery in order
    to figure out who you can talk to based on your phone’s contact list, and instead,
    used SGX (covered in chapter 13) as a trusted third party.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PSI 是一个前景广阔的领域，近年来开始越来越多地得到应用，因为它显示出比过去更实用的特点。例如，Google的Chrome浏览器集成的密码检查功能使用PSI来在密码泄露后的密码转储中检测到您的某些密码时向您发出警告，而不实际看到您的密码。有趣的是，微软也为其Edge浏览器做了同样的事情，但使用全同态加密（我将在下一节介绍）执行私有集交。另一方面，Signal消息应用的开发人员（在第10章讨论）认为PSI速度太慢，无法执行联系发现，以便根据您手机的联系人列表确定可以与您交谈的人，并且改用了SGX（在第13章介绍）作为可信第三方。
- en: 15.1.2 General-purpose MPC
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.2 通用型多方计算
- en: More generally, MPC has many different solutions aiming at the computation of
    arbitrary programs. General-purpose MPC solutions all provide different levels
    of efficiency (from hours to milliseconds) and types of properties. For example,
    how many dishonest participants can the protocol tolerate? Are participants malicious
    or just honest but curious (also called *semi-honest*, a type of participant in
    MPC protocols that is willing to execute the protocol correctly but might attempt
    to learn the other participants’ inputs)? Is it fair to all participants if some
    of them terminate the protocol early?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，MPC有许多不同的解决方案，旨在计算任意程序。通用型MPC解决方案提供不同级别的效率（从几小时到几毫秒）和不同类型的属性。例如，协议可以容忍多少不诚实的参与者？参与者是恶意的还是只是诚实但好奇（也称为*半诚实*，是MPC协议中的一种参与者类型，他们愿意正确执行协议，但可能试图了解其他参与者的输入）？如果其中一些参与者提前终止协议，那么所有参与者是否都公平？
- en: Before a program can be securely computed with MPC, it needs to be translated
    into an *arithmetic circuit*. Arithmetic circuits are successions of additions
    and multiplications, and because they are Turing complete, they can represent
    *any* program! For an illustration of an arithmetic circuit, see figure 15.3.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MPC可以安全计算程序之前，需要将其转换为*算术电路*。算术电路是一系列的加法和乘法，因为它们是图灵完备的，所以它们可以表示*任何*程序！有关算术电路的说明，请参见图15.3。
- en: '![](../Images/15_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_03.jpg)'
- en: Figure 15.3 An arithmetic circuit is a number of addition or multiplication
    gates linking inputs to outputs. In the figure, values travel from left to right.
    For example, *d* = *a* + *b*. Here, the circuit only outputs one value *f* = *a*
    + *b* + *bc*, but it can in theory have multiple output values. Notice that different
    inputs to the circuit are provided by different participants, but they could also
    be public inputs (known to everyone).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 一个算术电路是一些将输入与输出连接起来的加法或乘法门。在图中，数值从左到右传播。例如，*d* = *a* + *b*。在这里，电路只输出一个值
    *f* = *a* + *b* + *bc*，但理论上它可以有多个输出值。请注意，电路的不同输入由不同的参与者提供，但它们也可以是公共输入（为所有人所知）。
- en: 'Before taking a look at the next primitive, let me give you a simplified example
    of an (honest-majority) general-purpose MPC built via Shamir’s secret sharing.
    Many more schemes exist, but this one is simple enough to fit here in a three-step
    explanation: share enough information on each input in the circuit, evaluate every
    gate in the circuit, and reconstruct the output. Let’s look at each step in more
    detail.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在看下一个原语之前，让我给你一个通过Shamir的秘密共享构建的（诚实多数）通用型多方计算的简化示例。存在许多更多的方案，但这个方案足够简单，可以在这里进行三步解释：在电路中共享每个输入的足够信息，评估电路中的每个门，以及重构输出。让我们更详细地看看每一步。
- en: The first step is for every participant to have enough information about each
    input of the circuit. Public inputs are shared publicly, while private inputs
    are shared via Shamir’s secret sharing (covered in chapter 8). I illustrate this
    in figure 15.4.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是每个参与者对电路的每个输入都有足够的信息。公共输入是公开分享的，而私有输入是通过Shamir的秘密共享（在第8章中介绍）分享的。我在图15.4中说明了这一点。
- en: '![](../Images/15_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_04.jpg)'
- en: Figure 15.4 The first step of a general-purpose MPC with secret sharing is to
    have participants split their respective secret inputs (using Shamir’s secret
    sharing scheme) and distribute the parts to all participants. For example, here
    Alice splits her input *a* into *a*[1] and *a*[2]. Because there are only two
    participants in this example, she gives the first share to herself and gives Bob
    the second one.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 通用 MPC 的第一步是使用 Shamir 的秘密共享方案，让参与者分割各自的秘密输入并将部分分发给所有参与者。例如，在这里，Alice
    将她的输入 *a* 分割成 *a*[1] 和 *a*[2]。因为在这个例子中只有两个参与者，她将第一个份额给了自己，将第二个份额给了 Bob。
- en: The second step is to evaluate every gate of the circuit. For technical reasons
    I’ll omit here, addition gates can be computed locally, while multiplication gates
    must be computed interactively (participants must exchange some messages). For
    an addition gate, simply add the input shares you have; for a multiplication gate,
    multiply the input shares. What you get is a share of the result as figure 15.5
    illustrates. At this point, the shares can be exchanged (in order to reconstruct
    the output) or kept separate to continue the computation (if they represent an
    intermediate value).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是评估电路的每个门。由于技术原因，我将在这里省略，加法门可以在本地计算，而乘法门必须通过交互方式计算（参与者必须交换一些消息）。对于加法门，只需将您拥有的输入份额相加；对于乘法门，将输入份额相乘。您得到的是一个结果份额，如图
    15.5 所示。此时，份额可以交换（以重建输出）或保持分开以继续计算（如果它们代表中间值）。
- en: '![](../Images/15_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_05.jpg)'
- en: Figure 15.5 The second step of a general-purpose MPC with secret sharing is
    to have participants compute each gate in the circuit. For example, a participant
    can compute an addition gate by adding the two input Shamir shares that they have,
    which produces a Shamir share of the output.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 通用 MPC 的第二步是让参与者计算电路中的每个门。例如，参与者可以通过添加他们拥有的两个输入 Shamir 份额来计算一个加法门，这将产生一个输出的
    Shamir 份额。
- en: The final step is to reconstruct the output. At this point, the participants
    should all own a share of the output, which they can use to reconstruct the final
    output using the final step of Shamir’s secret sharing scheme.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是重建输出。此时，参与者应该都拥有输出的一个份额，他们可以使用这个份额来使用 Shamir 的秘密共享方案的最后一步来重建最终输出。
- en: 15.1.3 The state of MPC
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.3 MPC 的现状
- en: There’s been huge progress in the last decade to make MPC practical. It is a
    field of many different use cases, and one should be on the lookout for the potential
    applications that can benefit from this newish primitive. Note that, unfortunately,
    no real standardization effort exists, and while several MPC implementations can
    be considered practical for many use cases today, they are not easy to use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年中，MPC 的实用性取得了巨大进展。这是一个涵盖许多不同用例的领域，人们应该密切关注可以从这种新型原语中受益的潜在应用。需要注意的是，不幸的是，目前并没有真正的标准化努力，虽然今天有几种
    MPC 实现可以被认为对许多用例来说是实用的，但它们并不容易使用。
- en: Incidentally, the general-purpose MPC construction I explained earlier in this
    section is based on secret sharing, but there are more ways to construct MPC protocols.
    A well-known alternative is called *garbled circuits*, which is a type of construction
    first proposed by Yao in his 1982 paper introducing MPC. Another alternative is
    based on fully homomorphic encryption, a primitive you’ll learn about in the next
    section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在本节前面我解释的通用 MPC 构造是基于秘密共享的，但构造 MPC 协议的方法还有很多。一个著名的替代方案叫做*加密电路*，这是姚期智在他
    1982 年的论文中首次提出 MPC 时提出的一种构造类型。另一个选择是基于全同态加密，这是你将在下一节中了解的一种基本原语。
- en: 15.2 Fully homomorphic encryption (FHE) and the promises of an encrypted cloud
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 完全同态加密（FHE）和加密云的承诺
- en: 'For a long time in cryptography, a question has troubled many cryptographers:
    is it possible to compute arbitrary programs on encrypted data? Imagine that you
    could encrypt the values *a*, *b*, and *c* separately, send the ciphertexts to
    a service, and ask that service to return the encryption of *a* × 3*b* + 2*c*
    + 3, which you could then decrypt. The important idea here is that the service
    never learns about your values and always deals with ciphertexts. This calculation
    might not be too useful, but with additions and multiplications, one can compute
    actual programs on the encrypted data.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学领域长期以来，一个问题困扰着许多密码学家：是否可能在加密数据上计算任意程序？想象一下，您可以分别加密值 *a*、*b* 和 *c*，将密文发送到一个服务，然后要求该服务返回
    *a* × 3*b* + 2*c* + 3 的加密结果，然后您可以解密它。这里的重要思想是服务永远不会了解您的值，并始终处理密文。这个计算可能不太有用，但是通过加法和乘法，可以在加密数据上计算实际程序。
- en: This interesting concept, originally proposed in 1978 by Rivest, Adleman, and
    Dertouzos, is what we call *fully homomorphic encryption* (FHE) (or as it used
    to be called, the *holy grail of cryptography*). I illustrate this cryptographic
    primitive in figure 15.6.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有趣的概念最初是由 Rivest、Adleman 和 Dertouzos 在 1978 年提出的，我们称之为 *完全同态加密*（FHE）（或者以前被称为
    *密码学圣杯*）。我在图 15.6 中说明了这个密码学原语。
- en: '![](../Images/15_06.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_06.jpg)'
- en: Figure 15.6 Fully homomorphic encryption (FHE) is an encryption scheme that
    allows for arbitrary computations over encrypted content. Only the owner of the
    key can decrypt the result of the computation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6 完全同态加密（FHE）是一种加密方案，允许对加密内容进行任意计算。只有密钥的所有者可以解密计算结果。
- en: 15.2.1 An example of homomorphic encryption with RSA encryption
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.1 使用 RSA 加密的同态加密示例
- en: 'By the way, you already saw some cryptographic schemes that should make you
    feel like you know what I’m talking about. Think of RSA (covered in chapter 6):
    given a *ciphertext* = *message*^e mod *N*, someone can easily compute some restricted
    function of the ciphertext'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，您已经看到了一些加密方案，应该让您感觉自己知道我在说什么。想想 RSA（在第 6 章中讨论过）：给定一个 *ciphertext* = *message*^e
    mod *N*，某人可以轻松计算密文的某些受限函数
- en: '*n*^e × *ciphertext* = (*n* × *message*)^e mod *N*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*^e × *ciphertext* = (*n* × *message*)^e mod *N*'
- en: for any number *n* they want (although it can’t be too big). The result is a
    ciphertext that decrypts to
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 他们想要的任何数字（虽然不能太大）。结果是一个解密为
- en: '*n* × *message*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* × *message*'
- en: Of course, this is not a desired behavior for RSA, and it has led to some attacks
    (for example, Bleichenbacher’s attack mentioned in chapter 6). In practice, RSA
    breaks the homomorphism property by using a padding scheme. Note that RSA is homomorphic
    only for the multiplication, which is not enough to compute arbitrary functions,
    as both multiplication and addition are needed for those. Due to this limitation,
    we say that RSA is *partially homomorphic*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是 RSA 想要的行为，这导致了一些攻击（例如第 6 章提到的 Bleichenbacher 的攻击）。在实践中，RSA通过使用填充方案来打破同态性质。请注意，RSA
    仅对乘法同态，这对于计算任意函数是不够的，因为这需要乘法和加法。由于这个限制，我们说 RSA 是 *部分同态*。
- en: 15.2.2 The different types of homomorphic encryption
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.2 不同类型的同态加密
- en: Other types of homomorphic encryptions include
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的同态加密包括
- en: '*Somewhat homomorphic*—Which means partially homomorphic for one operation
    (addition or multiplication) and homomorphic for the other operation in limited
    ways. For example, additions are unlimited up to a certain number but only a few
    multiplications can be done.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分同态*—意味着对于一种操作（加法或乘法）部分同态，另一种操作在有限的方式上是同态的。例如，加法在一定数量上是无限制的，但只能进行少量乘法。'
- en: '*Leveled homomorphic*—Both addition and multiplication are possible up to a
    certain number of times.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分层同态*—可以进行一定次数的加法和乘法。'
- en: '*Fully homomorphic*—Addition and multiplication are unlimited (it’s the real
    deal).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完全同态*—加法和乘法无限制（这才是真正的东西）。'
- en: Before the invention of FHE, several types of homomorphic encryption schemes
    were proposed, but none could achieve what fully homomorphic encryption promised.
    The reason is that by evaluating circuits on encrypted data, some *noise* grows;
    after a point, the noise has reached a threshold that makes decryption impossible.
    And, for many years, some researchers tried to prove that perhaps there was some
    information theory that could show that fully homomorphic encryption was impossible;
    that is, until it was shown to be possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在FHE的发明之前，提出了几种类型的同态加密方案，但没有一种能够实现完全同态加密所承诺的功能。原因是通过在加密数据上评估电路，一些*噪声*会增加；在某个点之后，噪声已经达到了使解密变得不可能的阈值。多年来，一些研究人员试图证明也许有一些信息理论可以表明完全同态加密是不可能的；直到被证明是可能的。
- en: 15.2.3 Bootstrapping, the key to fully homomorphic encryption
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3 启动引导，完全同态加密的关键
- en: '*One night, Alice dreams of immense riches, caverns piled high with silver,
    gold and diamonds. Then, a giant dragon devours the riches and begins to eat its
    own tail! She awakes with a feeling of peace. As she tries to make sense of her
    dream, she realizes that she has the solution to her problem*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*一天晚上，爱丽丝梦见了巨大的财富，洞穴里堆满了银、金和钻石。然后，一只巨龙吞噬了财富，并开始吃自己的尾巴！她醒来时感到平静。当她试图理解她的梦时，她意识到她已经找到了解决问题的方法*。'
- en: —Craig Gentry (“Computing Arbitrary Functions of Encrypted Data,” 2009)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: —克雷格·根特里（“计算加密数据的任意函数”，2009）
- en: In 2009, Craig Gentry, a PhD student of Dan Boneh, proposed the first-ever fully
    homomorphic encryption construction. Gentry’s solution was called *bootstrapping*,
    which in effect was to evaluate a decryption circuit on the ciphertext every so
    often in order to reduce the noise to a manageable threshold. Interestingly, the
    decryption circuit itself does not reveal the private key and can be computed
    by the untrusted party. Bootstrapping allowed turning a leveled FHE scheme into
    an FHE scheme. Gentry’s construction was slow and quite impractical, reporting
    about 30 minutes per basic bit operation, but as with any breakthrough, it only
    got better with time. It also showed that fully homomorphic encryption was possible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，丹·博内的博士生克雷格·根特里提出了有史以来第一个完全同态加密构造。根特里的解决方案被称为*启动引导*，实际上是每隔一段时间在密文上评估解密电路，以将噪声降低到可管理的阈值。有趣的是，解密电路本身不会泄露私钥，并且可以由不受信任的一方计算。启动引导允许将分层的FHE方案转变为FHE方案。根特里的构造速度很慢且相当不切实际，每个基本位操作大约需要30分钟，但与任何突破一样，随着时间的推移变得更好。它还表明完全同态加密是可能的。
- en: How does bootstrapping work? Let’s see if we can gain some insight. First, I
    need to mention that we’ll need not a symmetric encryption system, but a public
    key encryption system, where a public key can be used to encrypt and a private
    key can be used to decrypt. Now, imagine that you execute a certain number of
    additions and multiplications on a ciphertext and reach some level of noise. The
    noise is low enough to still allow you to decrypt the ciphertext correctly, but
    too high that it won’t let you perform more homomorphic operations without destroying
    the encrypted content. I illustrate this in figure 15.7.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 启动引导是如何工作的？让我们看看是否能获得一些见解。首先，我需要提到我们不需要对称加密系统，而是需要一个公钥加密系统，其中公钥可用于加密，私钥可用于解密。现在，想象一下，你在一个密文上执行了一定数量的加法和乘法运算，并达到了一定的噪声水平。噪声足够低，仍然可以正确解密密文，但太高了，不会让你执行更多同态操作而不破坏加密内容。我在图15.7中说明了这一点。
- en: '![](../Images/15_07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_07.jpg)'
- en: Figure 15.7 After encrypting a message with a fully homomorphic encryption algorithm,
    operating on it increases its noise to dangerous thresholds, where decryption
    becomes impossible.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 在使用完全同态加密算法加密消息后，对其进行操作会将其噪声增加到危险的阈值，解密变得不可能。
- en: You could think that you’re stuck, but bootstrapping unsticks you by removing
    the noise out of that ciphertext. To do that, you re-encrypt the noisy ciphertext
    under another public key (usually called the *bootstrapping key*) to obtain an
    encryption of that noisy ciphertext. Notice that the new ciphertext has no noise.
    I illustrate this in figure 15.8.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为自己陷入了困境，但启动引导通过从那个密文中去除噪声来解决问题。为此，你需要使用另一个公钥（通常称为*启动引导密钥*）重新加密有噪声的密文，以获得该有噪声的密文的加密。请注意，新的密文没有噪声。我在图15.8中说明了这一点。
- en: '![](../Images/15_08.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_08.jpg)'
- en: Figure 15.8 Building on figure 15.7, to eliminate the noise of the ciphertext,
    you can decrypt it. But because you don’t have the secret key, instead you re-encrypt
    the noisy ciphertext under another public key (called the bootstrapping key) to
    obtain a new ciphertext of a noisy ciphertext without error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 在图15.7的基础上，为了消除密文的噪声，你可以对其进行解密。但是因为你没有秘密密钥，所以你将嘈杂的密文重新加密在另一个公钥下（称为引导密钥）以获得一个新的密文，该密文是没有错误的嘈杂密文。
- en: 'Now comes the magic: you are provided with the initial private key, not in
    cleartext, but encrypted under that bootstrapping key. This means that you can
    use it with a decryption circuit to homomorphically decrypt the inner noisy ciphertext.
    If the decryption circuit produces an acceptable amount of noise, then it works,
    and you will end up with the result of the first homomorphic operation encrypted
    under the bootstrapping key. I illustrate this in figure 15.9.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来到了魔法的部分：你被提供了初始的私钥，但不是以明文形式，而是在那个引导密钥下加密的。这意味着你可以使用解密电路与同态地解密内部带有噪声的密文。如果解密电路产生的噪声量是可接受的，那么它就起作用了，你将得到第一个同态操作的结果，其密文是在引导密钥下加密的。我在图15.9中进行了说明。
- en: '![](../Images/15_09.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_09.jpg)'
- en: Figure 15.9 Building on figure 15.9, you use the initial secret key encrypted
    to the bootstrapping key to apply the decryption circuit to that new ciphertext.
    This effectively decrypts the noisy ciphertext in place, removing the errors.
    There will be some amount of errors due to the decryption circuit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 在图15.9的基础上，你使用了初始的加密到引导密钥的秘密密钥来对新的密文应用解密电路。这有效地在原地解密了带有噪声的密文，消除了错误。由于解密电路，会产生一定数量的错误。
- en: 'If the remaining amount of errors allows you to do at least one more homomorphic
    operation (+ or ×), then you are gold: you have a fully homomorphic encryption
    algorithm because you can always, in practice, run the bootstrapping after or
    before every operation. Note that you can set the bootstrapping key pair to be
    the same as the initial key pair. It’s a bit weird as you get some circular security
    oddity, but it seems to work and no security issues are known.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果剩余的错误量允许你至少进行一次同态操作（+或×），那么你就成功了：你拥有一个完全同态加密算法，因为你可以始终在实践中在每个操作之后或之前运行引导。请注意，你可以将引导密钥对设置为与初始密钥对相同。这有点奇怪，因为你会得到一些循环安全问题，但似乎它可以运行，且没有已知的安全问题。
- en: 15.2.4 An FHE scheme based on the learning with errors problem
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.4 基于学习中的错误问题的FHE方案
- en: 'Before moving on, let’s see one example of an FHE scheme based on the learning
    with errors problem we saw in chapter 14\. I’ll explain a simplified version of
    the GSW scheme, named after the authors Craig Gentry, Amit Sahai, and Brent Waters.
    To keep things simple, I’ll introduce a secret key version of the algorithm, but
    just keep in mind that it is relatively straightforward to transform such a scheme
    into a public key variant, which we need for bootstrapping. Take a look at the
    following equation where **C** is a square matrix, **s** is a vector, and *m*
    is a scalar (a number):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看一个基于我们在第14章中看到的学习中的错误问题的FHE方案的示例。我将解释一个简化版本的GSW方案，以作者Craig Gentry、Amit
    Sahai和Brent Waters的名字命名。为了保持简单，我将介绍算法的秘密密钥版本，但请记住，将这样的方案转换为我们需要的公钥变体是相对简单的，这是我们用于引导的。看看下面的方程式，其中**C**是一个方阵，**s**是一个向量，而*m*是一个标量（一个数字）：
- en: '**Cs** = *m***s**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cs** = *m***s**'
- en: In this equation, **s** is called an *eigenvector* and *m* is an *eigenvalue*.
    If these words are foreign to you, don’t worry about it; they don’t matter much
    here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，**s**被称为*eigenvector*而*m*被称为*eigenvalue*。如果这些词对你来说很陌生，不用担心；它们在这里并不重要。
- en: The first intuition in our FHE scheme is obtained by looking at the eigenvectors
    and eigenvalues. The observation is that if we set *m* to a single bit we want
    to encrypt, **C** to be the ciphertext, and **s** to be the secret key, then we
    have an (insecure) homomorphic encryption scheme to encrypt one bit. (Of course,
    we assume there is a way to obtain a random ciphertext **C** from a fixed bit
    *m* and a fixed secret key **s**.) I illustrate this in figure 15.10 in a Lego
    kind of way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们FHE方案中的第一个直觉是通过观察特征向量和特征值得到的。观察到的是，如果我们将*m*设置为要加密的单个位，**C**设置为密文，**s**设置为秘密密钥，则我们有一个（不安全的）同态加密方案来加密一个位。
    （当然，我们假设存在一种方法从固定位*m*和固定秘密密钥**s**获取随机密文**C**。）我在图15.10中以一种乐高方式进行了说明。
- en: '![](../Images/15_10.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_10.jpg)'
- en: Figure 15.10 We can produce an insecure homomorphic encryption scheme to encrypt
    a single bit *m* with a secret vector **s** by interpreting *m* as an eigenvalue
    and **s** as an eigenvector and then finding the associated matrix **C**, which
    will be the ciphertext.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.10 我们可以通过将 *m* 解释为一个特征值，**s** 解释为一个特征向量，然后找到关联矩阵 **C** 来生成一个不安全的同态加密方案，该方案将密文。
- en: 'To decrypt a ciphertext, you multiply the matrix with the secret vector **s**
    and see if you obtain the secret vector back or 0\. You can verify that the scheme
    is fully homomorphic by checking that the decryption of two ciphertexts added
    together (**C**[1] + **C**[2]) results in the associated bits added together:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密密文，您需要用秘密向量 **s** 乘以矩阵，然后查看是否获得了秘密向量或 0。您可以验证该方案是完全同态的，方法是检查两个密文加在一起的解密结果是否是相应位相加的结果：
- en: (**C**[1] + **C**[2])**s** = **C**[1]**s** + **C**[2]**s** = *b*[1]**s** + *b*[2]**s**
    = (*b*[1] + *b*[2])**s**
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (**C**[1] + **C**[2])**s** = **C**[1]**s** + **C**[2]**s** = *b*[1]**s** + *b*[2]**s**
    = (*b*[1] + *b*[2])**s**
- en: 'Also, the decryption of two ciphertexts multiplied together (**C**[1] × **C**[2])
    results in the associated bits multiplied together:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，两个密文相乘的解密结果 (**C**[1] × **C**[2]) 是相应位相乘的结果：
- en: (**C**[1] × **C**[2])**s** = **C**[1] (**C**[2]**s**) = **C**[1] (*b*[2]**s**)
    = *b*[2]**C**[1]**s** = (*b*[2] × *b*[1]) **s**
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (**C**[1] × **C**[2])**s** = **C**[1] (**C**[2]**s**) = **C**[1] (*b*[2]**s**)
    = *b*[2]**C**[1]**s** = (*b*[2] × *b*[1]) **s**
- en: 'Unfortunately, that scheme is insecure as it is trivial to retrieve the eigenvector
    (the secret vector **s**) from **C**. What about adding a bit of noise? We can
    change this equation a bit to make it look like our learning with errors problem:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，该方案不安全，因为很容易从 **C** 中检索出特征向量（秘密向量 **s**）。增加一点噪声呢？我们可以稍微改变这个方程，使它看起来像我们的误差学习问题：
- en: '**Cs** = *m***s** + **e**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cs** = *m***s** + **e**'
- en: 'This should look more familiar. Again, we can verify that the addition is still
    homomorphic:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该更加熟悉了。同样，我们可以验证加法仍然是同态的：
- en: (**C**[1] + **C**[2])**s** = **C**[1]**s** + **C**[2]**s** = *b*[1]**s** + **e**[1]
    + *b*[2]**s** + **e**[2] = (*b*[1] + *b*[2])**s** + (**e**[1]+**e**[2])
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: (**C**[1] + **C**[2])**s** = **C**[1]**s** + **C**[2]**s** = *b*[1]**s** + **e**[1]
    + *b*[2]**s** + **e**[2] = (*b*[1] + *b*[2])**s** + (**e**[1]+**e**[2])
- en: 'Here, notice that the error is growing (**e**[1] + **e**[2]), which is what
    we expected. We can also verify that the multiplication is still working as well:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，注意到误差正在增加（**e**[1] + **e**[2]），这正是我们预期的。我们还可以验证乘法仍然有效：
- en: (**C**[1] × **C**[2])**s** = **C**[1] (**C**[2]**s**) = **C**[1] (*b*[2]**s**
    + **e**[2]) = *b*[2]**C**[1]**s** + **C**[1]**e**[2] = *b*[2] (*b*[1]**s** + **e**[1])
    + **C**[1]**e**[2]
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (**C**[1] × **C**[2])**s** = **C**[1] (**C**[2]**s**) = **C**[1] (*b*[2]**s**
    + **e**[2]) = *b*[2]**C**[1]**s** + **C**[1]**e**[2] = *b*[2] (*b*[1]**s** + **e**[1])
    + **C**[1]**e**[2]
- en: = (*b*[2] × *b*[1]) **s** + *b*[2]**e**[1] + **C**[1]**e**[2]
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: = (*b*[2] × *b*[1]) **s** + *b*[2]**e**[1] + **C**[1]**e**[2]
- en: Here, *b*[2]**e**[1] is small (as it is either **e**[1] or 0), but **C**[1]**e**[2]
    is potentially large. This is obviously a problem, which I’m going to ignore to
    avoid digging too much into the details. If you’re interested in learning more,
    make sure to read Shai Halevi’s “Homomorphic Encryption” report (2017), which
    does an excellent job at explaining all of these things and more.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*b*[2]**e**[1] 很小（因为它要么是 **e**[1] 要么是 0），但 **C**[1]**e**[2] 可能很大。这显然是一个问题，我会忽略它以避免深入研究细节。如果你有兴趣了解更多，请务必阅读沙伊·哈莱维（Shai
    Halevi）于 2017 年发表的《同态加密》报告，该报告在解释所有这些内容及更多内容方面做得非常出色。
- en: 15.2.5 Where is it used?
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.5 它在哪里使用？
- en: The most touted use case of FHE has always been the cloud. What if I could continue
    to store my data in the cloud without having it seen? And, additionally, what
    if the cloud could provide useful computations on that encrypted data? Indeed,
    one can think of many applications where FHE could be useful. A few examples include
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: FHE 最被吹捧的用例一直是云。如果我可以继续将我的数据存储在云中而不被看到怎么办？而且，此外，如果云可以在加密数据上提供有用的计算呢？事实上，人们可以想到许多应用场景可以使用
    FHE。一些例子包括
- en: A spam detector could scan your emails without looking at those.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾邮件检测器可以扫描您的电子邮件而不看这些内容。
- en: Genetic research could be performed on your DNA without actually having to store
    and protect your privacy-sensitive human code.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对您的DNA进行遗传研究，而无需实际存储和保护您的隐私敏感人类编码。
- en: A database could be stored encrypted and queried on the server side without
    revealing any data.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库可以加密存储，并且在服务器端进行查询而不泄露任何数据。
- en: Yet Phillip Rogaway, in his seminal 2015 paper on “The Moral Character of Cryptographic
    Work,” notes that “FHE [. . .] have engendered a new wave of exuberance. In grant
    proposals, media interviews, and talks, leading theorists speak of FHE [. . .]
    as game-changing indications of where we have come. Nobody seems to emphasize
    just how speculative it is that any of this will ever have any impact on practice.”
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，菲利普·罗加韦在他2015年关于“密码工作的道德性质”的开创性论文中指出，“全同态加密[...]引发了一波新的狂热。在资助提案、媒体采访和演讲中，领先的理论家们谈论全同态加密[...]作为我们取得进展的标志性迹象。没有人似乎强调这种假设性的东西是否会对实践产生任何影响。”
- en: While Rogaway is not wrong, FHE is still quite slow, advances in the field have
    been exciting. At the time of this writing (2021), operations are about one billion
    times slower than normal operations, yet since 2009, there has been a 10⁹ speed-up.
    We are undoubtedly moving towards a future where FHE will be possible for at least
    some limited applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管罗加韦并没有错，全同态加密仍然非常缓慢，但该领域的进展令人兴奋。截至撰写本文时（2021年），操作速度比正常操作慢约十亿倍，但自2009年以来，已经有了10⁹倍的加速。毫无疑问，我们正在朝着未来的方向前进，至少对于某些有限的应用来说，全同态加密将成为可能。
- en: Furthermore, not every application needs the full-blown primitive; somewhat
    homomorphic encryption can also be used in a wide range of applications and is
    much more efficient than FHE. A good indicator that a theoretical cryptography
    primitive is entering the real world is standardization, and indeed, FHE is no
    foreigner to that. The [https://homomorphicencryption.org](https://homomorphicencryption.org)
    standardization effort includes many large companies and universities. It is still
    unclear exactly when, where, and in what form homomorphic encryption will make
    its entry into the real world. What’s clear is that it will happen, so stay tuned!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，并非每个应用都需要全面的原语；有些同态加密可以在广泛的应用中使用，比全同态加密更有效。一个理论密码原语进入现实世界的一个良好指标是标准化，而事实上，全同态加密并不陌生于此。[https://homomorphicencryption.org](https://homomorphicencryption.org)的标准化工作包括许多大公司和大学。目前尚不清楚全同态加密何时、何地以及以何种形式进入现实世界。但可以肯定的是，它将会发生，敬请关注！
- en: 15.3 General-purpose zero-knowledge proofs (ZKPs)
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 通用零知识证明（ZKPs）
- en: I talked about zero-knowledge proofs (ZKPs) in chapter 7 on signatures. There,
    I pointed out that signatures are similar to non-interactive ZKPs of knowledge
    for discrete logarithms. These kinds of ZKPs were invented in the mid-1980s by
    Professors Shafi Goldwasser, Silvio Micali, and Charles Rackoff. Shortly after,
    Goldreich, Micali, and Wigderson found that we could prove much more than just
    discrete logarithms or other types of hard problems; we could also prove the correct
    execution of any program even if we removed some of the inputs or outputs (see
    figure 15.11 for an example). This section focuses on this general-purpose type
    of ZKP.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章中我谈到了零知识证明（ZKPs）与签名有关。在那里，我指出签名类似于离散对数的非交互式ZKPs。这种ZKPs是由沙菲·戈德瓦塞、席尔维奥·米卡利和查尔斯·拉科夫教授于上世纪80年代中期发明的。不久之后，戈德雷希、米卡利和威格德森发现我们不仅可以证明离散对数或其他类型的难题，还可以证明任何程序的正确执行，即使我们删除了一些输入或输出（参见图15.11的示例）。本节重点讨论这种通用类型的ZKP。
- en: '![](../Images/15_11.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_11.jpg)'
- en: Figure 15.11 General-purpose ZKPs allow a prover to convince a verifier about
    the integrity of an execution trace (the inputs of a program and the outputs obtained
    after its execution) while hiding some of the inputs or outputs involved in the
    computation. An example of this is a prover trying to prove that a sudoku can
    be solved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 通用ZKPs允许证明者说服验证者关于执行轨迹的完整性（程序的输入以及执行后获得的输出），同时隐藏了计算中涉及的一些输入或输出。一个例子是证明者试图证明数独可以被解决。
- en: ZKP as a field has grown tremendously since its early years. One major reason
    for this growth is the cryptocurrency boom and the need to provide more confidentiality
    to on-chain transactions as well as optimize on space. The field of ZKP is still
    growing extremely fast as of the time of this writing, and it is quite hard to
    follow what are all the modern schemes that exist and what types of general-purpose
    ZKPs there are.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 自其早期以来，ZKP作为一个领域已经有了巨大的增长。这种增长的一个主要原因是加密货币的繁荣以及对链上交易提供更多保密性以及优化空间的需求。截至撰写本文时，ZKP领域仍然以极快的速度增长，很难跟上现代方案的发展以及通用ZKPs的类型。
- en: Fortunately for us, this problem was getting large enough that it tripped the
    *standardization threshold*, an imaginary line that, when reached, almost always
    ends up motivating some people to work together towards a clarification of the
    field. In 2018, actors from the industry and academia joined together to form
    the ZKProof Standardization effort with the goal to “standardize the use of cryptographic
    zero-knowledge proofs.” To this day, it is still an ongoing effort. You can read
    more about it at [https://zkproof.org](https://zkproof.org).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题变得足够严重，已经触发了*标准化阈值*，一条虚拟线，一旦达到，几乎总是会激励一些人共同努力，以澄清该领域。2018年，来自行业和学术界的人士联合起来，成立了ZKProof标准化工作组，旨在“标准化使用加密零知识证明”。直至今日，这仍然是一个正在进行的工作。您可以在[https://zkproof.org](https://zkproof.org)上阅读更多信息。
- en: 'You can use general-purpose ZKPs in quite a lot of different situations, but
    to my knowledge, they have mostly been used in the cryptocurrency space so far,
    probably due to the high number of people interested in cryptography and willing
    to experiment with the bleeding edge stuff. Nonetheless, general-purpose ZKPs
    have potential applications in a lot of fields: identity management (being able
    to prove your own age without revealing it), compression (being able to hide most
    of a computation), confidentiality (being able to hide parts of a protocol), and
    so on. The biggest blockers for more applications to adopt general-purpose ZKPs
    seem to be the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在许多不同的情况下使用通用型ZKPs，但据我所知，迄今为止它们主要已被用于加密货币领域，可能是因为对密码学感兴趣并愿意尝试最前沿技术的人数众多。尽管如此，通用型ZKPs在许多领域都有潜在应用：身份管理（能够证明您的年龄而不暴露它）、压缩（能够隐藏大部分计算）、机密性（能够隐藏协议的某些部分）等等。更多应用采用通用型ZKPs的最大障碍似乎是以下几点：
- en: The large number of ZKP schemes and the fact that every year more schemes are
    being proposed.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量的ZKP方案以及每年都有更多方案被提出。
- en: The difficulty of grasping how these systems work and how to use them for specific
    use cases.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解这些系统如何工作以及如何将它们用于特定用例的困难。
- en: 'Distinctions between the different proposed schemes are quite important. Because
    it is a great source of confusion, here is how some of these schemes are divided:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不同提议方案之间的区别非常重要。由于这是一个极易引起混淆的来源，这是一些方案被分割的方式：
- en: '*Zero-knowledge or not*—If some of the information needs to remain secret from
    some of the participants, then we need zero-knowledgeness. Note that proofs without
    secrets can be useful as well. For example, you might want to delegate some intensive
    computation to a service that, in turn, has to prove to you that the result they
    provide is correct.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*零知识或非零知识*—如果某些信息需要对某些参与者保密，那么我们需要零知识性。注意，无秘密的证明也可能有用。例如，您可能想将一些密集计算委托给一个服务，而该服务又必须向您证明他们提供的结果是正确的。'
- en: '*Interactive or not*—Most ZKP schemes can be made non-interactive (sometimes
    using the Fiat-Shamir transformation I talked about in chapter 7), and protocol
    designers seem most interested in the non-interactive version of the scheme. This
    is because back-and-forth’s can be time consuming in protocols, but also because
    interactivity is sometimes not possible. So-called non-interactive proofs are
    often referred to as *NIZKs* for *non-interactive ZKPs*.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交互式或非交互式*—大多数ZKP方案可以变成非交互式的（有时使用我在第7章中讨论的Fiat-Shamir变换），而协议设计者似乎最感兴趣的是该方案的非交互式版本。这是因为在协议中来回传输的信息可能会耗费时间，但也因为有时交互性可能不可行。所谓的非交互式证明通常被称为*NIZKs*，代表*非交互式ZKPs*。'
- en: '*Succinct proofs or not*—Most of the ZKP schemes in the spotlight are often
    referred to as *zk-SNARKs* for *Zero-Knowledge Succinct Non-Interactive Argument
    of Knowledge*. While the definition can vary, it focuses on the size of the proofs
    produced by such systems (usually in the order of hundreds of bytes), and the
    amount of time needed to verify them (within the range of milliseconds). zk-SNARKs
    are, thus, short and easy to use to verify ZKPs. Note that a scheme not being
    a zk-SNARK does not disqualify it for the real world as often different properties
    might be useful in different use cases.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简洁证明或非简洁证明*—聚光灯下的大多数ZKP方案通常被称为*zk-SNARKs*，代表*零知识简洁非交互知识证明*。尽管定义可能有所不同，但它着重于这些系统生成的证明的大小（通常在数百字节的数量级），以及验证这些证明所需的时间（在毫秒级范围内）。zk-SNARKs因此简短且易于用于验证ZKPs。请注意，一个方案不是zk-SNARK并不意味着它在现实世界中无法使用，因为通常在不同的用例中可能有用的不同属性。'
- en: '*Transparent setup or not*—Like every cryptographic primitive, ZKPs need a
    setup to agree on a set of parameters and common values. This is called a *common
    reference string* (CRS). But setups for ZKPs can be much more limiting or dangerous
    than initially thought. There are three types of setup:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*透明的设置或不是*—像每个密码原语一样，ZKP需要一种设置来同意一组参数和公共值。这称为*共同参考字符串*（CRS）。但是，ZKP的设置可能比最初想象的限制或危险得多。有三种类型的设置：'
- en: '*Trusted*—Means that whoever created the CRS also has access to secrets that
    allow them to forge proofs (hence, it’s why these secrets are sometimes called
    “toxic waste”). This is quite an issue as we are back to having a trusted third
    party, yet schemes that exhibit this property are often the most efficient and
    have the shortest proof size. To decrease the risk, MPC can be use to have many
    participants help create these dangerous parameters. If a single participant is
    honest and deletes their keys after the ceremony, the toxic waste gets flushed.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可信任的*—意味着创建CRS的人也可以访问允许他们伪造证明的秘密（因此，这就是为什么这些秘密有时被称为“有毒废物”的原因）。这是一个相当严重的问题，因为我们又回到了需要信任的第三方，然而具有这种属性的方案通常是效率最高且证明大小最短的。为了降低风险，MPC可以用于让许多参与者帮助创建这些危险的参数。如果单个参与者是诚实的，并在典礼结束后删除他们的密钥，那么有毒废物就会被清除。'
- en: '*Universal*—A trusted setup is said to be universal if you can use it to prove
    the execution of any circuit (bounded by some size). Otherwise it is specific
    to a single circuit.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通用的*—如果信任的设置被称为通用，则您可以使用它来证明任何电路的执行（受某些大小限制）。否则它是特定于单个电路的。'
- en: '*Transparent*—Fortunately for us, many schemes also offer transparent setups,
    meaning that no trusted third party needs to be present to create the parameters
    of the system. Transparent schemes are by design universal.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*透明的*—对于我们来说，幸运的是，许多方案也提供透明的设置，这意味着不需要存在信任的第三方来创建系统的参数。透明的方案按设计是通用的。'
- en: '*Quantum-resistant or not*—Some ZKPs make use of public key cryptography and
    advanced primitives like bilinear pairings (which I’ll explain later), while others
    only rely on symmetric cryptography (like hash functions), which makes them naturally
    resistant to quantum computers (usually at the expense of much larger proofs).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*是否抗量子*—一些ZKP利用公钥加密和高级原语，如双线性配对（稍后我会解释），而另一些则仅依赖对称加密（如哈希函数），这使它们在本质上抗量子计算（通常以更大的证明为代价）。'
- en: Because zk-SNARKs are what’s up at the time of this writing, let me give you
    my perception as to how they work.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在撰写本文时，zk-SNARKs备受关注，让我向您解释一下它们的工作原理。
- en: 15.3.1 How zk-SNARKs work
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1 zk-SNARKs的工作原理
- en: 'First and foremost, there are many, many zk-SNARK schemes—too many of them,
    really. Most build on this type of construction:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有许多许多zk-SNARK方案—实际上有太多了。大多数都建立在这种类型的构造之上：
- en: A proving system, allowing a prover to prove something to a verifier.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个证明系统，允许证明者向验证者证明某些事情。
- en: A translation or compilation of a program to something the proving system can
    prove.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的翻译或编译为证明系统可以证明的东西。
- en: The first part is not too hard to understand, while the second part sort of
    requires a graduate course in the subject. To begin, let’s take a look at the
    first part.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分并不太难理解，而第二部分在某种程度上需要一个研究生课程的知识。首先，让我们来看看第一部分。
- en: The main idea of zk-SNARKs is that they are all about proving that you know
    some polynomial *f*(*x*) that has some roots. By roots I mean that the verifier
    has some values in mind (for example, 1 and 2) and the prover must prove that
    the secret polynomial they have in mind evaluates to 0 for these values (for example,
    *f*(1) = *f*(2) = 0). By the way, a polynomial that has 1 and 2 as roots (as in
    our example) can be written as *f*(*x*) = (*x* – 1)(*x* – 2)*h*(*x*) for some
    polynomial *h*(*x*). (If you’re not convinced, try to evaluate that at *x* = 1
    and *x* = 2.) We say that the prover must prove that they know an *f*(*x*) and
    *h*(*x*) such that *f*(*x*) = *t*(*x*)*h*(*x*) for some target polynomial *t*(*x*)
    = (*x* – 1)(*x* – 2). In this example, 1 and 2 are the roots that the verifier
    wants to check.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: zk-SNARKs的主要思想是证明您知道一些多项式*f*(*x*)具有一些根。根的意思是验证者心中有一些值（例如，1和2），证明者必须证明他们心中的秘密多项式对这些值（例如，*f*(1)
    = *f*(2) = 0）进行评估为0。顺便说一句，一个具有1和2作为根的多项式（如我们的例子）可以写为*f*(*x*) = (*x* – 1)(*x* –
    2)*h*(*x*)，其中*h*(*x*)是某个多项式。 （如果你不相信，请尝试在*x* = 1和*x* = 2处评估它。）我们说证明者必须证明他们知道一个*f*(*x*)和*h*(*x*)，使得*f*(*x*)
    = *t*(*x*)*h*(*x*)，其中*t*(*x*) = (*x* – 1)(*x* – 2)是目标多项式。在这个例子中，1和2是验证者想要检查的根。
- en: 'But that’s it! That’s what zk-SNARKs proving systems usually provide: something
    to prove that you know some polynomial. I’m repeating this because the first time
    I learned about that it made no sense to me. How can you prove that you know some
    secret input to a program if all you can prove is that you know a polynomial?
    Well, that’s why the second part of a zk-SNARK is so difficult. It’s about translating
    a program into a polynomial. But more on that later.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但就是这样！这就是zk-SNARKs证明系统通常提供的东西：证明你知道某些多项式。我再次强调这一点，因为我第一次了解这个概念时觉得很难理解。如果你只能证明你知道一个多项式，你怎么能证明你知道程序的某个秘密输入呢？好吧，这就是zk-SNARK的第二部分如此困难的原因。它涉及将程序转化为多项式。但稍后再详述。
- en: 'Back to our proving system, how does one prove that they know such a function
    *f*(*x*)? They have to prove that they know an *h*(*x*) such that you can write
    *f*(*x*) as *f*(*x*) = *t*(*x*)*h*(*x*). Ugh, ... not so fast here. We’re talking
    about *zero-knowledge* proofs right? How can we prove this without giving out
    *f*(*x*)? The answer is in the following three tricks:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的证明系统，如何证明他们知道这样一个函数*f*(*x*)？他们必须证明他们知道一个*h*(*x*)，使得你可以将*f*(*x*)写成*f*(*x*)
    = *t*(*x*)*h*(*x*)。啊，... 别那么快。我们说的是*零知识*证明，对吧？我们怎么能在不泄露*f*(*x*)的情况下证明这一点？答案就在以下三个技巧中：
- en: '*Homomorphic commitments*—A commitment scheme similar to the ones we used in
    other ZKPs (covered in chapter 7)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同态承诺*——类似于我们在其他零知识证明中使用的承诺方案（在第7章中讨论）'
- en: '*Bilinear pairings*—A mathematical construction that has some interesting properties;
    more on that later'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双线性配对*——一种具有一些有趣特性的数学构造；稍后详述'
- en: The fact that *different polynomials evaluate to different values most of the
    time*
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大多数情况下，不同的多项式求值不同*'
- en: So let’s go through each of these, shall we?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们逐个看看这些，好吗？
- en: 15.3.2 Homomorphic commitments to hide parts of the proof
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2 同态承诺以隐藏证明的部分
- en: The first trick is to use *commitments* to hide the values that we’re sending
    to the prover. But not only do we hide them, we also want to allow the verifier
    to perform some operations on them so that they can verify the proof. Specifically,
    they need to verify that if the prover commits on their polynomial *f*(*x*) as
    well as *h*(*x*), then we have
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个技巧是使用*承诺*来隐藏我们发送给证明者的值。但我们不仅要隐藏它们，还要允许验证者对它们执行一些操作，以便他们可以验证证明。具体来说，他们需要验证，如果证明者对他们的多项式*f*(*x*)以及*h*(*x*)进行承诺，那么我们就有
- en: '*com*(*f*(*x*)) = *com*(*t*(*x*)) *com*(*h*(*x*)) = *com*(*t*(*x*)*h*(*x*))'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*com*(*f*(*x*)) = *com*(*t*(*x*)) *com*(*h*(*x*)) = *com*(*t*(*x*)*h*(*x*))'
- en: 'where the commitment *com*(*t*(*x*)) is computed by the verifier as the agreed
    constraint on the polynomial. These operations are called *homomorphic operations*,
    and we couldn’t have performed them if we had used hash functions as commitment
    mechanisms (as mentioned in chapter 2). Thanks to these homomorphic commitments,
    we can “hide values in the exponent” (for example, for a value *v*, send the commitment
    *g*^v mod *p*) and perform useful identity checks:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中承诺*com*(*t*(*x*))由验证者计算为多项式上的约束。这些操作称为*同态操作*，如果我们使用哈希函数作为承诺机制（如第2章所述），我们无法执行这些操作。由于这些同态承诺，我们可以“隐藏指数中的值”（例如，对于值*v*，发送承诺*g*^v
    mod *p*）并执行有用的身份验证：
- en: The equality of commitments—The equality *g*^a = *g*^b means that *a* = *b*
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺的等式——等式*g*^a = *g*^b 意味着 *a* = *b*
- en: The addition of commitments—The equality *g*^a = *g*^b*g*^c means that *a* =
    *b* + *c*
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺的添加——等式*g*^a = *g*^b*g*^c 意味着 *a* = *b* + *c*
- en: The scaling of commitments—The equality *g*^a = (*g*^b)^c means that *a* = *bc*
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺的缩放——等式*g*^a = (*g*^b)^c 意味着 *a* = *bc*
- en: Notice that the last check only works if *c* is a public value and not a commitment
    (*gc*). With homomorphic commitments alone we can’t check the multiplication of
    commitments, which is what we needed. Fortunately, cryptography has another tool
    to get such equations hidden in the exponent—*bilinear pairings*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后一个检查只有在*c*是公共值而不是一个承诺（*gc*）时才有效。仅通过同态承诺，我们无法检查承诺的乘法，这正是我们所需的。幸运的是，密码学有另一个工具可以将这样的方程式隐藏在指数中——*双线性配对*。
- en: 15.3.3 Bilinear pairings to improve our homomorphic commitments
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3 双线性配对以改进我们的同态承诺
- en: Bilinear pairings can be used to unblock us, and this is the *sole reason* why
    we use bilinear pairings in a zk-SNARK (really, just to be able to multiply the
    values inside the commitments). I don’t want to go too deep into what bilinear
    pairings are, but just know that it is another tool in our toolkit that allows
    us to multiply elements that couldn’t be multiplied previously by moving them
    from one group to another.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 双线性配对可用于解除我们的阻碍，这是我们在 zk-SNARK 中使用双线性配对的**唯一原因**（真的，只是为了能够在承诺内部相乘的值）。我不想深入讨论什么是双线性配对，但只需知道它是我们工具箱中的另一个工具，允许我们将以前无法相乘的元素从一个群移到另一个群。
- en: 'Using *e* as the typical way of writing a bilinear pairing, we have *e*(*g*[1],
    *g*[2]) = *h*[3], where *g*[1], *g*[2], and *h*[3] are generators for different
    groups. Here, we’ll use the same generator on the left (*g*[1] = *g*[2]) which
    makes the pairing symmetric. We can use a bilinear pairing to perform multiplications
    hidden in the exponent via this equation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *e* 作为写双线性配对的典型方式，我们有 *e*(*g*[1], *g*[2]) = *h*[3]，其中 *g*[1]、*g*[2] 和 *h*[3]
    是不同群的生成器。在这里，我们将在左侧使用相同的生成器（*g*[1] = *g*[2]），这使得配对对称。我们可以使用双线性配对通过这个方程来执行指数中隐藏的乘法：
- en: '*e*(*g*^b, *g*^c) = *e*(*g*)^(bc)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*(*g*^b, *g*^c) = *e*(*g*)^(bc)'
- en: Again, we use bilinear pairings to make our commitments not only homomorphic
    for the addition, but also for the multiplication. (Note that this is not a fully
    homomorphic scheme as multiplication is limited to a single one.) Bilinear pairings
    are also used in other places in cryptography and are slowly becoming a more common
    building block. They can be seen in homomorphic encryption schemes and also signatures
    schemes like BLS (which I mentioned in chapter 8).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用双线性配对使得我们的承诺不仅对加法是同态的，而且对乘法也是同态的。（请注意，这不是一个完全同态的方案，因为乘法仅限于单个乘法。）双线性配对也用于密码学的其他地方，并且正在逐渐成为更常见的构建块。它们可以在同态加密方案中看到，也可以在像
    BLS（我在第 8 章提到的）这样的签名方案中看到。
- en: 15.3.4 Where does the succinctness come from?
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.4 紧凑性来自何处？
- en: Finally, the *succinctness* of zk-SNARKs comes from the fact that two functions
    that differ evaluate to different points most of the time. What does this mean
    for us? Let’s say that I don’t have a polynomial *f*(*x*) that really has the
    roots we’ve chosen with the verifier, this means that *f*(*x*) is not equal to
    *t*(*x*)*h*(*x*). Then, evaluating *f*(*x*) and *t*(*x*)*h*(*x*) at a random point
    *r* won’t return the same result *most of the time*. For almost all *r*, *f*(*r*)≠
    *t*(*r*)*h*(*r*). This is known as the *Schwartz-Zippel lemma*, which I illustrate
    in figure 15.12.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，zk-SNARK 的**紧凑性**来自于两个不同函数的评估大多数情况下会得到不同的点。这对我们意味着什么？假设我没有一个多项式 *f*(*x*)
    真正具有我们与验证者选择的根，这意味着 *f*(*x*) 不等于 *t*(*x*)*h*(*x*)。然后，在随机点 *r* 上评估 *f*(*x*) 和 *t*(*x*)*h*(*x*)
    不会大部分时间返回相同的结果。对于几乎所有的 *r*，*f*(*r*)≠ *t*(*r*)*h*(*r*)。这就是**Schwartz-Zippel 引理**，我在图
    15.12 中有所说明。
- en: '![](../Images/15_12.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15_12.jpg)'
- en: Figure 15.12 The Schwartz-Zippel lemma says that two different polynomials of
    degree *n* can intersect in at most *n* points. In other words, two different
    polynomials will differ in most points.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.12 Schwartz-Zippel 引理指出，两个不同的 *n* 次多项式最多可以在 *n* 个点相交。换句话说，两个不同的多项式在大多数点上会有所不同。
- en: 'Knowing this, it is enough to prove that *com*(*f*(*r*)) = *com*(*t*(*r*)*h*(*r*))
    for some random point *r*. This is why zk-SNARK proofs are so small: by comparing
    points in a group, you end up comparing much larger polynomials. But this is also
    the reason behind the trusted setup needed in most zk-SNARK constructions. If
    a prover knows the random point *r* that will be used to check the equality, then
    they can forge an invalid polynomial that will still verify the equality. So a
    trusted setup is about'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点，证明 *com*(*f*(*r*)) = *com*(*t*(*r*)*h*(*r*)) 对于某个随机点 *r* 就足够了。这就是为什么 zk-SNARK
    证明如此小的原因：通过比较群中的点，最终你会比较更大的多项式。但这也是大多数 zk-SNARK 构造中需要可信设置的原因。如果证明者知道将用于检查等式的随机点
    *r*，那么他们可以伪造一个无效的多项式，仍然会验证相等。因此，可信设置就是
- en: Creating a random value *r*
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机值 *r*
- en: Committing different exponentiations of *r* (for example, g, g^r, g^(*r*²),
    g^(*r*³), . . .) so that these values can be used by the prover to compute their
    polynomial without knowing the point *r*
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 承诺不同幂次的 *r*（例如，g, g^r, g^(*r*²), g^(*r*³)，等等），以便证明者可以计算他们的多项式而不知道点 *r*
- en: Destroying the value *r*
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁值 *r*
- en: Does the second point make sense? If my polynomial as the prover is *f*(*x*)
    = 3*x*² + *x* + 2, then all I have to do is compute (g^(*r*²))³ g^r g² to obtain
    a commitment of my polynomial evaluated at that random point *r* (without knowing
    *r*).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点有意义吗？如果我作为证明者的多项式是*f*(*x*) = 3*x*² + *x* + 2，那么我所要做的就是计算(g^(*r*²))³ g^r g²，以获得我在那个随机点*r*处评估的多项式的承诺（不知道*r*）。
- en: 15.3.5 From programs to polynomials
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.5 从程序到多项式
- en: 'So far, the constraints on the polynomial that the prover must find is that
    it needs to have some roots: some values that evaluate to 0 with our polynomial.
    But how do we translate a more general statement into a polynomial knowledge proof?
    Typical statements in cryptocurrencies, which are the applications currently making
    the most use of zk-SNARKs these days, are of the form:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，证明者必须找到的多项式的约束是它需要有一些根：一些用我们的多项式计算为0的值。但是我们如何将一个更一般的语句转换成多项式知识证明？目前最多使用zk-SNARKs的应用是加密货币，其中典型的语句的形式为：
- en: Prove that a value is in the range [0, 2^(64)] (this is called a range proof)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明一个值在范围[0, 2^(64)]内（这被称为范围证明）
- en: Prove that a (secret) value is included in some given (public) Merkle tree
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明一个（秘密）值包含在给定的（公开）Merkle树中
- en: Prove that the sum of some values is equal to the sum of some other values
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明某些值的和等于另一些值的和
- en: And so on
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依此类推
- en: 'And herein lies the difficult part. As I said earlier, converting a program
    execution into the knowledge of a polynomial is really hard. The good news is
    that I’m not going to tell you all about the details, but I’ll tell you enough
    to give you a sense of how things work. From there, you should be able to understand
    what are the parts that are missing from my explanation and fill in the gaps as
    you wish. What is going to happen next is the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是困难的部分所在。正如我之前所说，将程序执行转换为多项式的知识是非常困难的。好消息是我不会告诉你所有的细节，但我会告诉你足够让你了解事情的工作原理。从那里开始，你应该能够理解我解释中缺少的部分，并根据自己的需要填补缺漏。接下来将会发生以下事情：
- en: Our program will first get converted into an arithmetic circuit, like the ones
    we saw in the section on MPC.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的程序将首先被转换成算术电路，就像我们在MPC部分看到的那样。
- en: That arithmetic circuit will be converted into a system of equations that are
    of a certain form (called a rank-1 constraint system or R1CS).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个算术电路将被转换成一种特定形式的方程组（称为秩-1约束系统或R1CS）。
- en: We then use a trick to convert our system of equations into a polynomial.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用一个技巧将我们的方程组转换为一个多项式。
- en: 15.3.6 Programs are for computers; we need arithmetic circuits instead
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.6 程序适用于计算机；我们需要算术电路而不是
- en: 'First, let’s assume that almost any program can be rewritten more or less easily
    in math. The reason why we would want to do that should be obvious: we can’t prove
    code, but we can prove math. For example, the following listing provides a function
    where every input is public except for `a`, which is our secret input.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们假设几乎任何程序都可以更多或更少地轻松地用数学重写。为什么我们想这样做的原因应该是显而易见的：我们不能证明代码，但我们可以证明数学。例如，以下列表提供了一个函数，其中除了`a`是我们的秘密输入之外，每个输入都是公开的。
- en: Listing 15.1 A simple function
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.1 一个简单的函数
- en: '[PRE0]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this simple example, if every input and output is public except for `a`,
    one can still deduce what `a` is. This listing also serves as an example of what
    you shouldn’t try to prove in zero-knowledge. Anyway, the program can be rewritten
    in math with this equation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，如果除了`a`之外的每个输入和输出都是公开的，人们仍然可以推断出`a`是什么。这个列表也是一个例子，说明你不应该试图在零知识中证明什么。无论如何，该程序可以用以下方程重写成数学形式：
- en: '*w* × (*a* × (*b* + 3)) + (1 – *w*) × (*a* + *b*) = *v*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*w* × (*a* × (*b* + 3)) + (1 – *w*) × (*a* + *b*) = *v*'
- en: Where *v* is the output and *w* is either 0 (`false`) or 1 (`true`). Notice
    that this equation is not really a program or a circuit, it just looks like a
    constraint. If you execute the program correctly and then fill in the inputs and
    outputs obtained in the equation, the equality should be correct. If the equality
    is not correct, then your inputs and outputs don’t correspond to a valid execution
    of the program.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*v*是输出，*w*要么是0（`false`）要么是1（`true`）。请注意，这个方程实际上不是一个程序或电路，它只是一个约束条件。如果你正确执行程序，然后填写方程中得到的输入和输出，等式应该是正确的。如果等式不正确，那么你的输入和输出就不对应于程序的有效执行。
- en: This is how you have to think about these general-purpose ZKPs. Instead of executing
    a function in zero-knowledge (which doesn’t mean much really), we use zk-SNARKs
    to prove that some given inputs and outputs correctly match the execution of a
    program, even when some of the inputs or outputs are omitted.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你必须思考这些通用零知识证明的方式。我们不是在零知识中执行一个函数（实际上这并没有什么意义），而是使用zk-SNARKs来证明一些给定的输入和输出正确地匹配了程序的执行，即使其中一些输入或输出被省略了。
- en: 15.3.7 An arithmetic circuit to a rank-1 constraint system (R1CS)
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.7 从算术电路到rank-1约束系统（R1CS）
- en: In any case, we’re only one step into the process of converting our execution
    to something we can prove with zk-SNARKs. The next step is to convert that into
    a series of constraints, which then can be converted into proving the knowledge
    of some polynomial. What zk-SNARKs want is a *rank-1 constraint system* (R1CS).
    An R1CS is really just a series of equations that are of the form *L* × *R* =
    *O*, where *L*, *R*, and *O* can only be the addition of some variables, thus
    the only multiplication is between *L* and *R*. It really doesn’t matter why we
    need to transform our arithmetic circuit into such a system of equations except
    that it helps when doing the conversion to the final stuff we can prove. Try to
    do this with the equation we have and we obtain something like
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们只是将我们的执行转换为可以用zk-SNARKs证明的东西的过程中的一步。下一步是将其转换为一系列约束条件，然后可以将其转换为证明某个多项式的知识。zk-SNARKs想要的是*rank-1约束系统*（R1CS）。一个R1CS实际上只是一系列形式为*L*
    × *R* = *O*的方程，其中*L*、*R*和*O*只能是一些变量的加法，因此唯一的乘法是在*L*和*R*之间。我们为什么需要将我们的算术电路转换为这样的方程系统其实并不重要，除了在将其转换为最终可以证明的东西时会有所帮助。尝试用我们的方程做这个，我们得到的东西就像是
- en: '*a* × (*b* + 3) = *m*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a* × (*b* + 3) = *m*'
- en: '*w* × (*m* – *a* – *b*) = *v* – *a* – *b*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*w* × (*m* – *a* – *b*) = *v* – *a* – *b*'
- en: 'We actually forgot the constraint that *w* is either 0 or 1, which we can add
    to our system via a clever trick:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上忘记了*w*只能是0或1的约束条件，我们可以通过一个巧妙的技巧来将其添加到我们的系统中：
- en: '*a* × (*b* + 3) = *m*'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a* × (*b* + 3) = *m*'
- en: '*w* × (*m* – *a* – *b*) = *v* – *a* – *b*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*w* × (*m* – *a* – *b*) = *v* – *a* – *b*'
- en: '*w* × *w* = *w*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*w* × *w* = *w*'
- en: 'Does that make sense? You should really see this system as a set of constraints:
    if you give me a set of values that you claim match the inputs and outputs of
    the execution of my program, then I should be able to validate that the values
    also correctly verify the equalities. If one of the equalities is wrong, then
    it must mean that the program does not output the value you gave me for the inputs
    you gave me. Another way to think about it is that zk-SNARKs allow you to verifiably
    remove inputs or outputs of the transcript of the correct execution of a program.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有意义吗？你真的应该将这个系统看作一组约束条件：如果你给我一组值，声称这些值与我程序的输入和输出匹配，那么我应该能够验证这些值也正确地验证了等式。如果其中一个等式是错误的，那么这必须意味着该程序没有输出你给我的这些输入的值。另一种思考方式是，zk-SNARKs允许你可验证地删除程序正确执行的传输的输入或输出。
- en: 15.3.8 From R1CS to a polynomial
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.8 从R1CS到多项式
- en: 'The question is still: how do we transform this system into a polynomial? We’re
    almost there, and as always the answer is with a series of tricks! Because we
    have three different equations in our system, the first step is to agree on three
    roots for our polynomial. We can simply choose 1, 2, 3 as roots, meaning that
    our polynomial solves *f*(*x*) = 0 for *x* = 1, *x* = 2, and *x* = 3\. Why do
    that? By doing so, we can make our polynomial represent all the equations in our
    system simultaneously by representing the first equation when evaluated at 1,
    and representing the second equation when evaluated at 2, and so on. The prover’s
    job is now to create a polynomial *f*(*x*) such that:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 问题仍然是：我们如何将这个系统转化为一个多项式？我们已经快要完成了，而且一如既往的答案是通过一系列的技巧！因为我们的系统中有三个不同的方程，第一步是为我们的多项式确定三个根。我们可以简单地选择1、2、3作为根，这意味着我们的多项式对*x*
    = 1、*x* = 2和*x* = 3都解出了*f*(*x*) = 0。为什么这样做？通过这样做，我们可以使我们的多项式同时代表我们系统中的所有方程，通过在1处求值时代表第一个方程，在2处求值时代表第二个方程，依此类推。现在验证者的工作是创建一个多项式*f*(*x*)，使得：
- en: '*f*(1) = *a* × (*b* + 3) – *m*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f*(1) = *a* × (*b* + 3) – *m*'
- en: '*f*(2) = *w* × (*m* – *a* – *b*) – (*v* – *a* – *b*)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f*(2) = *w* × (*m* – *a* – *b*) – (*v* – *a* – *b*)'
- en: '*f*(3) = *w* × *w* – *w*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f*(3) = *w* × *w* – *w*'
- en: 'Notice that all these equations should evaluate to 0 if the values correctly
    match the execution of our original program. In other words, our polynomial *f*(*x*)
    has roots 1, 2, 3 only if we create it correctly. Remember, this is what zk-SNARKs
    are all about: we have the protocol to prove that, indeed, our polynomial *f*(*x*)
    has these roots (known by both the prover and the verifier).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果这些方程的值正确匹配我们原始程序的执行，所有这些方程应该评估为0。换句话说，我们的多项式*f*(*x*)只有在我们正确创建它时才有根1、2、3。记住，这就是zk-SNARK的全部意义：我们有协议来证明，确实，我们的多项式*f*(*x*)有这些根（由证明者和验证者都知道）。
- en: It would be too simple if this was the end of my explanation because now the
    problem is that the prover has too much freedom in choosing their polynomial *f*(*x*).
    They can simply find a polynomial that has roots 1, 2, 3 without caring about
    the values *a*, *b*, *m*, *v*, and *w*. They can do pretty much whatever they
    want! What we want instead, is a system that locks every part of the polynomial
    except for the secret values that the verifier must *not* learn about.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的解释到此为止就太简单了，因为现在的问题是证明者在选择他们的多项式*f*(*x*)时有太多的自由。他们可以简单地找到一个具有根1、2、3的多项式，而不关心值*a*、*b*、*m*、*v*和*w*。他们可以做任何他们想做的事情！相反，我们想要的是一个系统，锁定多项式的每个部分，除了验证者必须*不*了解的秘密值。
- en: 15.3.9 It takes two to evaluate a polynomial hiding in the exponent
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.9 两个人评估隐藏在指数中的多项式
- en: 'Let’s recap, we want a prover that has to correctly execute the program with
    their secret value *a* and the public values *b* and *w* and obtain the output
    *v* that they can publish. The prover then must create a polynomial by only filling
    the parts that the verifier must not learn about: the values *a* and *m*. Thus,
    in a real zk-SNARK protocol you want the prover to have the least amount of freedom
    possible when they create their polynomials and then evaluate it to a random point.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下，我们希望一个证明者必须使用他们的秘密值*a*和公共值*b*和*w*正确执行程序，并获得他们可以发布的输出*v*。然后，证明者必须创建一个多项式，只填写验证者不应该了解的部分：值*a*和*m*。因此，在一个真正的zk-SNARK协议中，当证明者创建他们的多项式并将其评估到一个随机点时，你希望证明者在创建他们的多项式时拥有尽可能少的自由。
- en: To do this, the polynomial is created somewhat dynamically by having the prover
    only fill in their part, then having the verifier fill in the other parts. For
    example, let’s take the first equation, *f*(1) = *a* × (*b* + 3) – *m*, and represent
    it as
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，多项式是通过让证明者只填写他们的部分而在一定程度上动态地创建的，然后让验证者填写其他部分。例如，让我们以第一个方程为例，*f*(1) =
    *a* × (*b* + 3) – *m*，表示为
- en: '*f*[1](*x*) = *aL*[1](*x*) × (*b* + 3)*R*[1](*x*) – *mO*[1](*x*)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*[1](*x*) = *aL*[1](*x*) × (*b* + 3)*R*[1](*x*) – *mO*[1](*x*)'
- en: 'where *L*[1](*x*), *R*[1](*x*), *O*[1](*x*) are polynomials that evaluate to
    1 for *x* = 1 and to 0 for *x* = 2 and *x* = 3\. This is necessary so that they
    only influence our first equation. (Note that it is easy to find such polynomials
    via algorithms like Lagrange interpolation.) Now, notice two more things:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*L*[1](*x*)、*R*[1](*x*)、*O*[1](*x*)是多项式，当*x* = 1时评估为1，当*x* = 2和*x* = 3时评估为0。这是必要的，以便它们只影响我们的第一个方程。（请注意，通过拉格朗日插值等算法很容易找到这样的多项式。）现在，请注意另外两点：
- en: We have the inputs, intermediate values, and outputs as coefficients of our
    polynomials.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的多项式的系数是输入、中间值和输出。
- en: The polynomial *f*(*x*) is the sum *f*[1](*x*) + *f*[2](*x*) + *f*[3](*x*),
    where we can define *f*[2](*x*) and *f*[3](*x*) to represent equations 2 and 3,
    similarly to *f*[1](*x*).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式*f*(*x*)是和 *f*[1](*x*) + *f*[2](*x*) + *f*[3](*x*)的总和，其中我们可以定义*f*[2](*x*)和*f*[3](*x*)来表示方程2和3，类似于*f*[1](*x*)。
- en: 'As you can see, our first equation is still represented at the point *x* =
    1:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的第一个方程仍然在点*x* = 1处表示：
- en: '*f*(1) = *f*[1](1) + *f*[2](1) + *f*[3](1)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(1) = *f*[1](1) + *f*[2](1) + *f*[3](1)'
- en: = *f*[1](1)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: = *f*[1](1)
- en: = *aL*[1](1) × (*b* + 3)*R*[1](1) – *mO*[1](1)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: = *aL*[1](1) × (*b* + 3)*R*[1](1) – *mO*[1](1)
- en: = *a* × (*b* + 3) – *m*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: = *a* × (*b* + 3) – *m*
- en: 'With this new way of representing our equations (which remember, represent
    the execution of our program), the prover can now evaluate parts of the polynomial
    that are relevant to them by:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种新的表示方程的方式（记住，表示我们程序执行的方程），证明者现在可以通过以下方式评估与他们相关的多项式的部分：
- en: Taking the exponentiation of the random point *r* hidden in the exponent to
    reconstruct the polynomials *L*[1](*r*) and *O*[1](*r*)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对隐藏在指数中的随机点*r*进行指数运算，以重构多项式*L*[1](*r*)和*O*[1](*r*)
- en: Exponentiating g^(L[1](r)) with the secret value *a* to obtain (g^(L[1](r)))^a
    = g^(aL[1](r)), which represents *a* × *L*[1](*x*) that is evaluated at an unknown
    and random point *x* = *r* and hidden in the exponent
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对秘密值*a*进行指数运算g^(L[1](r))以获得(g^(L[1](r)))^a = g^(aL[1](r))，表示*a* × *L*[1](*x*)在未知且随机点*x*
    = *r*处的评估，并隐藏在指数中。
- en: Exponentiating g^(O[1](r)) with the secret intermediate value *m* to obtain
    (g^(O[1](r)))^m = g^(mO[1](r)), which represents the evaluation of *mO*[1](*x*)
    at the random point *r* and hidden in the exponent
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对秘密中间值*m*进行指数运算g^(O[1](r))以获得(g^(O[1](r)))^m = g^(mO[1](r))，表示在随机点*r*处评估*mO*[1](*x*)，并隐藏在指数中。
- en: 'The verifier can then fill in the missing parts by reconstructing (g^(R[1](r)))^b
    and (g^(R[0](r)))³ for some agreed on value *b* with the same techniques the prover
    used. Adding the two together the verifier obtains g^(bR[1](r)) + g^(3R[1](r)),
    which represents the (hidden) evaluation of (*b* + 3) × *R*[1](*x*) at an unknown
    and random point *x* = *r*. Finally, the verifier can reconstruct *f*[1](*r*),
    which is hidden in the exponent, by using a bilinear pairing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者可以通过使用与证明者相同的技术，重建(g^(R[1](r)))^b和(g^(R[0](r)))³来填补缺失的部分，其中*b*是一个已同意的值。将两者相加，验证者得到g^(bR[1](r))
    + g^(3R[1](r))，表示在未知且随机点*x* = *r*处(*b* + 3) × *R*[1](*x*)的（隐藏）评估。最后，验证者可以通过使用双线性配对重建隐藏在指数中的*f*[1](*r*)：
- en: e(g^(aL[1](r)), g^((b+3)R[1](r))) – e(g, g^(mO[1](r))) = e(g, g)^(aL[1](r))
    × (b + 3)R[1](r) – mO[1](r)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: e(g^(aL[1](r)), g^((b+3)R[1](r))) – e(g, g^(mO[1](r))) = e(g, g)^(aL[1](r))
    × (b + 3)R[1](r) – mO[1](r)
- en: If you extrapolate these techniques to the whole polynomial *f*(*x*), you can
    figure out the final protocol. Of course, this is still a gross simplification
    of a real zk-SNARK protocol; this still leaves way too much power to the prover.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将这些技术推广到整个多项式*f*(*x*)，你可以了解最终的协议。当然，这仍然是对真实zk-SNARK协议的严重简化；这仍然给证明者留下了太多的权力。
- en: 'All the other tricks used in zk-SNARKs are meant to further restrict what the
    prover can do, ensuring that they correctly and consistently fill in the missing
    parts as well as optimizing what can be optimized. By the way, the best explanation
    I’ve read is the paper, “Why and How zk-SNARK Works: Definitive Explanation” by
    Maksym Petkus, which goes much more in depth and explains all of the parts that
    I’ve overlooked.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: zk-SNARKs中使用的所有其他技巧都旨在进一步限制证明者的行为，确保他们正确且一致地填补缺失的部分，并优化可以优化的部分。顺便说一句，我读过的最好的解释是Maksym
    Petkus的论文《zk-SNARK为什么以及如何工作：权威解释》，该论文深入探讨了我忽视的所有部分。
- en: And that’s it for zk-SNARKs. This is really just an introduction; in practice,
    zk-SNARKs are much more complicated to understand and use! Not only is the amount
    of work to convert a program into something that can be proven nontrivial, it
    sometimes adds new constraints on a cryptography protocol. For example, the mainstream
    hash functions and signature schemes are often too heavy-duty for general-purpose
    ZKP systems, which has led many protocol designers to investigate different ZKP-friendly
    schemes. Furthermore, as I said earlier, there are many different zk-SNARKs constructions,
    and there are also many different non-zk-SNARKs constructions, which might be
    more relevant as general-purpose ZKP constructions depending on your use case.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是zk-SNARKs的全部内容。这实际上只是一个介绍；在实践中，了解和使用zk-SNARKs要复杂得多！将程序转换为可被证明的东西的工作量不仅仅是非平凡的，有时还会对密码协议添加新的约束。例如，主流的哈希函数和签名方案通常对于通用ZKP系统来说过于重型，这导致许多协议设计者研究了不同的ZKP友好方案。此外，正如我之前所说的，有许多不同的zk-SNARKs构造，还有许多不同的非zk-SNARKs构造，根据您的用例，后者可能更相关作为通用ZKP构造。
- en: But, unfortunately, no one-size-fits-all ZKP scheme seems to exist (for example,
    a ZKP scheme with a transparent setup, succinct, universal, and quantum-resistant),
    and it is not clear which one to use in which cases. The field is still young,
    and every year new and better schemes are being published. It might be that a
    few years down the line better standards and easy-to-use libraries will surface,
    so if you’re interested in this space, keep watching!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并不存在一种大小适合所有的ZKP方案（例如，具有透明设置、简洁、通用和抗量子的ZKP方案），目前尚不清楚在哪些情况下使用哪种方案。该领域仍然很年轻，每年都会发布新的更好的方案。也许几年后会出现更好的标准和易于使用的库，所以如果你对这个领域感兴趣，继续关注吧！
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In the last decade, many theoretical cryptographic primitives have made huge
    progress in terms of efficiency and practicality; some are making their way into
    the real world.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过去的十年中，许多理论密码学原语在效率和实用性方面取得了巨大进步；其中一些正在逐渐走向现实世界。
- en: Secure multi-party computation (MPC) is a primitive that allows multiple participants
    to correctly execute a program together, without revealing their respective inputs.
    Threshold signatures are starting to be adopted in cryptocurrencies, while private
    set intersection (PSI) protocols are being used in modern and large-scale protocols
    like Google’s Password Checkup.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全多方计算（MPC）是一种原语，允许多个参与者共同正确执行程序，而不暴露各自的输入。阈值签名正在开始在加密货币中被采用，而私密集合交集（PSI）协议正在被用于现代和大规模协议，如谷歌的密码检查。
- en: Fully homomorphic encryption (FHE) allows one to compute arbitrary functions
    on encrypted data without decrypting it. It has potential applications in the
    cloud, where it could prevent access to the data to anyone but the user while
    still allowing the cloud platform to perform useful computation on the data for
    the user.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全同态加密（FHE）允许在不解密的情况下对加密数据进行任意函数计算。它在云中具有潜在应用，可以防止除用户之外的任何人访问数据，同时允许云平台对数据进行用户有用的计算。
- en: General-purpose zero-knowledge proofs (ZKPs) have found many use cases, and
    have had recent breakthroughs with small proofs that are fast to verify. They
    are mostly used in cryptocurrencies to add privacy to or to compress the size
    of the blockchain. Their use cases seem broader, though, and as better standards
    and easier-to-use libraries make their way into the real world, we might see them
    being used more and more.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用零知识证明（ZKPs）已经找到了许多用例，并且在快速验证小证明方面取得了最近的突破。它们主要用于加密货币，以增加隐私或压缩区块链的大小。然而，它们的用例似乎更广泛，随着更好的标准和更易于使用的库进入现实世界，我们可能会看到它们被越来越广泛地使用。
