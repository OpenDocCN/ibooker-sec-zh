- en: 9 Fractionation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 分数化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The Polybius square
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Polybius方阵
- en: Splitting a letter into smaller parts, such as bits or hexadecimal digits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一封信拆分成较小的部分，如比特或十六进制数字
- en: Mixing and recombining those parts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合和重新组合这些部分
- en: The first two basic tools of cryptography are substitution and transposition,
    which are covered in chapters 5 through 8\. The third fundamental element of cryptography
    is fractionation. This means breaking the normal units of language, letters, syllables
    and words into smaller units and operating on those units. The smaller units are
    commonly bits, decimal digits, hexadecimal digits, or digits in other number bases.
    This chapter covers fractionation using digits in bases 2, 3, 5, 6, and 16, plus
    some other forms of fractionation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学的前两个基本工具是替换和置换，这些内容涵盖在第5至8章。密码学的第三个基本元素是分数化。这意味着将语言的正常单位，即字母、音节和单词，拆分为较小的单位并对这些单位进行操作。较小的单位通常是比特、十进制数字、十六进制数字或其他进制的数字。本章涵盖了使用2、3、5、6和16进制的数字进行分数化，以及其他形式的分数化。
- en: 9.1 Polybius square
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 Polybius方阵
- en: Possibly the oldest method for representing letters as smaller units is the
    *Polybius Square*, which we saw in section 4.4\. Here each letter is represented
    by two base-5 digits, making 25 possible 2-digit combinations. (The Greeks did
    not have a representation for 0, so their digits started at 1.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是将字母表示为较小单位的最古老方法是*Polybius方阵*，我们在第4.4节中看到过。在这里，每个字母由两个基数5位数字表示，共有25种可能的2位数字组合。（希腊人没有0的表示，因此他们的数字从1开始。）
- en: Here is the Polybius square from section 4.4\. Each letter is represented by
    its *coordinates* in the square, that is, by its row and column numbers. For example,
    the letter P is on row 2 in column 5, so it is represented as 25\. When needed
    for clarity this can also be written as 2,5.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第4.4节的Polybius方阵。每个字母都用方阵中的*坐标*表示，即通过其行号和列号表示。例如，字母P在第2行第5列，因此表示为25。需要时，为了清晰起见，也可以写成2,5。
- en: '![9-unnumb-1](../Images/9-unnumb-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-1](../Images/9-unnumb-1.png)'
- en: A Polybius square by itself can produce a number of different ciphers. For example,
    it can produce a simple substitution by replacing each letter in a message by
    the letter to the right in the square (U becomes **V**), or below (U becomes **Z**),
    or below and to the right (U becomes **S**) or left (U becomes **P**), and so
    forth. This idea can be extended to a polyalphabetic cipher by changing directions,
    say right, left, down, right, left, down, etc. You can also go 2 letters away
    or use knight moves, as in chess.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Polybius方阵本身可以产生多种不同的密码。例如，它可以通过用方阵中右边的字母（U变成**V**）、下面的字母（U变成**Z**）、下面和右边的字母（U变成**S**）或左边的字母（U变成**P**）等方式产生简单的替换。这个想法可以通过改变方向来扩展为多表密码，比如向右、向左、向下、向右、向左、向下等。你也可以走2个字母的距离或使用象棋中的骑士走法。
- en: A Polybius square can also be used to produce a *Polybius Ripple* cipher. Begin
    by replacing each letter of the message by its coordinates, simply written out
    in one line. Starting with the second number in this list, add the previous number
    to the current number. If the sum is more than 5, subtract 5 to keep the numbers
    in the range 1 to 5\. Then turn these numbers back into letters using the Polybius
    square again.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Polybius方阵也可以用于生成*Polybius Ripple*密码。首先，将消息中的每个字母替换为其坐标，简单地写在一行中。从此列表中的第二个数字开始，将前一个数字加到当前数字上。如果总和超过5，减去5以保持数字在1到5的范围内。然后再次使用Polybius方阵将这些数字转换回字母。
- en: '![9-unnumb-2](../Images/9-unnumb-2.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-2](../Images/9-unnumb-2.png)'
- en: The Polybius ripple cipher is rated Three. The cipher can be strengthened by
    using a different Polybius square for converting the coordinates back to letters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Polybius涟漪密码评级为三。通过使用不同的Polybius方阵将坐标转换回字母，可以加强密码。
- en: Let’s look at a few hand ciphers from the 1800s based on the Polybius square
    in sections 9.2 to 9.7\. I cover some additional hand methods in sections 9.8
    to 9.11\. Then I discuss some computer methods in the rest of the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下基于Polybius方阵的几种手写密码，涵盖在第9.2至9.7节。我在第9.8至9.11节中介绍了一些额外的手写方法。然后我在本章的其余部分讨论了一些计算机方法。
- en: 9.2 Playfair
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 Playfair
- en: The *Playfair* cipher was invented by Charles Wheatstone (pronounced WHIT-stun)
    in 1854\. Wheatstone is well-known among electrical engineers as the inventor
    of the Wheatstone bridge, which measures electrical resistance. Wheatstone and
    William Cooke invented the needle telegraph several years before Samuel Morse
    invented his key telegraph. Cooke commercialized the needle telegraph in England
    years before Morse began his telegraph company in the US.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*普莱费尔*密码是由查尔斯·维特斯通（发音为WHIT-stun）于1854年发明的。维特斯通在电气工程师中以发明维特斯通电桥而闻名，该电桥用于测量电阻。维特斯通和威廉·库克在塞缪尔·摩尔斯发明他的键式电报几年前就发明了指针电报。库克在英格兰商业化了指针电报，比摩尔斯在美国成立电报公司早了几年。'
- en: Wheatstone’s cipher is called the Playfair cipher because it was Wheatstone’s
    look-alike friend Baron Lyon Playfair (both had bright red hair and stood about
    5'2'') who advocated for its use and convinced the British Foreign Office to use
    the cipher for diplomatic communications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 维特斯通的密码被称为普莱费尔密码，因为维特斯通的长相类似的朋友利昂·普莱费尔男爵（两人都有红头发，身高约5'2''）主张使用它，并说服英国外交部在外交通信中使用该密码。
- en: Historical aside
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 历史插曲
- en: Since this cipher was not called the Wheatstone cipher, that left the Wheatstone
    name available for a second cipher that Wheatstone invented circa 1860 and exhibited
    at the Paris Exposition Universelle in 1867\. The Wheatstone Cryptograph, which
    resembled a large pocket watch, consisted of two stationary concentric rings made
    of stiff cardboard and two moveable clock hands connected by a simple clockwork
    mechanism. The inner ring was erasable, and could be changed for each message.
    This ring had the 26-letter alphabet in scrambled order, while the outer ring
    had the standard 26-letter alphabet plus a blank, making 27 positions. You move
    the long clock hand to indicate the plaintext letter on the outer ring, and the
    short hand moves to indicate the ciphertext letter on the inner ring. When the
    long clock hand completes one revolution of 27 positions, the short hand also
    moves 27 positions, which is 1 complete revolution plus 1 extra letter position.
    So the short hand starts from a different point on each revolution. An equivalent
    device with moveable rings and no hands had been produced by Col. Decius Wadsworth,
    chief of ordnance, in 1817, based on plans made by Thomas Jefferson in 1790, but
    it is Wheatstone’s name that is forever associated with this concept.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个密码并不被称为维特斯通密码，这使得维特斯通的名字可以用于他大约在1860年发明并在1867年巴黎世界博览会上展示的第二个密码。维特斯通密码机看起来像一个大口袋手表，由两个固定的硬纸板同心圆环和两个可移动的时钟指针组成，通过简单的钟表机制连接。内环可擦拭，每条消息都可以更改。这个环上有乱序的26个字母表，而外环有标准的26个字母表加一个空格，共27个位置。您将长时钟指针移动到外环上的明文字母位置，短指针移动到内环上的密文字母位置。当长时钟指针完成27个位置的一次旋转时，短指针也会移动27个位置，即完成一次完整的旋转再加上1个额外的字母位置。因此，短指针在每次旋转时都从不同的位置开始。相当于具有可移动环而没有指针的设备于1817年由军械长德西厄斯·沃兹沃斯制造，该设备基于托马斯·杰斐逊于1790年制定的计划，但维特斯通的名字永远与这个概念联系在一起。
- en: Photo provided by Ralph Simpson. The inscription reads
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由拉尔夫·辛普森提供。铭文如下
- en: “The Cryptograph. C. Wheatstone Inv^r.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “密码学。C.维特斯通Inv^r。”
- en: '![9-unnumb-3](../Images/9-unnumb-3.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-3](../Images/9-unnumb-3.png)'
- en: The Playfair cipher is based on the Polybius square, and enciphers two letters
    at a time. That is, it enciphers bigrams. The square can be prepared by mixing
    the alphabet using any of the methods of section 5.2\. One low-frequency letter
    of the alphabet such as J, Q or Z is omitted to make the alphabet fit into a 5×5
    square. (In French, J, Q and Z are common, so omit W. In German, omit Q, X or
    Y.) When the omitted letter occurs in the message, some other letter is chosen
    to replace it. In our case each J is replaced by an **I**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 普莱费尔密码基于波利比奥斯方阵，每次加密两个字母。也就是说，它加密的是双字母组。方阵可以通过使用第5.2节中的任何方法混合字母来准备。为了使字母适应5×5方阵，会省略一个低频字母，如J、Q或Z。（在法语中，J、Q和Z很常见，所以省略W。在德语中，省略Q、X或Y。）当省略的字母出现在消息中时，会选择其他字母替换它。在我们的例子中，每个J都被**I**替换。
- en: The next step is to divide the message into bigrams, for example ME ET ME TO
    MO RR OW. If a bigram is a double letter, this should be broken up, typically
    by inserting an X in the middle. (This is a good reason not to omit X from the
    square.) Also, if the message contains an odd number of letters, an X is added
    at the end. The message becomes ME ET ME TO MO RX RO WX. Now we are ready to encipher
    it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将信息分成二元素，例如ME ET ME TO MO RR OW。如果一个二元素是双字母的，则应该将其分开，通常是通过在中间插入一个X来实现。（这是不应该从方块中省略X的一个很好的理由。）另外，如果消息包含奇数个字母，则在末尾添加一个X。消息变为ME
    ET ME TO MO RX RO WX。现在我们准备好加密它了。
- en: 'Playfair has 3 rules: (1) if the two letters are on the same row, each letter
    is replaced by the letter to its right; (2) if the letters are in the same column,
    each letter is replaced by the letter below it; (3) for all other letters, each
    letter is replaced by the letter in the same row, but in the column of the other
    letter of the bigram. It is understood that the square wraps around, so in the
    square in section 9.1, the letter to the right of Y is U, and the letter below
    Q is W.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 普莱菲尔有3条规则：（1）如果两个字母位于同一行，则每个字母都被其右侧的字母替换；（2）如果字母位于同一列，则每个字母都被其下方的字母替换；（3）对于所有其他字母，每个字母都被二元素的另一个字母所在的同一行中的字母替换。理解方块环绕，因此在第9.1节的方块中，Y的右侧字母是U，Q下方的字母是W。
- en: These rules can be restated in terms of the coordinates. Let the bigram we wish
    to encipher be r1c1 r2c2, so that the first letter is on row r1 in column c1 and
    the second letter is on row r2 in column c2\. Now the 3 rules become
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则可以用坐标来重新表述。让我们要加密的二元素是r1c1 r2c2，因此第一个字母在第r1行第c1列，第二个字母在第r2行第c2列。现在这3条规则变为
- en: If r1 = r2 then substitute r1,c1+1 r2,c2+1.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果r1 = r2，那么将替换为r1，c1+1 r2，c2+1。
- en: If c1 = c2 then substitute r1+1,c1 r2+1,c2.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果c1 = c2，那么将替换为r1+1，c1 r2+1，c2。
- en: Otherwise substitute r1,c2 r2,c1.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则替换为r1，c2 r2，c1。
- en: Let’s encipher our sample message ME ET ME TO MO RX RO WX and see how these
    rules work. The first bigram is ME. M and E are in different rows and different
    columns so Rule 3 applies. M is in row 2 column 4 and E is in row 3 column 2\.
    So M gets replaced by the letter in the same row, namely row 2, in the same column
    as the letter E, namely column 2\. The letter in row 2 column 2 is S, so M is
    replaced by **S**. Likewise, E is replaced by the letter in row 3 column 4, namely
    **C**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的样本信息ME ET ME TO MO RX RO WX进行加密，看看这些规则是如何起作用的。第一个二元素是ME。M和E位于不同的行和不同的列，因此适用规则3。M位于第2行第4列，E位于第3行第2列。因此，M被替换为同一行的字母，即第2行，与字母E相同的列，即第2列。第2行第2列的字母是S，所以M被替换为**S**。同样，E被替换为第3行第4列的字母，即**C**。
- en: In the same way ET is replaced by **DO**, and the second ME is replaced by **SC**.
    The letters T and O are in the same row, so Rule 1 applies. They are replaced
    by the letters to their right. T gets replaced by **N** and O gets replaced by
    **Q**. So TO is replaced by **NQ**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，ET被**DO**替换，第二个ME被**SC**替换。字母T和O位于同一行，因此适用规则1。它们被替换为其右侧的字母。T被**N**替换，O被**Q**替换。所以TO被替换为**NQ**。
- en: MO goes by Rule 3\. It is replaced by **SR**. R and X are in the same column
    so Rule 2 applies. RX is replaced by **XM**. RO and WX both use Rule 1 and are
    replaced by **TQ** and **XY**. The entire message thus becomes **SC DO SC NQ SR
    XM TQ XY**, which is **SCDOS CNQSR XMTQX Y** after regrouping.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MO按照规则3进行。它被替换为**SR**。R和X位于同一列，因此适用规则2。RX被替换为**XM**。RO和WX都使用规则1，被替换为**TQ**和**XY**。因此整个消息变为**SC
    DO SC NQ SR XM TQ XY**，在重新分组后变为**SCDOS CNQSR XMTQX Y**。
- en: Here are some diagrams to help you visualize how the bigrams LY, TO and RX are
    enciphered.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些图表可以帮助你形象化地理解大二元素LY、TO和RX是如何被加密的。
- en: '![9-unnumb-4](../Images/9-unnumb-4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-4](../Images/9-unnumb-4.png)'
- en: The Playfair cipher remained in military and diplomatic use until at least 1960\.
    Next, let’s take a brief look at how a Playfair cipher can be solved.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 普莱菲尔密码一直被军事和外交用途使用，至少持续到1960年。接下来，让我们简要地看一下普莱菲尔密码如何被解密。
- en: 9.2.1 Solving a Playfair cipher
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 解密普莱菲尔密码
- en: Notice that each letter can be enciphered by only 5 possible substitutes, namely
    the 4 other letters on its row and the letter immediately below it. For each letter
    there are 24 other letters in the grid. Of these, only the 4 letters in its own
    column will cause the letter to be replaced by the letter below it. So the chance
    of a letter being replaced by the letter below is 4/24, or 1/6\. The chance that
    it is replaced by another letter on its row is therefore 5/6.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Since there are 5 rows in the square and 9 English letters with frequencies
    over 5% there must be several rows that contain at least 2 high-frequency letters.
    If there are fewer than 4 such rows, then there must be at least one row with
    3 high-frequency letters. The other letters on these rows will appear more frequently
    in the ciphertext than any other letters. If you have sufficient ciphertext there
    is a good chance that the 3 to 5 most frequent letters in the ciphertext appear
    on the same row in the square.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: If we remove all of the bigrams containing these letters, the 3 to 5 most frequent
    letters in the remaining bigrams are likely to be on the same row of the square.
    Knowing the high-frequency letters on 2 out of the 5 rows is enough to get started
    in the reconstruction of the square. The next step would be to try to place some
    probable words.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The Playfair cipher is rated Three. There are several ways to increase the strength
    of the Playfair cipher. Let me mention just a few.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2 Strengthening a Playfair cipher
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are several stronger variants of the Playfair cipher.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Nullfair or nofair
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Nulls can be added to the ciphertext at repeating intervals, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-5](../Images/9-unnumb-5.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Nullfair is rated Five.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Playfair+1
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: This super-simple enhancement adds a repeating binary key to the Playfair ciphertext.
    Wherever there is a 1 bit, the next letter of the alphabet is used. Playfair+1
    is stronger if the binary key has an odd length.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-6](../Images/9-unnumb-6.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: Playfair+1 is rated Five. Playfair+1 can also be done with ternary numbers.
    The digits in the additive key are kept small so the addition can be done in your
    head, without needing a tableau.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Double Playfair
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The Playfair cipher can be strengthened by applying it twice. On the second
    round, the pairs should straddle the bigrams created in the first round. (1) Encipher
    the message with a Playfair cipher. (2) Either move the first letter to the end,
    move the last letter to the beginning, or add a null at both ends. (3) Apply another
    round of Playfair. This is strongest if a different mixed alphabet is used for
    the second Playfair cipher. Double Playfair is rated Six.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Playfair ripple
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: This is a variant of double Playfair that takes only one pass through the message,
    and needs only one Polybius square. Let the plaintext be P[1]P[2]P[3]P[4] ...
    Start at the left end and encipher plaintext bigram P[1]P[2] using Playfair, producing
    ciphertext bigram C[1]C[2]. Then encipher C[2]P[3] as the second bigram, getting
    D[2]C[3]. Notice that D[2] has been enciphered twice. Next you encipher C[3]P[4],
    to get D[3]C[4], and so forth, moving one character to the right at each step.
    Playfair ripple is rated Six.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是双 Playfair 的一种变体，只需通过消息进行一次传递，而且只需要一个 Polybius 方块。让明文为 P[1]P[2]P[3]P[4] ...
    从左端开始，使用 Playfair 对明文二元组 P[1]P[2] 进行加密，产生密文二元组 C[1]C[2]。然后将 C[2]P[3] 作为第二个二元组进行加密，得到
    D[2]C[3]。注意，D[2] 已经加密了两次。接下来，你将 C[3]P[4] 进行加密，得到 D[3]C[4]，依此类推，每一步向右移动一个字符。Playfair
    波动被评为 Six。
- en: Since the first letter C[1] and the last letter C[n] of the ciphertext have
    been enciphered only once, you may wish to encipher them as a bigram to complete
    the cycle.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密文的第一个字母 C[1] 和最后一个字母 C[n] 仅加密了一次，因此你可能希望将它们作为一个二元组加密以完成循环。
- en: '![9-unnumb-7](../Images/9-unnumb-7.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-7](../Images/9-unnumb-7.png)'
- en: PolyPlayfair
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: PolyPlayfair
- en: 'Use two different Polybius squares and alternate between them by using a repeating
    key. For example, a key of 11212 means that on each cycle of 5 bigrams the first,
    second and fourth bigrams would be enciphered with Square 1, while the third and
    fifth bigrams would be enciphered with Square 2\. This can be extended to three
    or more squares, with a correspondingly longer setup time. Using two squares and
    a key of not more than 10 digits PolyPlayfair is rated Five. If the key is generated
    by the Chained Digit algorithm, using the first square when the digit is 0 to
    4, and the second square when the digit is 5 to 9, the rating increases to Six.
    (Note: using the parity of the chained digit sequence has a much shorter period,
    so it is far weaker.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个不同的 Polybius 方块，并通过使用重复密钥在它们之间交替。例如，密钥为 11212 意味着在每个 5 个二元组的周期中，第一个、第二个和第四个二元组将使用方块
    1 进行加密，而第三个和第五个二元组将使用方块 2 进行加密。这可以扩展到三个或更多方块，相应的设置时间会更长。使用两个方块和不超过 10 位数字的密钥，PolyPlayfair
    的评级为 Five。如果密钥是由 Chained Digit 算法生成的，当数字为 0 到 4 时使用第一个方块，当数字为 5 到 9 时使用第二个方块，评级会增加到
    Six。（注意：使用链式数字序列的奇偶性具有更短的周期，因此它更弱。）
- en: Transposition
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 转位
- en: After the plaintext has been enciphered with the Playfair cipher the resulting
    ciphertext can be transposed. The transposition can be as elaborate as the columnar
    transposition of section 7.2, or as simple as the piecewise reversal of the Bazeries
    Type 4 cipher in section 4.6.1\. With columnar transposition the Playfair is rated
    Seven. With piecewise reversal the Playfair is rated Five.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Playfair 密码对明文进行加密后，可以对结果的密文进行转置。转置可以像第 7.2 节的栏转置那样复杂，也可以像第 4.6.1 节的 Bazeries
    类型 4 密码那样简单。使用栏转置，Playfair 评为 Seven。使用分段反转，Playfair 评为 Five。
- en: 9.3 Two Square
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 双方块
- en: The *Two Square* cipher, sometimes called *Double Playfair*, is an improved
    version of the Playfair cipher. It was invented by French amateur cryptographer
    Félix-Marie Delastelle and described in his 1902 book *Traité Élémentaire de Cryptographie*.
    As the name implies, it uses two Polybius squares instead of one, so that there
    are two mixed alphabets instead of one. The two squares may be placed side-by-side
    horizontally, or bottom-to-top vertically. The horizontal version is illustrated.
    In this example the two squares were mixed using the keywords FIRST and SECOND,
    and the letter Q was omitted to fit the 5×5 grids.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*Two Square* 密码，有时称为 *双 Playfair*，是 Playfair 密码的改进版本。它是由法国业余密码学家费利克斯·玛丽·德拉斯泰尔（Félix-Marie
    Delastelle）发明的，并在他的 1902 年著作 *Traité Élémentaire de Cryptographie* 中描述。顾名思义，它使用两个
    Polybius 方块而不是一个，因此有两个混合字母表而不是一个。这两个方块可以水平并排放置，也可以垂直从底部到顶部放置。水平版本如图所示。在此示例中，使用关键词
    FIRST 和 SECOND 混合了两个方块，并且省略了字母 Q 以适应 5×5 网格。'
- en: '![9-unnumb-8](../Images/9-unnumb-8.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-8](../Images/9-unnumb-8.png)'
- en: Like the Playfair, the message is enciphered 2 letters at a time. That is, Two
    Square enciphers bigrams. To encipher the bigram SO we find the S in the left
    square and the O in the right square. The substitute for S is the letter in the
    right square in the same row as S and the same column as O, namely **T**. The
    substitute for O is the letter in the left square in the same row as O and the
    same column as S, namely **K**. Thus the bigram SO becomes **TK**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Playfair 一样，消息每次加密 2 个字母。也就是说，Two Square 加密双字母组。要加密双字母组 SO，我们在左方块中找到 S，在右方块中找到
    O。S 的替代字母是右方块中与 S 同一行且与 O 同一列的字母，即**T**。O 的替代字母是左方块中与 O 同一行且与 S 同一列的字母，即**K**。因此，双字母组
    SO 变成了**TK**。
- en: Unlike the Playfair, there is no need to break up double letters. The two letters
    could be on different rows in the two squares. For example, SS becomes **MK**.
    In most cases, a double letter in the ciphertext will not correspond to a double
    letter in the plaintext.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Playfair 不同，不需要分开双字母。两个字母可以在两个方块的不同行上。例如，SS 变成**MK**。在大多数情况下，密文中的双��母不会对应于明文中的双字母。
- en: Here is the substitution process visually.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是替换过程的可视化展示。
- en: '![9-unnumb-9](../Images/9-unnumb-9.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-9](../Images/9-unnumb-9.png)'
- en: An important weakness of the Two Square cipher is that when the two letters
    of a bigram fall on the same row in the grid the substitute is simply those letters
    in reverse. For instance, ST would become **TS**. This weakness, called a *transparency*,
    sometimes allows an entire word to leak through. For example, SU ND AY would become
    **US DN YA**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Two Square 密码的一个重要弱点是，当一个双字母组的两个字母在网格中的同一行时，替代字母就是这两个字母的反向。例如，ST 会变成**TS**。这种弱点被称为*透明性*，有时会导致整个单词泄露出来。例如，SU
    ND AY 会变成**US DN YA**。
- en: 'To prevent this, I propose this *Same Row Rule*: when the two letters are on
    the same row, they are replaced by the letters immediately below them, wrapping
    to the top row when necessary. For example, ST would now become **DY**, and VI
    would become **FP**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，我提出了这个*相同行规则*：当两个字母在同一行上时，它们被它们下面的字母替换，必要时回到顶行。例如，ST 现在会变成**DY**，VI
    会变成**FP**。
- en: With the Same Row Rule, Two Square is rated Four. Call this variation *Two Square
    B*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同行规则，Two Square 评级为四。将这种变体称为*Two Square B*。
- en: The Germans took the name Double Playfair literally. They enciphered each bigram
    using the Two Square cipher, and then enciphered that bigram again, using Two
    Square with the same two squares. The result is essentially a general bigram substitution
    (section 6.5).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 德国人字面上采用了“双 Playfair”这个名称。他们使用了 Two Square 密码对每个双字母组进行加密，然后再次使用相同的两个方块进行加密。结果基本上是一个通用的双字母替换（第
    6.5 节）。
- en: The same methods that were used to strengthen the Playfair cipher may also be
    used to strengthen the Two Square cipher, such as *TwoSquare+1* and *Two Square
    Ripple*, with the same ratings. Here is an additional variant.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 加强 Playfair 密码所使用的方法也可以用于加强 Two Square 密码，比如*TwoSquare+1*和*Two Square Ripple*，评级相同。这里是一个额外的变体。
- en: Playfair TwoSquare
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair TwoSquare
- en: The Two Square cipher uses two Polybius squares. Either of these squares could
    be used for a Playfair cipher. This suggests a hybrid method that mixes Playfair
    and Two Square. Again, we will use a numerical key to control how each successive
    bigram is enciphered. A 1 means encipher the bigram using Playfair in the left
    square, a 2 means encipher the bigram using Playfair in the right square, and
    a 3 means encipher the bigram using Two Square or Two Square B. It is best if
    the numeric key contains at least one of each digit. Since Two Square is stronger
    than Playfair, 3 should occur more often than 1 or 2 in the key. About 50% would
    be suitable. *Playfair TwoSquare* is rated Six.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Two Square 密码使用了两个 Polybius 方块。这两个方块中的任何一个都可以用于 Playfair 密码。这提示了一种混合方法，将 Playfair
    和 Two Square 结合起来。同样，我们将使用一个数字密钥来控制每个连续双字母组的加密。1 表示使用左方块中的 Playfair 加密双字母组，2 表示使用右方块中的
    Playfair 加密双字母组，3 表示使用 Two Square 或 Two Square B 加密双字母组。最好是数字密钥至少包含每个数字。由于 Two
    Square 比 Playfair 更强大，3 应该比 1 或 2 在密钥中更频繁出现。大约 50% 是合适的。*Playfair TwoSquare* 评级为六。
- en: 9.4 Three Square
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 三方块
- en: '*Three Square* is my own idea. Otherwise, it has no special merit. I include
    it here simply because one of the books I read while researching for this book
    said that Two Square could not be extended to more than two squares. I love a
    challenge.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*Three Square* 是我的独创想法。否则，它没有特别的优点。我在这里包括它只是因为我在为这本书做研究时阅读的一本书说 Two Square
    不能扩展到超过两个方块。我喜欢挑战。'
- en: As the name suggests, Three Square uses three Polybius squares. These squares
    should be well-mixed with independent keys. Three Square enciphers 3 letters at
    a time, that is, it enciphers trigrams. This makes it stronger than Two Square.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-10](../Images/9-unnumb-10.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: The basic idea is that each letter is replaced by a letter in the square to
    its right. The replacement letter is in the same row, but in the column containing
    the next letter of the trigram.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we wish to encipher the trigram THE. The first letter is T, the second
    letter is H, and the third letter is E. We encipher using the T in the first square,
    the H in the second square and the E in the third square, like this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-11](../Images/9-unnumb-11.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: The substitute for T is on the row containing the T, and in the column in the
    second square containing the H, so T is replaced by **V**. The substitute for
    H is on the same row as the H in the same column as the E in the third square,
    so H is replaced by **R**. The substitute for E is on the same row as the E in
    the column in the first square containing the T, so E is replaced by **Z**. Thus,
    THE becomes **VRZ**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen pictorially as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-12](../Images/9-unnumb-12.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'The decipherment goes in the opposite direction. Since the first letter of
    the ciphertext trigram **VRZ** came from the second square, we begin deciphering
    in the second square, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-13](../Images/9-unnumb-13.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: Three Square has a worse problem than Two Square with letters falling on the
    same row. In a trigram such as XYZ, it is possible that X and Y could fall on
    the same row, Y and Z could fall on the same row, or Z and X could fall on the
    same row. This requires two extra rules to prevent a transparency where a letter
    represents itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '*Rule 1:* If two consecutive letters in the trigram fall on the same row, the
    first of these two letters is enciphered as the letter to the right of the second
    of the letters, wrapping to the left column, if needed. For example, in the trigram
    SUB the S is on the top row of the first square, and the U is on the top row of
    the second square. Therefore S is replaced by **V** instead of by **U**. Similarly,
    in the trigram LET, the T is on the third row of the third square, and the L is
    on the third row of the first square. So T is replaced by **G** instead of **L**.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: This diagram illustrates Rule 1\. Without Rule 1, in the trigram SUB the S would
    be replaced by **U**. Instead, it is replaced by the letter to the right of U
    in the middle square, namely **V**. Without Rule 1, in the trigram LET the T would
    be replaced by **L**. Instead, it is replaced by the letter to the right of L
    in the left square. This wraps from column 5 to column 1, which has the letter
    **G**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-14](../Images/9-unnumb-14.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '*Rule 2:* If all three letters in the trigram fall on the same row, each letter
    will be replaced by the letter immediately below it, wrapping to the top row,
    if needed. Thus FUN would be replaced by **AZV**, and WRE would be replaced by
    **IXL**.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*规则 2：* 如果三元组中的所有三个字母都在同一行上，那么每个字母将被其下方的字母替换，如果需要，将回到顶行。因此，FUN 将被替换为**AZV**，而
    WRE 将被替换为**IXL**。'
- en: With these rules Three Square is rated Five.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，三方格被评为五。
- en: Playfair ThreeSquare
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair ThreeSquare
- en: The Three Square cipher uses three Polybius squares. Any of these squares could
    be used for a Playfair cipher. This suggests a hybrid method that mixes the Playfair
    and Three Square ciphers. You can use a numerical key such as 1,4,1,3,4,2,4 to
    control how each successive bigram or trigram is enciphered. A 1 means encipher
    the next 2 letters as a bigram using Playfair in the first square. A 2 means encipher
    the next 2 letters as a bigram using Playfair in the second square. A 3 means
    encipher the next 2 letters as a bigram using Playfair in the third square. A
    4 means encipher the next 3 letters as a trigram using Three Square. It is best
    if the numeric key contains at least one of each digit. Since Three Square is
    much stronger than Playfair, the digit 4 should occur more often than 1, 2 or
    3 in the numeric key. About 50% would be suitable. That is, 4 should occur as
    often as 1, 2 and 3 combined. Equivalently, generate random numbers from 1 to
    6, and use Three Square with 4, 5 or 6.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 三方格密码使用三个波利比斯方格。这些方格中的任何一个都可以用于 Playfair 密码。这表明了一种混合方法，将 Playfair 和三方格密码混合在一起。您可以使用数字密钥，例如
    1,4,1,3,4,2,4 来控制每个连续的二元组或三元组的加密方式。1 表示使用第一个方格中的 Playfair 将下一个 2 个字母加密为二元组。2 表示使用第二个方格中的
    Playfair 将下一个 2 个字母加密为二元组。3 表示使用第三个方格中的 Playfair 将下一个 2 个字母加密为二元组。4 表示使用三方格将下一个
    3 个字母加密为三元组。最好是数字密钥至少包含每个数字。由于三方格比 Playfair 更强大，数字 4 应该比数字 1、2 或 3 更频繁地出现在数字密钥中。大约
    50% 的频率是合适的。也就是说，4 应该与 1、2 和 3 的总和一样频繁出现。同样，生成从 1 到 6 的随机数，并使用 4、5 或 6 进行三方格加密。
- en: Since Playfair ThreeSquare mixes bigrams and trigrams, about half of the bigrams
    and two-thirds of the trigrams will not fall on even boundaries. This means the
    increase in strength is greater than the increase for Playfair TwoSquare. Playfair
    ThreeSquare is rated Seven.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Playfair ThreeSquare 混合了二元组和三元组，大约一半的二元组和三分之二的三元组不会落在偶数边界上。这意味着强度的增加比 Playfair
    TwoSquare 的增加更大。Playfair ThreeSquare 被评为七。
- en: It is possible to combine Playfair, Two Square and Three Square into an even
    more complex cipher, no doubt with greater strength, but Playfair ThreeSquare
    is already pushing the limits of what a human code clerk can do. Both speed and
    accuracy would suffer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 Playfair、Two Square 和 Three Square 结合成一个更复杂的密码，毫无疑问具有更强的强度，但是 Playfair ThreeSquare
    已经在推动人类代码员的极限。速度和准确性都会受到影响。
- en: There is an opposite approach, which I call a *Straddling Three Square*. Group
    the plaintext into rows containing four blocks of 3 characters each. Encipher
    each of the blocks using the Three Square cipher. Now take the last letter of
    block 1 and the first letter of block 2 and encipher that bigram using the Playfair
    cipher with the first Polybius square. Take the last letter of block 2 and the
    first letter of block 3 and encipher that bigram using the Playfair cipher with
    the second Polybius square. Take the last letter of block 3 and the first letter
    of block 4 and encipher that bigram with the third Polybius square. This improves
    the strength of the Three Square cipher without adding much complexity, or much
    time. Use the Same Row Rule throughout.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种相反的方法，我称之为*跨三方格*。将明文分组成包含每行四个 3 个字符块的行。使用三方格密码对每个块进行加密。现在，取第一个块的最后一个字母和第二个块的第一个字母，并使用第一个波利比斯方格的
    Playfair 密码对该二元组进行加密。取第二个块的最后一个字母和第三个块的第一个字母，并使用第二个波利比斯方格的 Playfair 密码对该二元组进行加密。取第三个块的最后一个字母和第四个块的第一个字母，并使用第三个波利比斯方格的
    Playfair 密码对该二元组进行加密。这样可以提高三方格密码的强度，而不会增加太多复杂性或时间。始终使用相同行规则。
- en: 9.5 Four Square
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 四方格
- en: The *Four Square* cipher was invented by Félix-Marie Delastelle circa 1890,
    and described in his book *Traité Élémentaire de Cryptographie*, published 3 months
    after his death in 1902\. Delastelle invented the Two Square cipher after the
    Four Square cipher as a simplified and slightly less secure version. However,
    with the Same Row Rule described in section 9.3 the two ciphers can be considered
    equal in strength.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*四方密码*是由 Félix-Marie Delastelle 大约于 1890 年发明的，并在他于 1902 年去世后的 3 个月出版的书籍*Traité
    Élémentaire de Cryptographie*中描述。Delastelle 在四方密码之后发明了双方密码，作为简化且稍微不那么安全的版本。然而，使用第
    9.3 节中描述的同行规则，可以认为这两种密码的强度相等。'
- en: As the name implies, the Four Square cipher utilizes four Polybius squares.
    Two of the squares contain the standard alphabet, and the other two squares contain
    alphabets mixed using independent keys. The message is enciphered two letters
    at a time, that is, Four Square enciphers bigrams.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，四方密码利用四个 Polybius 方块。其中两个方块包含标准字母表，另外两个方块包含使用独立密钥混合的字母表。消息以两个字母为一组进行加密，即四方加密二元组。
- en: Here is a sample arrangement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例排列。
- en: '![9-unnumb-15](../Images/9-unnumb-15.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-15](../Images/9-unnumb-15.png)'
- en: 'Enciphering uses the familiar rectangular scheme. You locate the two plaintext
    letters in the standard alphabets and replace them with the letters at the opposite
    corners of the rectangle, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 加密使用熟悉的矩形方案。您在标准字母表中定位两个明文字母，并将它们替换为矩形对角线上的字母，如下所示：
- en: '![9-unnumb-16](../Images/9-unnumb-16.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-16](../Images/9-unnumb-16.png)'
- en: Since the two plaintext letters can never be in the same row or the same column
    of the 10×10 grid there is no need for special rules, or for separating double
    letters. The only need for a null character is for completing the last bigram.
    Four Square is rated Five.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个明文字母永远不可能在 10×10 网格的同一行或同一列中，因此无需特殊规则或分隔双字母。唯一需要空字符的情况是为了完成最后一个双字母组合。四方加密的评级为五。
- en: Cycling method
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 循环方法
- en: 'To get a little more strength you can use a simple transposition similar to
    the piecewise reversal in section 4.6.1\. This transposition uses a repeating
    numeric key such as 1,3,1,4,2,6\. Divide the ciphertext into blocks of 7 characters,
    or any other odd length. Write the successive key digits above each block. Then
    cycle each block left the number of positions indicated by its key digit. For
    example, if the key digit is 4 you would move the leftmost 4 digits to the right
    end of the block. Here is an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得更大的强度，您可以使用类似于第 4.6.1 节中的分段反转的简单换位。此换位使用重复的数字密钥，例如 1、3、1、4、2、6。将密文分成 7 个字符或任何其他奇数长度的块。在每个块的上方写下连续的密钥数字。然后将每个块左移其密钥数字指示的位置数。例如，如果密钥数字是
    4，则将最左边的 4 位数字移动到块的右端。这是一个例子：
- en: '![9-unnumb-17](../Images/9-unnumb-17.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-17](../Images/9-unnumb-17.png)'
- en: Four Square using the cycling method is rated Six.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环方法的四方加密的评级为六。
- en: Halving method
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分半方法
- en: Another approach to strengthening Four Square is to transpose the message beforehand.
    Suppose the message is AMBASSADOR WILKINS ASSASSINATED KABUL TODAY. This has 39
    letters. Dividing 39 by 2 and rounding up gives 20\. Write the message in two
    rows of 20 letters each, and read off the bigrams reading vertically. Encipher
    these bigrams using Four Square.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 加强四方加密的另一种方法是事先转置消息。假设消息是AMBASSADOR WILKINS ASSASSINATED KABUL TODAY。这有 39 个字母。将
    39 除以 2 并四舍五入得到 20。将消息写成两行，每行 20 个字母，并从垂直方向读取双字母组合。使用四方进行这些双字母组合的加密。
- en: '![9-unnumb-18](../Images/9-unnumb-18.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-18](../Images/9-unnumb-18.png)'
- en: These bigrams no longer have the normal bigram frequencies, or the normal contact
    frequencies, for English bigrams. Four Square using the halving method is rated
    Seven.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些双字母组合不再具有正常的双字母组合频率或英语双字母组合的正常联系频率。使用分半方法的四方加密的评级为七。
- en: 9.6 Bifid
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 双分
- en: Let’s look at one more historical hand cipher based on the 5×5 Polybius square.
    This is the *Bifid* cipher, also invented by Félix-Marie Delastelle in the 1890s.
    Bifid is a 3-step cipher where (1) the letters are converted into their Polybius
    coordinates, (2) those coordinates are rearranged, and (3) the coordinates are
    then converted back into letters. Originally, Delastelle wrote out the entire
    message with the coordinates written vertically under each letter, then he combined
    the pairs of coordinates reading horizontally, first across the top row and then
    across the bottom row.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个基于5×5波利比乌斯方阵的历史手工密码。这是*双重*密码，也是在19世纪90年代由菲利克斯·玛丽·德拉斯特尔发明的。双重是一个3步密码，其中(1)字母被转换为它们的波利比乌斯坐标，(2)这些坐标被重新排列，(3)然后坐标被转换回字母。最初，德拉斯特尔将整个消息写出，坐标垂直写在每个字母下面，然后他将坐标对水平地读出，先横穿顶行，然后横穿底行。
- en: The modern method is to break the message into blocks of a fixed size. The block
    size should be an odd number, such as 5, 7 or 9\. If the block size is an even
    number, then Emily can separate the blocks into bigrams.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现代方法是将消息分成固定大小的块。块大小应该是奇数，如5、7或9。如果块大小是偶数，则艾米莉可以将块分成二元组。
- en: 'The first step is to convert the letters into their coordinates in the Polybius
    square. Suppose the block length is 5\. The 5 plaintext letters can be represented
    as X1, X2, X3, X4 and X5\. Their row and column coordinates can be represented
    as R1C1, R2C2, R3C3, R4C4 and R5C5\. Each of these R and C symbols is a number
    from 1 to 5, with the row coordinate first and the column coordinate second. These
    pairs of coordinates are written vertically below each letter in the block, like
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将字母转换为波利比乌斯方阵中的坐标。假设块长度为5。5个明文字母可以表示为X1、X2、X3、X4和X5。它们的行和列坐标可以表示为R1C1、R2C2、R3C3、R4C4和R5C5。这些R和C符号各自是从1到5的数字，先是行坐标，然后是列坐标。这些坐标对是垂直地写在每个块的每个字母下面，像这样：
- en: '![9-unnumb-19](../Images/9-unnumb-19.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-19](../Images/9-unnumb-19.png)'
- en: Then they are read out going across the rows in the order R1R2, R3R4, R5C1,
    C2C3, C4C5\. Here is an example. The word MAJOR is enciphered using a Polybius
    square that was mixed using the keyword SAMPLE.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照R1R2、R3R4、R5C1、C2C3、C4C5的顺序读取。这里是一个例子。使用关键词SAMPLE混合的波利比乌斯方阵对单词MAJOR进行了加密。
- en: '![9-unnumb-20](../Images/9-unnumb-20.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![9-unnumb-20](../Images/9-unnumb-20.png)'
- en: Notice that the third set of letter coordinates in the ciphertext, **R5C1**,
    is a row/column pair. This means that the third ciphertext letter will come from
    the same row, **R5**, in the Polybius square as the fifth plaintext letter, and
    from the same column, **C1**, as the first plaintext letter. This concurrence
    of both row coordinate and column coordinate is called a *natural*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，密文中的第三组字母坐标，**R5C1**，是一个行/列对。这意味着第三个密文字母将来自与第五个明文字母相同的行，**R5**，以及与第一个明文字母相同的列，**C1**。这个同时出现行坐标和列坐标的情况被称为*自然*。
- en: Since there are 5 letters in each row and 5 letters in each column in the square,
    there is a 1 in 5 chance that the third ciphertext letter is the same as the fifth
    plaintext letter, and a 1 in 5 chance that the third ciphertext letter is the
    same as the first plaintext letter. That is, there is a 20% chance that **R5C1**
    is the same as **R5C5**, and a 20% chance that **R5C1** is the same as **R1C1**.
    In this example, that is exactly what happened. The fifth plaintext letter is
    R and the third ciphertext letter is also **R**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方阵中每行有5个字母，每列有5个字母，所以第三个密文字母与第五个明文字母相同的概率为1/5，第三个密文字母与第一个明文字母相同的概率也是1/5。也就是说，**R5C1**与**R5C5**相同的概率是20%，而**R5C1**与**R1C1**相同的概率也是20%。在这个例子中，确实发生了这种情况。第五个明文字母是R，第三个密文字母也是**R**。
- en: Now look at the first ciphertext letter, **R1R2**. This is a row/row pair, not
    a row/column pair. Here only the first coordinate, **R1**, is in the correct place
    for a row/ column pair. The other coordinate, **R2**, is a row coordinate in the
    column position. Such a single placement is called a *half-natural*. It means
    that the first ciphertext letter comes from the same row in the Polybius square
    as the first plaintext letter. So there is a 20% chance that the first ciphertext
    letter is the same as the first plaintext letter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: This also happens with the second, fourth and fifth ciphertext letters. Each
    one of them falls in either the same row or the same column as one of the plaintext
    letters. Thus each of them has a 20% chance of being the same as that plaintext
    letter. This happened in the example, where the second ciphertext letter, **J**,
    is the same as the third plaintext letter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: This is a serious weakness in the bifid cipher which makes it easy for Emily
    to guess at and place probable words. On the other hand, if the plaintext and
    ciphertext letters are different, then you know that they are in the same row
    or column. In the example, the first plaintext letter **R1C1** is M, and the first
    ciphertext letter **R1R2** is **S**. This means that M and S must be in the same
    row of the Polybius square. When Emily deduces or guesses a word, that provides
    several of these equivalences. This, in turn, makes it easier to place additional
    words. When enough of these letter pairs have been accumulated, Emily can reconstruct
    the square.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Due to these weaknesses, the bifid cipher is rated Three.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 9.6.1 Conjugated matrix bifid
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These problems can be eliminated by using a different Polybius square to convert
    the coordinates back to letters. For example, Square 2 yields the ciphertext **VBJEF**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-21](../Images/9-unnumb-21.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Bifid with two separate Polybius squares is called by the highfalutin name *Conjugated
    Matrix Bifid*. In this context, a matrix simply means a rectangular array of letters
    or characters. The conjugated matrix bifid cipher is rated Five.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to boost the strength of the bifid cipher. One way is
    to vary the block length using a repeating numeric key such as 5, 11, 7\. The
    block lengths would be a cyclic repetition of this key, namely 5, 11, 7, 5, 11,
    7, 5, ... If you prefer, you can generate the block lengths by using the chained
    digit generator and translating the digits to odd block lengths. One possibility
    is
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-22](../Images/9-unnumb-22.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: So, if the generator produced digits 3, 6, 2, 7, ... , then the block lengths
    would be 11, 7, 9, 9, ...
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Using a short repeating key and conjugated matrices the cipher is rated Six.
    With a long repeating key or generating the block lengths using a random number
    generator the cipher is rated Seven.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar idea is to read out the coordinates starting from a different point
    in each block. You could use a numeric key to specify the sequence of starting
    points. If the block length is L, each number in the key may be anywhere from
    1 to 2L. A number from 1 to L would indicate a starting position on the top row
    of coordinates, while a number from L+1 to 2L would indicate a starting position
    on the bottom row, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-23](../Images/9-unnumb-23.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: The coordinates would be taken out in pairs reading from left to right. Here
    is the order for reading out the coordinates using the numeric key 4, 9\. The
    starting positions 4 and 9 are shaded.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-24](../Images/9-unnumb-24.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: This method increases the rating to Six.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Another way to strengthen the bifid cipher is to use a stronger transposition
    to mix the coordinates. The standard bifid using a block of length L takes the
    2L coordinates and writes them into a 2×L block. The coordinates are written into
    the block vertically and read out horizontally. We recognize this as a very simple
    route transposition, described in section 7.1\. There are several stronger transpositions
    covered in chapter 7, notably columnar transposition. One example of this type
    of cipher is the *ADFGVX* cipher invented by intelligence officer Lt. Fritz Nebel
    and used by the Germans in World War I. In the ADFGVX cipher, the coordinates,
    represented by the letters A,D,F,G,V,X, are mixed using a columnar transposition,
    and then transmitted as a string of those letters. This cipher is rated Five.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If you used longer blocks, say 20 characters, that would give you 40 coordinates.
    (With this method the block lengths may be either even or odd.) This is enough
    to use columnar transposition effectively to mix the coordinates. Or, you could
    go back to Delastelle’s original concept and take the coordinates for the entire
    message as a single block. Either way, using conjugated matrices this cipher is
    rated Eight. Using a double columnar transposition the cipher is rated Ten. Assuming
    four long independent keys and well-mixed alphabets, this is an unbreakable paper
    and pencil cipher. Call it *Double Columnar Bifid*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Diagonal bifid
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variation on the bifid cipher is to write the Polybius coordinates vertically
    under each letter, as usual, but to read them out diagonally, going from lower
    left to upper right (or southwest to northeast). This is called a *left diagonal*
    or an *antidiagonal*. (On a heraldic crest it is called *bar sinister*, and indicates
    out-of-wedlock birth.) For the last letter, you wrap to the first column (the
    shaded digit 1). The advantage of this is that there are no naturals or half-naturals
    to help Emily guess words. Here is an example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-25](../Images/9-unnumb-25.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Diagonal bifid is rated Four. With conjugated matrices it is rated Five. With
    conjugated matrices and periodically varying block sizes it is rated Six. Unlike
    classical bifid, both odd and even block sizes can be used with diagonal bifid.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 9.8 6×6 squares
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your messages contain a lot of numbers, it may be advantageous to use a 6×6
    Polybius square instead of a 5×5 square. A 6×6 square allows you to have the full
    26-letter alphabet plus the numerals from 0 to 9\. There is no need to omit J
    or Q from the alphabet. If you are enciphering by hand, this requires taking extra
    care to distinguish the letters O, I, Z, S and G from the digits 0, 1, 2, 5 and
    6\. Some people adopt special conventions, such as underlining all digits. I find
    this cumbersome and error-prone. I usually just exaggerate the characteristics
    that distinguish each of these characters from its mate, such as writing the letter
    I with extra-wide serifs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: All of the methods from the preceding 5 sections, namely Playfair, Two Square,
    Three Square, Four Square and Bifid, can be used with 6×6 squares, along with
    all of their variations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 9.9 Trifid
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you like squares, how about cubes? Another fractionation method, also invented
    by Félix-Marie Delastelle in the 1890s, is the *Trifid* cipher. Instead of representing
    each letter of the alphabet by two digits in base 5 (quinary numbers), each letter
    is represented by three base-3 digits (ternary numbers). This gives 3×3×3, or
    3³, different 3-digit combinations. This is enough for all 26 letters of the alphabet
    plus one extra character. Delastelle used a + plus sign for the 27th character.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The extra character + might be used as a form of punctuation, or it might be
    a signal that the following plaintext letter should be interpreted as a digit.
    The correspondence +A = 1, +B = 2, ... , +J = 0 could be used. The rest of the
    alphabet could also be used as special characters. For example, +K could mean
    period, +L could mean comma, and so forth.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Just as the 2-digit combinations can be displayed as a 5×5 letter square, the
    3-digit combinations can be displayed as a 3×3×3 letter cube. The 3 digits in
    each triple can be interpreted as the coordinates in the cube where that letter
    is located. These coordinates are commonly called the layer, the row and the column.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Here are the 27 ternary combinations, in order, with letter equivalents weakly
    mixed by using the keyword EXAMPLE and alternating columns. For instance, the
    letter N is represented by the triple 102, so it would be located on layer 1,
    row 0 and column 2 of the 3×3×3 letter cube.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-26](../Images/9-unnumb-26.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: The trifid cipher works similarly to the bifid cipher. The plaintext is written
    in blocks of some fixed size. The size may be any number that is not a multiple
    of 3\. The 3 digits are written vertically beneath each letter of the message,
    and then read out horizontally in groups of 3\. Then they are converted back into
    letters using the same equivalences. Here is an example with the plaintext SEND
    HELP and block size 4.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-27](../Images/9-unnumb-27.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: The same analysis and techniques that were used for bifid can also be applied
    to trifid, and they have the same ratings. You can use two separate substitution
    tables for converting the letters to digits and the digits back to letters. You
    can vary the block sizes. You can start reading out the digits from different
    places in each block. You can use a strong transposition to mix the ternary digits.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: A natural question is whether there is a diagonal version of the trifid cipher
    analogous to diagonal bifid. The advantage of diagonal bifid over the original
    bifid is that the diagonal version does not give rise to the half-naturals that
    weaken the original version. In the analogous diagonal trifid the middle digit
    of every group would be a third-natural, so the advantage is lost. The problem
    of naturals disappears, though, if you use two different mixed alphabets, one
    for writing in the digits and another for reading them out. Diagonal trifid with
    two alphabets is rated Five.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 9.10 Three Cube
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I was typing the preceding paragraph about the trifid cipher, I realized
    that the 3×3×3 cubic arrangement lends itself to a 3-dimensional analogue to the
    Two Square cipher described in section 9.3\. It is easy to visualize the Two Square
    cipher in two dimensions, but much harder to visualize a cube in three dimensions,
    so I am going to describe the new cipher solely in terms of the coordinates. Let’s
    call this cipher *Three Cube*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Two Square enciphers two letters at a time using two substitution tables, ergo
    Three Cube will encipher three letters at a time using three substitution tables.
    Here is a set of three tables well-mixed using the keywords COLUMBIA, STANFORD
    and HOPKINS. These three substitution tables are designated S, T and U. That’s
    S for Substitution, T for Table, and U for the next letter in the alphabet.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The substitution tables correspond the 26 letters of the alphabet and the character
    + with the 27 ternary triplets.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-28](../Images/9-unnumb-28.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Like trifid, Three Cube begins by writing the 3-digit triplet for each letter
    vertically beneath it. The 3 digits for the first letter are taken from substitution
    table S, the 3 digits for the second letter are taken from table T, and the 3
    digits for the third letter are taken from U. The pattern is shown here and illustrated
    by the trigram FLY.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-29](../Images/9-unnumb-29.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: Then the digits are read out left to right, and these horizontal triplets are
    converted back to letters. It would seem natural to use table S for converting
    the top row, table T for the middle row and table U for the bottom row. However,
    that would lead to a 1 in 9 chance that the top row would be identical to the
    left column, so that the first plaintext letter would be replaced by itself. That
    is, there is 1 chance in 9 that S1S2S3 is the same as S1T1U1\. The same is true
    for the middle and bottom rows. Let’s call this situation, where one digit is
    the same, a *part natural*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, substitution table S is used for the second row, table T is
    used for the third row, and table U is used for the top row. This eliminates the
    naturals. Here is the pattern.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-30](../Images/9-unnumb-30.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Since this is hard to keep straight when you are enciphering by hand, I suggest
    writing the choice of substitution table over each triplet of digits. This is
    similar to writing the key letter over each plaintext letter when using the Belaso
    cipher (section 5.5). Here is an example of Three Cube using the plaintext message
    FLY TO ROME.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-31](../Images/9-unnumb-31.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: The Three Cube cipher is rated Seven.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: There is a simple way to strengthen the Three Cube cipher. Instead of converting
    the triplets back to letters using the three substitution tables in strict rotation
    as we just did, use a key to set the order of the read-out tables. The key would
    consist of the letters S, T and U in some scrambled order, for example SUTUTTUUSTS.
    The length of this key should not be a multiple of 3\. I call this variant *Three
    Cube Plus*. Here is how FLY TO ROME would be enciphered using this read-out key.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-32](../Images/9-unnumb-32.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Using Three Cube Plus about 1/3 of the letters will have part naturals. That
    is, one of the 3 write-in digits will be the same as one of the read-out digits.
    However, Emily will not know which letters have this defect, and will not be able
    to exploit it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Three Cube Plus is rated Nine.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: So, you might well be saying, is it possible to nudge the rating up to Ten without
    making the cipher too complex for hand use? Thank you for asking. First off, let’s
    increase the number of substitution tables from 3 to 6\. Let’s call them S, T,
    U, V, W and X. Instead of writing in the triplets using a strict rotation STU,
    STU, STU, ... we will use another letter key consisting of those 6 letters in
    some scrambled order. The write-in key could be TWXUSTTVWV, and the read-out key
    could be VWTXXSUSVTU. Ideally, the lengths of these keys would be mutually prime,
    and neither length would be divisible by 3\. Here the lengths are 10 and 11\.
    Let’s call this cipher *Three Cube Super*. This is an example of Three Cube Super
    using the plaintext FLY TO NEW YORK.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-33](../Images/9-unnumb-33.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Three Cube Super is rated Ten. This is another unbreakable hand cipher.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 9.11 Rectangular grids
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to now we have discussed only square and cubic arrays of letters. There is
    no restriction in cryptography that requires all of the dimensions of a letter
    grid to be the same. It is basically a historical accident that the English alphabet
    has 26 letters, and 26 is very close to 5×5\. If we used the 33-letter Russian
    alphabet we might choose a 4×8 or 5×7 rectangle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: If we want to have all 26 letters of the alphabet, then a 3×9 or 4×7 rectangle
    might be preferable. These give you the full 26-letter alphabet plus one or two
    extra characters. We have discussed the use of such extra characters earlier,
    for example for switching between letters and numerals. Most of the ciphers based
    on Polybius squares work just as well with 3×9 or 4×7 rectangles as they do with
    5×5 squares, assuming all of the rectangles are oriented in the same direction.
    These are the Playfair, the Two Square, the Three Square, the Four Square, and
    the diagonal bifid ciphers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In fact, these 5 ciphers may be stronger when used with those rectangles because
    each letter of the alphabet has more possible substitutes. The downside, when
    using Playfair or Two Square, is that there is a higher probability that the two
    letters are on the same row, and therefore are replaced with the letters below
    them or to their right.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a Playfair cipher done with a 3×9 rectangle:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-34](../Images/9-unnumb-34.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 9.12 Hexadecimal fractionation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far this chapter has focused solely on hand methods. This meant small arrays
    using only the uppercase alphabet. For computer use you usually want the full
    alphabet, uppercase and lowercase, numbers, punctuation, special symbols, diacritics,
    and perhaps multiple alphabets. In short you may want the full text capabilities
    of the computer. The simplest way to do this is to represent each character by
    an 8-bit byte using one of the standard computer codes such as UTF-8 or UTF-16.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: A natural way to fractionate an 8-bit byte is to split it into two 4-bit hexadecimal
    digits, or hex digits. All of the fractionation methods that are based on Polybius
    squares also work for 16×16 squares, namely Playfair, Two Square, Three Square,
    Four Square, and bifid. If the 16×16 square is well-mixed using a large key, these
    methods are stronger than the same methods used with 5×5 squares. This is because
    there are vastly more arrangements of 256 characters than of 25 characters, namely
    8.58×10^(506) versus 1.55×10^(25).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: A simple method for using hexadecimal fractionation is to (1) convert the characters
    of the message to hexadecimal digits by using a well-mixed keyed substitution
    table, (2) scramble those digits using some transposition cipher, and then (3)
    convert the pairs of hex digits back to bytes using a second well-mixed keyed
    substitution table.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The simplest transposition is just moving the first hex digit to the end, so
    that 12 34 56 78 would become 23 45 67 81\. This might be called *Cycle Hex*.
    It is essentially diagonal bifid (section 9.7) done in base 16 instead of base
    5\. Cycle hex is rated Five. You could also use the piecewise reversal transposition
    described in section 4.6.1 to scramble the letter order. This might be called
    *Piecewise Hex*. It is also rated Five. A stronger method would be to scramble
    the hex digits using a columnar transposition cipher. This could be called *Columnar
    Hex*. It is rated Seven. With a double columnar transposition the rating increases
    to Ten.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: These methods can be used to encipher any computer file. However, if the files
    are pure text, the methods can be further enhanced. Pure text will normally use
    fewer than 100 of the 256 possible byte values. The remaining character codes
    can be used for nulls, bigrams, trigrams and other purposes described in section
    6.4\. If done well, this raises the ratings to cycle hex Six, piecewise hex Six,
    and columnar hex Eight.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 9.13 Bitwise fractionation
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fractionation can also be done with the individual bits that represent the characters
    in a message. The block of N characters would be represented by 8N bits. These
    can be formed into a rectangle in several ways, such as 2×4N, 4×2N, 8×N and N×8\.
    For example, a block of 5 letters would be represented by 40 bits, which could
    be written as 2 rows of 20 bits, 4 rows of 10 bits, 8 rows of 5 bits, or 5 rows
    of 8 bits. This is cumbersome for hand operations, but easily done with a computer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of how 5 characters can be written horizontally into a 5×8
    block and then read out vertically. This example uses the standard UTF-8 character
    codes. For example, uppercase letter A is represented as 01000001\. The plaintext
    is the word DELTA.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-35](../Images/9-unnumb-35.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: The bits are read out going down the columns. Since each column contains only
    5 bits, each byte of the ciphertext must span two or more columns. The 8 bits
    for the first ciphertext byte are found in columns 1 and 2 with medium highlighting.
    The first column contains 00000, and the first 3 bits in the second column are
    111, so the first byte of the ciphertext is 00000111, or hex 07\. This is the
    control character BELL, dating back to the teletype era, when it used to cause
    the carriage-return bell to sound. It has no graphic representation anymore. I
    will use the note **♪** to represent the bell character.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The second ciphertext byte comes from the darker highlighted section spanning
    columns 2, 3 and 4\. The last 2 bits in column 2 are 11, column 3 contains 00000,
    and the first bit in column 4 is 0\. Combining these, the second ciphertext byte
    is 11000000\. This represents the character **À**, which is an uppercase **A**
    with a grave accent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Bytes 3 and 4 of the ciphertext are **“** and **x**, that is, double quote and
    lowercase x. The fifth byte comes from columns 7 and 8, namely 000 and 01001\.
    The byte 00001001 represents the **HTAB**, or horizontal tab character, which
    is invisible. I will use the arrowhead **►** to represent it. Thus the ciphertext
    is **♪À“x►**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: This looks pretty cryptic, but the method is weak because it uses the standard
    alphabet for both the conversion of the plaintext into bits and the conversion
    from bits back to characters. It is rated One. If two independent well-mixed keyed
    alphabets are used for these steps, then this cipher is simply a binary version
    of the conjugated matrix bifid (section 9.6.1). This method could be called *Hex
    Rectangle*. It has the same rating as the conjugated matrix bifid cipher, namely
    Five.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: It is natural to form eight 8-bit bytes into an 8×8 bit square. Write the 8
    bits for each character vertically into the square using a mixed alphabet, and
    read them out horizontally using a different mixed alphabet. This is just an 8×8
    square version of the hex rectangle, and has the rating Six.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 9.13.1 Cyclic 8×N
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is easy to improve the strength of this cipher. For any block of N characters,
    write their 8-bit representations into an 8×N rectangle vertically. Shift each
    row cyclically to the left by some amount from 0 to N-1 bit positions. For example,
    abcdefgh cyclically shifted, or *rotated*, left by 2 positions would give cdefghab.
    Then read each 8-bit column out vertically. Here is an example using an 8×8 bit
    square. Each row is cycled left by the amount indicated to its left.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-36](../Images/9-unnumb-36.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: This cipher is at the limit of what can be done by hand. It requires 3 keys,
    namely 2 keys for mixing the 2 alphabets, and an 8-digit key for specifying the
    shift amounts. It can be called *Cyclic 8×N*. When N is 6 or larger it is rated
    Seven. The cipher gets stronger as the block size, N, increases.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: When the rectangle is square you can rotate both the rows and columns to get
    a *Bicyclic 8×8* cipher. You should alternate directions for this. Write the bits
    in horizontally, cycle the bits vertically, cycle the bits horizontally, and read
    out the characters vertically. The Bicyclic 8×8 is rated Eight.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The cyclic 8×N cipher can be repeated to get a *Double Cyclic 8×N* cipher. This
    requires 5 keys, namely 3 keys to mix the 3 alphabets, and two 8-digit keys to
    control the 2 rounds of shifting. There are 5 steps. (1) Use the first alphabet
    to do a simple substitution. The resulting N bytes are written into the 8×N bit
    rectangle vertically. (2) Cyclically shift the rows using the first shift key.
    (3) Use the second alphabet to perform a simple substitution on the N columns.
    (4) Cyclically shift the rows using the second shift key. (5) Use the third alphabet
    to perform a final simple substitution on the vertical columns. Notice that all
    the shifts are horizontal and all the substitutions are vertical. The double cyclic
    8×N cipher is rated Nine.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: This can be continued to *Triple*, *Quadruple* and beyond, if desired. All of
    these variations can be further enhanced by varying the block sizes, either periodically
    or using a random number generator.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 9.14 Other fractionation
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In sections 9.12 and 9.13 we looked at dividing a byte into two hexadecimal
    digits or into eight individual bits. There are numerous other ways of partitioning
    8 bits, such as 3,2,3\. If the 3,2,3 bit representation of each character is written
    vertically, and then the 3 rows are cyclically shifted left by some number of
    positions, then each column will still have the 3,2,3 bit distribution, so the
    8 bits can be converted back into bytes. Here is an example. Each row is cycled
    left by the number of positions shown at the left, that is, 1 position, 3 positions
    and 2 positions, respectively.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![9-unnumb-37](../Images/9-unnumb-37.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Here the plaintext RETREAT has been transformed into the ciphertext **@w«****θ****K_****╝**.
    Let’s call this a *BitCycle Substitution*. This method is rated Five. Like the
    cyclic 8×N cipher in section 9.13.1, this can be doubled, tripled, or more, and
    the block sizes can be varied.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: This basic idea can be enhanced in two powerful ways.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: First, the bytes can be divided in several different ways, such as 1,3,2,2 or
    2,4,2\. For example, you could encipher the block first using the 3,2,3 split,
    then reencipher it using the 1,3,2,2 split, then reencipher that using the 2,4,2
    split. This would involve 7 keys and 7 steps. (1) Use the first substitution to
    produce the 3,2,3 bit representation of the message. (2) Shift the 3 rows using
    the first shift key. (3) Use the second substitution to produce the 1,3,2,2 bit
    representation of the bytes. (4) Shift the 4 rows according to the second shift
    key. (5) Use the third substitution to produce the 2,4,2 bit representation of
    the bytes. (6) Shift the 3 rows according to the third shift key. (7) Use the
    fourth substitution to produce the final ciphertext bytes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Second, the message blocks can be divided in several different ways. Suppose
    you used long plaintext blocks of, say, 32 characters. For Step 2 in the previous
    technique you could divide the 32 bytes into groups of 6, 14 and 12 bytes. For
    Step 4 you could divide the 32 bytes into groups of 11, 8 and 13 bytes. For Step
    6 you could divide the 32 bytes into groups of 8, 17 and 7 bytes. Each group would
    be shifted independently. This division could be different for every message.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Or, you could take a more inclusive approach. For Step 2, divide the entire
    message into blocks of size X. For Step 4, divide the message into blocks of size
    Y. For Step 6, divide the message into blocks of size Z. X, Y and Z may be any
    length from 6 bytes up to the full message length.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: I will not rate all of the variations of the BitCycle substitution. Suffice
    to say that the ratings may range anywhere from Five to Ten. In chapter 12 I will
    describe how you can verify that a block cipher truly deserves a rating of Ten.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 9.15 Stronger blocks
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several of the ciphers described in this chapter work on blocks of plaintext.
    There are several things that you can do to the plaintext blocks to make your
    cipher just a bit harder for Emily. Here is a short list of ideas:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Vary the block lengths, periodically or pseudorandomly.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse the first few letters of each block, periodically or pseudorandomly.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse the last few letters of each block, periodically or pseudorandomly.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cycle each block left or right, periodically or pseudorandomly.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swap the last N letters of the block with the first N letters of the next block.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But a word of warning: if you are enciphering and deciphering by hand, use
    these methods sparingly. If you make your cipher so complex that you cannot encipher
    and decipher accurately, then it becomes worthless.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
