- en: 13 Stream ciphers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 流密码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Pseudorandom number generators
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪随机数生成器
- en: Functions for combining the random numbers with the message
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于将随机数与消息组合的函数
- en: Generating true random numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成真随机数
- en: Hash functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散列函数
- en: Stream ciphers are the opposite of block ciphers. Characters in stream ciphers
    are enciphered as they are encountered, usually one at a time. The basic concept
    is to take a stream of message characters and combine them with a stream of key
    characters to produce a stream of ciphertext characters. This paradigm is well
    suited for continuous operation where messages are continuously enciphered and
    transmitted at one end, and continuously received and deciphered at the other
    end, with no pauses, or only momentary pauses to change keys.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码与分组密码相反。流密码中的字符在遇到时被加密，通常一次一个。基本概念是将一系列消息字符与一系列密钥字符结合起来，以产生一系列密文字符。这种范式非常适合连续操作，其中消息在一端持续加密和传输，另一端持续接收和解密，没有暂停，或者只有短暂的暂停来更换密钥。
- en: We have already seen a few stream ciphers. The autokey and running key ciphers
    in section 5.9, the rotor machines of section 5.10, Huffman substitution in section
    10.4, and the ciphers based on text compression in section 10.7 are all examples
    of stream ciphers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些流密码。第 5.9 节中的自动密钥和流动密钥密码，第 5.10 节中的转子机器，第 10.4 节中的哈夫曼替换，以及第 10.7 节中基于文本压缩的密码都是流密码的示例。
- en: 13.1 Combining functions
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 组合函数
- en: The most common types of stream ciphers use one key unit to encipher one plaintext
    unit. The units are usually letters or bytes, but hex digits or even bits can
    also be used. The key unit is combined with the plaintext unit using essentially
    the same combining functions that were used with the ripple ciphers in section
    11.8, but using a key unit in place of the preceding unit. Here are the analogous
    methods, with x[n] being the nth unit of the message, k[n] being the nth unit
    of the key, A and B being simple substitutions and P being a general polyalphabetic
    substitution. The substitutions A, B and P should be mixed using keys, not fixed
    or built in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的流密码类型使用一个密钥单元加密一个明文单元。这些单元通常是字母或字节，但十六进制数字甚至比特也可以使用。密钥单元与明文单元结合使用基本上与第 11.8
    节中的涟漪密码使用的组合函数相同，但使用密钥单元代替前一个单元。以下是类似的方法，其中 x[n] 是消息的第 n 个单元，k[n] 是密钥的第 n 个单元，A
    和 B 是简单的替换，P 是通用多表替换。替换 A、B 和 P 应该使用密钥混合，而不是固定或内置的。
- en: '| **xor** | Exclusive-OR | x[n] is replaced by k[n]⊕x[n]. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **xor** | 异或 | x[n] 被 k[n]⊕x[n] 替换。'
- en: '| **sxor** | Substitute and exclusive-OR | There are three variations: x[n]
    may be replaced by A(k[n])⊕x[n], or k[n]⊕B(x[n]) or A(k[n])⊕B(x[n]). That is,
    you may substitute for either k[n] or x[n] or both. (The use of A(k[n]) instead
    of k[n] can serve to prevent Emily from recovering the pseudorandom sequence when
    there is known plaintext.) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **sxor** | 替换并异或 | 有三种变体：x[n] 可以被 A(k[n])⊕x[n] 替换，或者 k[n]⊕B(x[n]) 或 A(k[n])⊕B(x[n])。也就是说，你可以替换
    k[n] 或 x[n] 或两者都替换。（在已知明文的情况下，使用 A(k[n]) 而不是 k[n] 可以防止 Emily 恢复伪随机序列。）'
- en: '| **xors** | Exclusive-OR and substitute | x[n] is replaced by A(k[n]⊕x[n]).
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **xors** | 异或并替换 | x[n] 被 A(k[n]⊕x[n]) 替换。'
- en: '| **add** | Add | x[n] is replaced by k[n]+x[n]. As always, addition is modulo
    the size of the alphabet. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **add** | 相加 | x[n] 被 k[n]+x[n] 替换。如常，加法是对字母表大小取模的。'
- en: '| **madd** | Multiply and add | Also called **linear replacement**. x[n] is
    replaced by pk[n]+x[n], or k[n]+qx[n], or pk[n]+qx[n], where p may be any integer
    and q may be any odd integer. (If you are using an alphabet whose size is different
    from 256, q must be coprime to that size.) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **madd** | 乘以并相加 | 也称为**线性替换**。x[n] 被 pk[n]+x[n] 替换，或者 k[n]+qx[n]，或者 pk[n]+qx[n]，其中
    p 可以是任意整数，q 可以是任意奇整数。（如果你使用的字母表大小与 256 不同，q 必须与该大小互质。）'
- en: '| **sadd** | Substitute and add | x[n] is replaced by A(k[n])+x[n], or k[n]+B(x[n])
    or A(k[n])+B(x[n]). |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **sadd** | 替换并相加 | x[n] 被 A(k[n])+x[n] 替换，或者 k[n]+B(x[n]) 或 A(k[n])+B(x[n])。'
- en: '| **adds** | Add and substitute | x[n] is replaced by A(k[n]+x[n]). |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **adds** | 相加并替换 | x[n] 被 A(k[n]+x[n]) 替换。'
- en: '| **poly** | General polyalphabetic substitution | x[n] is replaced by P(k[n],
    x[n]). |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **poly** | 通用多表替换 | x[n] 被 P(k[n], x[n]) 替换。'
- en: Since **xor** or **sxor** may leak information about its operands, I recommend
    using **xors** instead, so that the simple substitution is done after the exclusive-OR
    to mask the waveforms, namely A(k[n]⊕x[n]).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**xor**或**sxor**可能会泄露关于其操作数的信息，我建议改用**xors**，这样在执行异或操作后进行简单替换以掩盖波形，即A(k[n]⊕x[n])。
- en: A stream cipher may also use one or more previous characters to encipher the
    current character. There are many combinations. One example is P(k[n]⊕x[n-i],
    x[n]) for some small integer i. This cipher requires an initialization vector
    to encipher the first i characters. A stream cipher can also be strengthened by
    switching among several combining functions, for example periodically switching
    among the 3 forms of **sadd**, or of **madd**, or by periodically varying the
    multipliers p and q in **madd**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码也可以使用一个或多个先前的字符来加密当前字符。有许多组合方式。一个例子是P(k[n]⊕x[n-i], x[n])，其中i是一个小整数。这种密码需要一个初始化向量来加密前i个字符。流密码也可以通过在几个组合函数之间切换来加强，例如周期性地在**sadd**的3种形式之间或**madd**之间进行切换，或者周期性地变化**madd**中的乘数p和q。
- en: 13.2 Random numbers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 随机数
- en: 'The long keys used in the stream ciphers listed in the previous table can come
    from several sources:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面表格中列出的流密码中使用的长密钥可以来自几个来源：
- en: They may be a list of numbers repeated as many times as needed. This was the
    standard method from the 16th through the 19th centuries.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能是一个数字列表，根据需要重复多次。这是从16世纪到19世纪的标准方法。
- en: They may be generated by a mathematical process. Such numbers are called *pseudorandom*
    because they eventually repeat, as opposed to true random numbers, which never
    repeat. The process that generates these numbers is called a *pseudorandom number
    generator* (PRNG).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能是通过数学过程生成的。这些数字称为*pseudorandom*，因为它们最终会重复，而不是真正的随机数，后者永远不会重复。生成这些数字的过程称为*pseudorandom
    number generator*（PRNG）。
- en: They may be true random numbers that might be generated by some physical process
    such as gamma rays from an exploding star. Such processes are usually too slow
    for cryptographic needs, so these random numbers are usually collected over time
    and stored in the computer for later use. That is, they may be collected continuously
    and used only when you need to send a message.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能是真正的随机数，可能是由一些物理过程生成的，例如来自爆炸星的伽马射线。这些过程通常对于密码学的需要来说太慢了，因此这些随机数通常会随着时间的推移而收集，并存储在计算机中以供以后使用。也就是说，它们可以连续收集，并且只在您需要发送消息时使用。
- en: Books and articles about cryptography often state that you need true random
    numbers for a secure cipher. They point out that it has been mathematically proven
    that a one-time pad using a true random key cannot be broken. This is certainly
    true, provided that for every plaintext unit p and every ciphertext unit c there
    is a key unit k that transforms p into c, that is, S(k, p) = c. A true random
    key is sufficient to make the one-time pad unbreakable. However, as everyone who
    has studied logic knows, a condition can be sufficient without being necessary,
    and vice versa.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于密码学的书籍和文章经常声称，你需要真正的随机数才能获得安全的密码。他们指出，已经数学证明了使用真正随机密钥的一次性密码本是不可破解的。这当然是正确的，前提是对于每个明文单元p和每个密文单元c，都存在一个密钥单元k将p转换为c，即S(k,
    p) = c。真正的随机密钥足以使一次性密码本无法破解。然而，正如每个学过逻辑的人都知道的，条件可以是充分的，但不是必要的，反之亦然。
- en: For example, for an integer to be a prime it is necessary for it to be greater
    than 1\. That is necessary but not sufficient, since 4 is an integer greater than
    1 but is not a prime. For an integer to be composite it is sufficient for it to
    be a square greater than 1\. That is sufficient but not necessary, since 6 is
    composite but not a square.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使一个整数成为质数，必须大于1。这是必要的，但不充分，因为4是一个大于1的整数，但不是质数。要使一个整数成为合数，它必须是一个大于1的平方数。这是充分的，但不必要，因为6是合数，但不是平方数。
- en: Requiring that the key for a one-time pad must be true random is overkill. To
    make the one-time pad unbreakable the key must be *unpredictable*, also called
    *cryptographically secure*. With a true random key, no matter how many key units
    Emily may know, it is impossible for her to determine any other units. With an
    unpredictable key it only needs to be computationally infeasible for Emily to
    determine any other units. Specifically, the amount of work Emily needs to do
    to determine another key unit must be greater than 2^k, where k is your chosen
    key size in bits. It is true that when the key stream is only pseudorandom you
    can no longer prove that the cipher is unbreakable, but this has no practical
    significance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要求一次性密码本的密钥必须是真随机是过度的。为了使一次性密码本无法破解，密钥必须是*不可预测的*，也称为*密码学安全的*。使用真随机密钥，无论 Emily
    知道多少个密钥单位，她都无法确定其他单位。使用不可预测的密钥，Emily 只需无法计算地确定其他单位。具体而言，Emily 需要做的工作量来确定另一个密钥单位必须大于
    2^k，其中 k 是你选择的密钥大小（以比特为单位）。当密钥流仅为伪随机时，您无法再证明密码本是不可破解的，但这在实践中没有实际意义。
- en: Later in this chapter I will describe several schemes to make pseudorandom number
    generators cryptographically secure, and point out one secure-looking scheme that
    is insecure, namely CG5, described in section 13.13.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面我将描述几种使伪随机数生成器具有密码学安全性的方案，并指出一个看起来安全但实际上是不安全的方案，即第 13.13 节中描述的 CG5。
- en: All of the stream ciphers listed earlier can utilize pseudorandom number generators
    to produce the key stream, so let’s look at a variety of PRNGs, starting with
    some classical methods from the 1950s. These generators use a small initial value,
    called the *seed* or the *initial state*, and some simple mathematical function
    that generates the next state from the current state, called the *state vector*.
    Common generating functions are addition, multiplication and exclusive-OR. These
    generators are still in wide use today because of their great speed and easy implementation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列出的所有流密码都可以利用伪随机数生成器产生密钥流，因此让我们来看一些 PRNG 的变体，首先从上世纪 50 年代的一些经典方法开始。这些生成器使用一个小的初始值，称为*种子*或*初始状态*，以及一些简单的数学函数，从当前状态生成下一个状态，称为*状态向量*。常见的生成函数包括加法、乘法和异或。由于它们的速度快且易于实现，这些生成器今天仍然被广泛使用。
- en: Each generator produces a sequence of integers that eventually repeats after
    a period that depends on the seed. It is possible to have a repeating sequence
    of numbers that never repeats the seed, like 1,2,3,4,5,4,5,4,5,4,5, ... , but
    none of the generators in this book have that behavior. The period is limited
    by the size of the state vector. For example, a generator whose state vector is
    three 31-bit integers cannot have a period longer than 2^(93).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生成器都会产生一个整数序列，在依赖于种子的周期之后最终会重复。可能会有一个永远不会重复种子的重复数字序列，例如 1,2,3,4,5,4,5,4,5,4,5,
    ... ，但本书中的生成器都没有这种行为。周期受状态向量大小的限制。例如，一个状态向量为三个 31 位整数的生成器的周期不能超过 2^(93)。
- en: 13.3 Multiplicative congruential generator
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 乘法同余生成器
- en: A *multiplicative congruential PRNG* uses two parameters, a multiplier m and
    a modulus p. Starting from the seed s, the sequence of pseudorandom numbers x[n]
    is generated by the recurrence
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*乘法同余伪随机数生成器*使用两个参数，一个是乘数 m，一个是模数 p。从种子 s 开始，伪随机数序列 x[n] 通过递推生成。
- en: '![13-equation-13-1](../Images/13-equation-13-1.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![13-equation-13-1](../Images/13-equation-13-1.png)'
- en: In other words, to get the next pseudorandom number you multiply the previous
    number by m and then take the residue modulo p. The seed may be any integer 1,2,3,
    ... ,p-1\. The modulus p is almost always chosen to be a prime because primes
    produce the longest periods. The choice of p often depends on the size of the
    registers in the computer you are using. For 32-bit registers, the prime 2^(31)-1,
    which is 2,147,483,647, is a common choice. The first PRNG in this class was published
    by Berkeley number theorist Derrick H. Lehmer (not to be confused with Berkeley
    number theorist Derrick N. Lehmer, his father) in 1949.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，要获取下一个伪随机数，你需要将上一个数乘以 m，然后取模 p 的余数。种子可以是任何整数 1,2,3, ... ,p-1。模数 p 几乎总是选择为质数，因为质数产生最长的周期。选择
    p 通常取决于您使用的计算机中寄存器的大小。对于 32 位寄存器，常见选择是素数 2^(31)-1，即 2,147,483,647，这是由伯克利数论学家 Derrick
    H. Lehmer（不要与他的父亲伯克利数论学家 Derrick N. Lehmer 混淆）在 1949 年发布的这一类中的第一个 PRNG。
- en: The multiplier m must be chosen carefully. The period of a multiplicative congruential
    generator can be any integer that evenly divides p-1\. Since p is a prime, and
    presumably far greater than 2, p-1 will be even, so a very poor choice of m, such
    as p-1, could give a period of 2\. A multiplier that has the maximum possible
    period, namely p-1, is called a *primitive root* of p. That means m, m², m³, ...
    , m^(p-1) all have different residues modulo p. For a multiplicative congruential
    generator, it is best to make m a primitive root in order to get the longest possible
    period.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 乘数 m 必须谨慎选择。乘法同余生成器的周期可以是任何均匀地整除 p-1 的整数。由于 p 是一个素数，且可能远大于 2，p-1 将是偶数，因此非常糟糕的选择
    m，比如 p-1，可能会得到一个周期为 2 的结果。具有最长周期的乘数，即 p-1，称为 p 的 *原根*。这意味着 m、m²、m³、...、m^(p-1)
    在模 p 下有不同的余数。对于乘法同余生成器，最好使 m 成为原根，以获得最长可能的周期。
- en: Fortunately, this is easy to do. On average just slightly less than 3/8 of the
    numbers in the range 2 to p-2 are primitive roots of p. The exact ratio is called
    *Artin’s constant*, for Emil Artin, an Austrian mathematician who escaped from
    Nazi Germany in 1937 and finished his career at Princeton. Its value is about
    .373956\. If you can factor p-1, then it is easy to test whether a given multiplier
    m is a primitive root of p. We know that the period of m must divide p-1, so begin
    by factoring p-1\. Suppose the distinct prime factors of p-1 are a, b, c and d.
    Then you only need to test m^((p-1)/a) (mod p), m^((p-1)/b) (mod p), m^((p-1)/c)
    (mod p) and m^((p-1)/d) (mod p). If none of these are 1, then m is a primitive
    root. For example, if p = 13, the distinct prime factors of p-1 = 12 are 2 and
    3, so you only need to test exponents 12/2 and 12/3, that is, m⁶ and m⁴. For example,
    5 is not a primitive root of 13 because 5⁴ = 625≡1 mod 13.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这很容易做到。在范围为 2 到 p-2 的数中，平均约有不到 3/8 的数字是 p 的原根。这个确切的比率被称为 *阿丁常数*，以奥地利数学家埃米尔·阿丁（Emil
    Artin）的名字命名，他于 1937 年逃离纳粹德国，并在普林斯顿完成了他的职业生涯。它的值约为 .373956。如果您可以因式分解 p-1，那么很容易测试给定的乘数
    m 是否是 p 的原根。我们知道 m 的周期必须整除 p-1，因此首先将 p-1 进行因式分解。假设 p-1 的不同素因子是 a、b、c 和 d。然后，您只需要测试
    m^((p-1)/a) (mod p)，m^((p-1)/b) (mod p)，m^((p-1)/c) (mod p) 和 m^((p-1)/d) (mod
    p)。如果这些值中没有一个是 1，则 m 是一个原根。例如，如果 p = 13，则 p-1 的不同素因子为 2 和 3，因此您只需要测试指数 12/2 和
    12/3，即 m⁶ 和 m⁴。例如，5 不是 13 的原根，因为 5⁴ = 625 ≡ 1 mod 13。
- en: There are efficient ways to compute m^x by taking successive squares. For example,
    to compute m^(21) you could successively compute m², m⁴, m⁸, m^(16), m^(20), m^(21)
    using just 6 multiplications. You can get further efficiencies by using these
    products to compute the next power. For example, if the next value to test were
    m^(37), you could compute m^(32), m^(36), m^(37) using just 3 multiplications.
    It is more efficient to calculate the residue modulo p after each multiplication
    than to compute the huge number m^(21) and take the residue at the end. There
    are more sophisticated schemes that use somewhat fewer multiplications, perhaps
    10% to 15% fewer, but if you are doing this only a few times the extra effort
    is not worthwhile.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有有效的方法来通过连续的平方来计算 m^x。例如，要计算 m^(21)，您可以连续计算 m²、m⁴、m⁸、m^(16)、m^(20)、m^(21)，只需进行
    6 次乘法运算。您可以通过使用这些乘积来计算下一个幂值来获得进一步的效率。例如，如果要测试的下一个值是 m^(37)，您可以只使用 3 次乘法运算计算出 m^(32)、m^(36)、m^(37)。在每次乘法运算后计算模
    p 的余数要比计算庞大的数 m^(21) 并在最后取余更有效。有更复杂的方案可以使用稍少的乘法运算，可能减少 10% 到 15%，但如果您只做几次，额外的努力是不值得的。
- en: If you are using a multiplicative congruential PRNG it is important to know
    that it is the magnitude of each number that shows random properties. To convert
    an output R of the generator to an integer in the range 0 to N-1, the correct
    calculation is ⌊RN/p⌋, where ⌊x⌋, read “floor of x,” means x rounded down to the
    next lower integer. For example, ⌊27⌋ is 27, and ⌊27.999⌋ is 27\. The expression
    ⌊RN/p⌋ is slightly biased toward smaller values, that is, it will yield lower
    numbers slightly more frequently than higher numbers. However, when p is much
    larger than N, say p > 1000N, this will not matter for cryptographic purposes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是乘法同余伪随机数生成器（PRNG），则重要的是要知道每个数字的大小显示出随机特性。要将生成器的输出 R 转换为范围在 0 到 N-1 的整数，正确的计算方式是⌊RN/p⌋，其中⌊x⌋表示“x的地板”，意思是将
    x 向下舍入到下一个较低的整数。例如，⌊27⌋是27，⌊27.999⌋是27。表达式⌊RN/p⌋略微偏向于较小的值，即，它会比较频繁地产生较小的数字。但是，当
    p 远远大于 N，比如 p > 1000N 时，这对于加密目的并不重要。
- en: Historical aside
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 历史旁注
- en: Incidentally, the notation ⌊x⌋ and the corresponding ⌈x⌉ (read “ceil of x,”
    which means x rounded up to the next higher integer, so ⌈27.001⌉ is 28) were both
    invented by Kenneth Iverson, the creator of the APL programming language, in 1962\.
    APL was the first interactive programming language. Computer users today take
    interactivity for granted. You press a key or click the mouse, and the computer
    does something. They do not realize that this concept had to be invented. Before
    then, the standard model for computing was that you ran a card deck through a
    card reader, the computer printed the results, and a few hours later you got a
    sheaf of paper.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，符号⌊x⌋和相应的⌈x⌉（读作“x的ceil”，意思是将x四舍五入到下一个更高的整数，因此⌈27.001⌉为28）都是由肯尼斯·艾弗森（Kenneth
    Iverson）在1962年发明的，他是APL编程语言的创造者。APL是第一种交互式编程语言。今天的计算机用户认为交互性理所当然。您按下一个键或点击鼠标，计算机就会执行某些操作。他们没有意识到这个概念必须被发明。在那之前，计算的标准模型是您通过卡片阅读器运行一叠卡片，计算机打印结果，几个小时后您得到一叠纸。
- en: WARNING Do not use (R mod N) as your random number. R mod N can be severely
    biased toward low values. For example, if the modulus p = 11 and N = 7, then the
    11 possible values of (R mod 7) are 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, so that 0,
    1, 2 and 3 are generated twice as often as 4, 5 or 6.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：不要使用(R mod N)作为您的随机数。R mod N可能严重偏向低值。例如，如果模数p = 11，N = 7，那么(R mod 7)的11个可能值为0,
    1, 2, 3, 4, 5, 6, 0, 1, 2, 3，因此0, 1, 2和3的生成频率是4, 5或6的两倍。
- en: A multiplicative congruential generator will have decent random properties as
    long as m > √p. It is best if the multiplicative inverse m' > √p as well. This
    means that the number of bits in m needs to be at least half the number of bits
    in p. You want p to be as large as possible so the generator will have a long
    period, and you want m to be large so the generator is random. How big can you
    go? The sizes of m and p are limited by the size of the registers in the computer.
    If you go bigger than one register, you will pay a penalty in speed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 只要m > √p，乘法同余生成器将具有良好的随机特性。最好是乘法逆m' > √p。这意味着m的位数至少需要是p位数的一半。您希望p尽可能大，以便生成器具有长周期，同时希望m足够大，以便生成器是随机的。您可以走多远？m和p的大小受计算机寄存器的大小限制。如果超过一个寄存器，速度将受到惩罚。
- en: Each pseudorandom number x[n] is generated by multiplying the previous number
    x[n-1] by m. The number x[n-1] can have as many bits as p, so if p has b bits,
    x[n-1] can also have b bits. Since m must have at least b/2 bits, the product
    mx[n-1] can have 3b/2 bits. If the register size is 63 bits, then b can be at
    most 2/3 of 63, namely 42, which means m could have at most 21 bits. It is better
    to make m larger than √p. A reasonable trade-off is for m to be 25 bits and for
    p to be 38 bits. That lets the period be up to 2^(38).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个伪随机数x[n]是通过将前一个数字x[n-1]乘以m生成的。数字x[n-1]可以有与p相同数量的位，因此如果p有b位，则x[n-1]也可以有b位。由于m必须至少有b/2位，因此乘积mx[n-1]可以有3b/2位。如果寄存器大小为63位，则b最多可以是63的2/3，即42，这意味着m最多可以有21位。最好使m大于√p。一个合理的折衷方案是m为25位，p为38位。这样可以让周期长达2^(38)。
- en: The property that is required to make the generator unpredictable is that the
    generated units have equal or uniform frequencies, pairs of units have equal frequencies,
    triples and quadruples have equal frequencies, and so forth. As a practical matter,
    you need not go beyond octuples or at most dectuples of bytes. If you want to
    be absolutely dead sure, take your desired key size and divide by the size of
    the generated units. For example, if your key size is 128 bits and the PRNG generates
    4-bit hex digits, then you might require the n-tuples to have equal frequencies
    for all values of n up through 32\. (Anyone who does that is clearly obsessive-compulsive
    and should seek treatment.) Even for 4-bit random numbers it is neither necessary
    nor useful to go beyond 16-tuples or at most 20-tuples (sexdectuples or vigintuples),
    that is, 64 or 80 bits.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使生成器不可预测所需的属性是生成的单位具有相等或均匀的频率，成对的单位具有相等的频率，三元组和四元组具有相等的频率，依此类推。实际上，您不需要超过八元组或最多十元组的字节。如果您想要绝对确定，可以将所需的密钥大小除以生成的单位的大小。例如，如果您的密钥大小为128位，PRNG生成4位十六进制数字，则您可能需要使n元组在所有n值上的频率相等，直到32。
    （那些这样做的人显然是强迫症患者，应该寻求治疗。）即使对于4位随机数，也没有必要也没有用处超过16元组或最多20元组（sexdecuples或vigintuples），即64或80位。
- en: Emily would need more than 2^(64) or 2^(80) bytes, respectively, of known plaintext
    to exploit these uneven frequencies. Even if Sandra never changed her key, it
    is implausible that Emily could ever accumulate that much material. To put this
    in perspective, suppose there were a satellite that beamed down telemetry at the
    rate of 1 MB per second. Suppose, further, that it beams this data down using
    two different key streams simultaneously, and that Emily has the key for one of
    them. Even though she is getting plaintext/ciphertext pairs at the rate of 1 MB
    per second, it would still take about 585,000 years for her to collect 2^(64)
    bytes. Even with 1000 satellites all using the same keys, it would take 585 years.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Emily需要超过2^(64)或2^(80)字节的已知明文才能利用这些不均匀的频率。即使Sandra从不更改她的密钥，Emily也不可能积累那么多的材料。从长远来看，假设有一颗卫星以每秒1
    MB的速率发送遥测数据。进一步假设，它同时使用两个不同的密钥流发送这些数据，而Emily拥有其中一个密钥。即使她以每秒1 MB的速度获取明文/密文对，她仍需要大约585,000年才能收集到2^(64)字节。即使有1000颗卫星都使用相同的密钥，也需要585年。
- en: If the frequencies of the n-tuples are equal for every value of n, then your
    generator is true random. You have found a mathematical algorithm for generating
    true random numbers. Congratulations. Go collect your Fields Medal.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对于每个n的所有值，n元组的频率都相等，则您的生成器是真随机的。您已经找到了一种生成真随机数的数学算法。恭喜。去领取您的菲尔兹奖。
- en: In order to have the tuple frequencies equal up through n-tuples it is generally
    necessary for the generator to have seeds that are themselves at least n-tuples.
    For multiplicative congruential generators the single-unit and pair frequencies
    are uniform, but the triples frequencies are never uniform, and the n-tuple frequencies
    for n > 3 are very far from uniform; most of these frequencies are 0.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使元组频率在n元组中相等，通常需要生成器的种子本身至少是n元组。对于乘法同余生成器来说，单个单位和对频率是均匀的，但三元组频率从不均匀，而对于n >
    3的n元组频率则远非均匀；其中大多数频率为0。
- en: Cracking a multiplicative congruential cipher is straightforward if you have
    a few characters of known plaintext, and if the cipher makes it easy to determine
    the random output from a plaintext/ciphertext pair, that is, if the combining
    function is **xor**, **add** or **madd**. For example, if the cipher exclusive-ORs
    the key byte to the plaintext byte to get the ciphertext byte, then all Emily
    needs to do is exclusive-OR the plaintext byte with the ciphertext byte to get
    the key byte.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有几个已知明文字符，并且密码使得很容易从明文/密文对确定随机输出，即，如果组合函数是**xor**、**add**或**madd**，那么破解乘法同余密码就很简单。例如，如果密码通过对密钥字节和明文字节进行异或运算来获取密文字节，那么Emily所需要做的就是将明文字节与密文字节进行异或运算以获取密钥字节。
- en: If the generator has a 31-bit or 32-bit modulus, it is feasible for Emily to
    try all 2^(31) or 2^(32) values for the seed, even on a PC. The known plaintext
    characters would be used merely for verification. If the modulus is larger, say
    48 or 64 bits, then the first 2 or 4 known plaintext characters are used to limit
    the search range. The first random output limits the current state of the generator
    to a narrow range, 1/256 of the total range. A second known plaintext character
    gives a second output that limits the state to 1/256 of that range, and so forth.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成器有一个31位或32位的模，即使在个人电脑上，Emily也可以尝试所有2^(31)或2^(32)种种子的值。已知的明文字符仅用于验证。如果模数更大，例如48位或64位，则前2个或4个已知的明文字符用于限制搜索范围。第一个随机输出将当前生成器状态限制在一个窄范围内，即总范围的1/256。第二个已知的明文字符给出第二个输出，将状态限制在该范围的1/256，依此类推。
- en: Thus a single multiplicative congruential generator is not cryptographically
    secure. It is possible to use a much larger modulus, using big-integer multiplication
    techniques like Karatsuba or Toom-Cook, but that would sacrifice the high speed
    of this class of generator. There are faster ways to produce cryptographically
    secure generators, so this book will not cover big-integer multiplication methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，单个乘法同余生成器在密码学上并不安全。可以使用更大的模数，使用卡拉兹巴或图姆-库克等大整数乘法技术，但这会牺牲这一类生成器的高速度。有更快的方法来生成密码安全的生成器，因此本书不会涉及大整数乘法方法。
- en: 13.4 Linear congruential generator
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 线性同余生成器
- en: '*Linear congruential generators* are an extension of the multiplicative congruential
    generators. They add a linear constant term c to the recurrence formula. Starting
    from the seed s, the sequence of pseudorandom numbers x[n] is generated by the
    recurrence'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性同余生成器*是对乘法同余生成器的扩展。它们在递推公式中添加一个线性常数项 c。从种子 s 开始，通过递推生成伪随机数序列 x[n] 的是公式是'
- en: '![13-equation-13-2](../Images/13-equation-13-2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![13-equation-13-2](../Images/13-equation-13-2.png)'
- en: 'In other words, to get the next pseudorandom number you multiply the previous
    number by m, add c and then take the residue of that sum modulo P. The seed may
    be any integer 1, 2, 3, ... , P-1\. The generator will have the longest possible
    period when these three conditions are met:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，要获得下一个伪随机数，你将前一个数字乘以 m，加上 c，然后取该和对 P 的模。种子可以是任何整数 1、2、3、...、P-1。当满足以下三个条件时，生成器将具有最长可能的周期：
- en: c is relatively prime to P,
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c 与 P 互质，
- en: For every prime p that is a factor of P, m has the form pk+1, and
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个是 P 因子的素数 p，m 的形式为 pk+1，且
- en: If P is a multiple of 4, then m has the form 4k+1,
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 P 是 4 的倍数，则 m 的形式为 4k+1，
- en: where k may be any integer. These are called the *Hull-Dobell conditions* for
    T. E. Hull and A. R. Dobell of the University of British Columbia, who published
    them in 1962.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 k 可以是任意整数。这些被称为 T. E. Hull 和 A. R. Dobell 在 1962 年发表的*Hull-Dobell条件*。
- en: For example, suppose P = 30, which is 2×3×5\. Then m-1 must be a multiple of
    2, of 3 and of 5\. In other words, m must be 1\. So, if s = 1 and c = 7, the pseudorandom
    sequence would be 1, 8, 15, 22, 29, ... This is an arithmetic progression, and
    not at all random. For this reason, the modulus P is usually chosen to be a power
    of a prime, most commonly 2\. It is difficult to find values for m, c and P that
    produce good random properties.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 P = 30，即 2×3×5。那么 m-1 必须是 2、3 和 5 的倍数。换句话说，m 必须是 1。所以，如果 s = 1，c = 7，伪随机序列将是
    1、8、15、22、29、...。这是一个等差数列，一点也不随机。因此，通常选择模数 P 为质数的幂，最常见的是 2。找到产生良好随机特性的 m、c 和 P
    的值是困难的。
- en: There is, however, one good use for linear congruential generators. If you want
    to produce a generator that has an extremely long period, you can add the outputs
    of two or more linear congruential generators whose moduli are powers of different
    primes to get a generator with good random properties and a period equal to the
    product of those moduli. For example, suppose you added the outputs of the following
    three PRNGs. I chose the 3 moduli to be as large as possible, yet still fit in
    a 32-bit machine word, and I chose the multipliers and constants to satisfy the
    Hull-Dobell conditions. Other than that, I chose them arbitrarily.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，线性同余生成器有一个很好的用途。如果你想产生一个具有极长周期的生成器，你可以将两个或多个模数为不同质数幂的线性同余生成器的输出相加，以获得具有良好随机特性和周期等于这些模数乘积的生成器。例如，假设你添加了以下三个
    PRNG 的输出。我选择了 3 个模数尽可能大，但仍适合于 32 位机器字，我选择了乘数和常数以满足 Hull-Dobell 条件。除此之外，我任意选择了它们。
- en: '![13-equation-13-3](../Images/13-equation-13-3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![13-equation-13-3](../Images/13-equation-13-3.png)'
- en: Let w[n] = (x[n]+y[n]+z[n]) mod 2^(31). Select the high-order byte of w[n] by
    shifting it right 23 places, namely v[n] = w[n]/2^(23). The v[n] sequence will
    have good random properties provided that (1) at least one of the three multipliers,
    and its multiplicative inverse, are greater than the square root of its corresponding
    modulus, and (2) neither of the other two multipliers is 1 or P-1\. The period
    of the v[n] sequence is 2^(31)3^(19)5^(13) = 3.0468×10^(27).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让 w[n] = (x[n]+y[n]+z[n]) mod 2^(31)。通过将其右移 23 位来选择 w[n] 的高阶字节，即 v[n] = w[n]/2^(23)。只要
    (1) 三个乘数中至少有一个，以及它的乘法逆元，大于其对应模数的平方根，且 (2) 其余两个乘数都不是 1 或 P-1，那么 v[n] 序列将具有良好的随机特性。v[n]
    序列的周期为 2^(31)3^(19)5^(13) = 3.0468×10^(27)。
- en: 13.5 Chained exclusive-OR generator
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 链式异或生成器
- en: The simplest *chained exclusive-OR generator* operates on a string of bits,
    like 10111\. The basic idea is to exclusive-OR the first bit to the last bit,
    delete the first bit, and append the new bit to the end of the string, that is,
    x[i] = x[i-1]⊕x[i-n]. Since there are 2^n possible values for an n-bit string,
    and since the all-zero string produces a sequence of all zeros, the longest possible
    period for a chained exclusive-OR generator is 2^n-1\. Let’s look at a small example
    using 3-bit strings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的*链式异或生成器*操作的是一串比特，例如 10111。基本思想是将第一个比特与最后一个比特进行异或操作，删除第一个比特，并将新比特附加到字符串的末尾，即
    x[i] = x[i-1]⊕x[i-n]。由于 n 位字符串有 2^n 种可能的值，而且由于全零字符串产生一系列全零，链式异或生成器的最长周期为 2^n-1。让我们用
    3 位字符串的一个小例子来看一下。
- en: '![13-unnumb-1](../Images/13-unnumb-1.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-1](../Images/13-unnumb-1.png)'
- en: After 7 steps the initial string 001 repeats, so the period of this generator
    is 7\. This is called a *full period* generator. The chained exclusive-OR generator
    has a full period when n is 2, 3, 4, 6, 7, 15 or 22\. For n = 37 the generator
    comes within .00057% of being full period. That is, 99.99943% of all 37-bit values
    form one large cycle, and the rest belong to shorter cycles. For some purposes
    n = 37 may be a good choice. For most values of n there are several repeating
    sequences of bits, some short and some long. Their combined lengths total 2^n-1\.
    You can talk about *the* period only for full period generators. Otherwise there
    will be multiple cycles that may have differing lengths.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 经过 7 步后，初始字符串 001 重复，因此该生成器的周期为 7。这称为*完整周期*生成器。当 n 为 2、3、4、6、7、15 或 22 时，链式异或生成器具有完整周期。对于
    n = 37，该生成器接近于完整周期的概率为 0.00057%。也就是说，99.99943% 的所有 37 位值形成一个大循环，而其余的属于较短的循环。对于某些目的，n
    = 37 可能是一个不错的选择。对于大多数 n 值，存在若干个重复的比特序列，有些短，有些长。它们的总长度为 2^n-1。只有对于完整周期生成器才能谈论*周期*。否则会有多个循环，可能长度不同。
- en: Suppose that you need a generator with a period longer than 2^(22), and you
    are unwilling to take a .00057% chance of getting a short cycle. What can you
    do? One option is to try other generating functions. Instead of x[i] = x[i-1]⊕x[i-n],
    try the recurrence relation x[i] = x[i-1]⊕x[i-j]⊕x[i-k]⊕x[i-n] for values of j
    and k such that 1 < j < k < n. There is a good chance that some of these generators
    will have a full period. Note, however, that x[i] = x[i-1]⊕x[i-j]⊕x[i-n], which
    has 3 terms, can never produce a full period generator. There must be an even
    number of terms.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个周期长于 2^(22) 的生成器，并且不愿意冒获得短周期的 0.00057% 的风险。你可以怎么做？一个选择是尝试其他生成函数。而不是使用
    x[i] = x[i-1]⊕x[i-n] 的递归关系，尝试使用 x[i] = x[i-1]⊕x[i-j]⊕x[i-k]⊕x[i-n] 的递归关系，其中 j
    和 k 的值使得 1 < j < k < n。这些生成器中很有可能有一些具有完整周期。但是请注意，具有 3 项的 x[i] = x[i-1]⊕x[i-j]⊕x[i-n]
    的生成器永远不会产生完整周期。项数必须是偶数。
- en: Whichever generator you choose, the result is a sequence of bits. To get a pseudorandom
    sequence of bytes, take the bits in groups of 8, that is, bits 1 to 8, bits 9
    to 16, bits 17 to 24, and so forth. That requires generating 8 bits for every
    byte. There is a faster way. Instead of exclusive-ORing single bits, exclusive-OR
    a byte at a time. In effect, you are running 8 separate single-bit generators
    in parallel. That way, you get a whole byte in one operation each time. If your
    programming language supports it, you could use full 32-bit words and get 4 bytes
    at a time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个生成器，结果都是一系列比特序列。要得到伪随机的字节序列，将比特按照8位一组取出，即比特 1 到 8，比特 9 到 16，比特 17 到 24，依此类推。这需要为每个字节生成
    8 位比特。有一种更快的方法。不是逐比特进行异或操作，而是一次异或一个字节。实际上，您是同时运行 8 个单比特生成器。这样，每次操作就可以获得一个完整的字节。如果你的编程语言支持，你可以使用完整的
    32 位字，并每次获取 4 个字节。
- en: Any of the combining functions listed in section 13.1 can be used to combine
    the pseudorandom stream with the plaintext to form a cipher. If Sandra chooses
    the combining function **xor**, **add** or **madd**, then the cipher will be easy
    for Emily to solve, provided she has enough known plaintext. She can easily determine
    the random outputs corresponding to the plaintext characters. This lets her reconstruct
    a section of the key stream. This section can be extended both ahead and back
    to reconstruct the entire key stream merely by exclusive-ORing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 13.1 节列出的任何组合函数都可以用于将伪随机流与明文组合成密码。如果 Sandra 选择**xor**、**add**或**madd**作为组合函数，那么密码将很容易让
    Emily 解密，前提是她拥有足够的已知明文。她可以轻松确定与明文字符对应的随机输出。这使她可以重构密钥流的一部分。这一部分可以向前和向后延伸，仅通过进行异或操作就可以重构整个密钥流。
- en: There is a trick that Sandra can use to confound Emily. Suppose that the generator
    produces a sequence of 32-bit words, which Sandra carves up into four separate
    bytes. Instead of always starting with the high-order bit, Sandra could start
    from a different position each time. Equivalently, Sandra could shift the 32-bit
    word cyclically, either left or right, by a varying number of bit positions. For
    example, ABCDEF cyclically shifted left 2 positions gives CDEFAB. The lengths
    of the shifts could be a repeating sequence of numbers in the range 0 to 31\.
    This way, Emily cannot match up successive outputs of the generator to reconstruct
    the key stream.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Sandra 可以使用一个技巧来迷惑 Emily。假设生成器产生一系列 32 位字，Sandra 将其分成四个单独的字节。Sandra 不一定总是从高阶位开始，而是每次可以从不同位置开始。等效地，Sandra
    可以将 32 位字循环左移或右移，位移数量不同。例如，ABCDEF 循环左移 2 位得到 CDEFAB。位移的长度可以是在 0 到 31 范围内的重复数字序列。这样，Emily
    无法将生成器的连续输出匹配起来以重构密钥流。
- en: 13.6 Chained addition generator
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 链式加法生成器
- en: '*Chained addition generators*, also called *lagged Fibonacci* generators, are
    similar to chained exclusive-OR generators, except that they use addition instead
    of exclusive-OR. The addition is understood to be modulo 2^w, where w is the word
    size in bits, x[i] = (x[i-1]+x[i-n]) mod 2^w. Typical values for w are 15, 31
    and 63 using signed addition, or 16, 32 and 64 using unsigned addition. Another
    way of looking at the mod 2^w operation is that the carry out of the high-order
    bit is ignored.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*链式加法生成器*，也称为*滞后斐波那契*生成器，类似于链式异或生成器，只是它们使用加法而不是异或。加法被理解为模 2^w，其中 w 是位大小，x[i]
    = (x[i-1]+x[i-n]) mod 2^w。w 的典型值为 15、31 和 63，使用有符号加法，或者 16、32 和 64，使用无符号加法。另一种看待
    mod 2^w 运算的方式是忽略高阶位的进位。'
- en: Because addition produces carries from one bit position to the next-higher bit
    position, the period of the higher bit is twice the period of the lower bit. The
    period of the low-order bit in each word is the same as the period of an exclusive-OR
    generator with the same seeds. That is because addition is the same as exclusive-OR
    with a carry. If the period of the low-order bit in a chained addition generator
    is P, then the period of the high-order bit is 2^(w-1)P.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为加法会从一个位位置产生进位到下一个更高位位置，所以高位的周期是低位的两倍。每个字中低阶位的周期与具有相同种子的异或生成器的周期相同。这是因为加法与带进位的异或相同。如果链式加法生成器中低阶位的周期为
    P，则高阶位的周期为 2^(w-1)P。
- en: Chained additive generators are an easy way to get a longer period for little
    additional effort. Just find a chained exclusive-OR generator with a long period,
    preferably a full period, and then expand it from single-bit width to full word
    width. Like the multiplicative congruential generators, the most random part of
    the sequence of outputs is the high-order end. For a sequence of pseudorandom
    bytes, use only the high-order 8 bits of each word.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 链式加法生成器是一种简单的方法，可以在很少的额外工作量下获得更长的周期。只需找到一个具有长周期的链式异或生成器，最好是完整周期，然后将其从单比特宽度扩展到完整字宽度。与乘法同余生成器一样，输出序列中最随机的部分是高阶端。对于伪随机字节序列，只使用每个字的高阶
    8 位。
- en: Once again, you may use any of the combining functions from section 13.1 to
    combine the pseudorandom stream with the plaintext to form a cipher.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可以使用第 13.1 节中的任何组合函数将伪随机流与明文组合成密码。
- en: 13.7 Shift and XOR generator
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7 移位和异或生成器
- en: Another class of PRNGs is the shift and exclusive-OR generators invented by
    George Marsaglia of Florida State University. Marsaglia is best known for developing
    the Diehard suite of random number tests. These generators use two operators that
    work on integers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类 PRNG 是由佛罗里达州立大学的 George Marsaglia 发明的移位和异或生成器。Marsaglia 最著名的是开发了 Diehard
    随机数测试套件。这些生成器使用两个作用于整数的运算符。
- en: << *Shift left.* For example, 80<<2 shifts the integer 80 left 2 bit positions
    to give the value 320.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: << *左移.* 例如，80<<2 将整数 80 左移 2 位，得到值 320。
- en: '>> *Shift right*. For example, 80>>2 shifts the integer 80 right 2 bit positions
    to give the value 20.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '>> *右移.* 例如，80>>2 将整数 80 右移 2 位，得到值 20。'
- en: Bits that are shifted out of the high- or low-order end of the computer word
    are lost. For example, 25>>1 is 12, not 12.5\. These operations contrast with
    the cyclic shifts <<< and >>>, where the bits that are shifted out of one end
    of the computer word are placed at the opposite end. For example, if the hex digits
    in a 32-bit computer word are 12345678, then 12345678<<<4 gives 23456781, and
    12345678>>>12 gives 67812345, because each hex digit has 4 bits. If the word is
    contained within a larger computer register, the unused bits need to be zeroed
    out.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 被移出计算机字的高位或低位的位将会丢失。例如，25>>1 是 12，而不是 12.5。这些操作与循环左移 <<< 和右移 >>> 相对应，其中被移出计算机字一端的位将被放置在相反端。例如，如果32位计算机字中的十六进制数字为
    12345678，则 12345678<<<4 得到 23456781，而 12345678>>>12 得到 67812345，因为每个十六进制数字有 4
    位。如果字包含在较大的计算机寄存器中，则未使用的位需要清零。
- en: There are several different generators in this class. The lengths and directions
    of the shifts must be carefully chosen so that the generator will have a long
    period. Following are two examples of the *Xorshift* generator devised by Marsaglia.
    They have long periods, and strong random properties, although they fail some
    of the more sensitive randomness tests. Each generator uses 3 shift and exclusive-OR
    steps in a left-right-left pattern to produce the next number in the sequence.
    The variable y is used to hold intermediate values. Any positive integer is a
    qualified seed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中有几种不同的生成器。必须仔细选择位移的长度和方向，以使生成器具有长周期。以下是 Marsaglia 设计的两个 *Xorshift* 生成器的示例。它们具有长周期和强大的随机特性，尽管它们未通过一些更敏感的随机性测试。每个生成器使用左-右-左的模式中的
    3 次位移和异或步骤来生成序列中的下一个数字。变量 y 用于保存中间值。任何正整数都是合格的种子。
- en: '![13-unnumb-1-equation-13-4](../Images/13-unnumb-1-equation-13-4.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-1-equation-13-4](../Images/13-unnumb-1-equation-13-4.png)'
- en: 13.8 FRand
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.8 FRand
- en: FRand, for Fast Random generator, is my own creation. FRand uses an array of
    S binary words of width W, that is, it uses the low-order W bits of each word
    in the array to hold an unsigned integer value. The period depends on the values
    of S and W. I have found that W = 29 works best, and that S = 40 and S = 64 give
    extremely long periods. The array of seeds can be viewed as a 40×29 matrix of
    bits. Each row is one seed, and each column represents one bit position within
    each seed word.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: FRand，即快速随机生成器，是我自己的创建。FRand 使用一个宽度为 W 的 S 个二进制字的数组，也就是说，它使用数组中每个字的低位 W 位来保存无符号整数值。周期取决于
    S 和 W 的值。我发现 W = 29 效果最好，而且 S = 40 和 S = 64 给出了非常长的周期。种子数组可以看作是一个 40×29 位的矩阵。每一行是一个种子，每一列代表种子字中的一个位位置。
- en: For S = 40 the period is 2^(1160)-2^(40), about 1.566×10^(349), for qualified
    seeds. A seed is *qualified* if at least one of the 40 seed words is neither all-zeros
    nor all-ones. This generator has a weakness. If the seed array contains almost
    entirely zeros, then the generator may produce dozens or even hundreds of successive
    outputs that are mostly zero. In the extreme case, when the seed array contains
    1159 zeros and only 1 one, it will take at least 1120 cycles before there is at
    least one 1 in every column.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 S = 40，周期为 2^(1160)-2^(40)，约为 1.566×10^(349)，对于合格种子。如果至少有一个 40 个种子字中的一个既不全为零也不全为一，则该种子是
    *合格* 的。该生成器有一个弱点。如果种子数组几乎完全为零，则生成器可能会产生数十甚至数百个连续的输出，其中大部分是零。在极端情况下，当种子数组包含 1159
    个零和仅 1 个一时，至少需要 1120 个周期才能在每列中至少有一个 1。
- en: It is best if the initial seeds contain plenty of ones and zeros in a random-looking
    pattern. One way to get a suitable seed array is to take a mnemonic or numerical
    key expressed in UTF-8 code, and hash it into an 1160-bit value. A suitable hash
    function is
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最好是初始种子包含大量随机模式中的 1 和 0。获取适当的种子数组的一种方法是将表达为 UTF-8 代码的助记符或数字密钥，并将其哈希为一个 1160
    位值。一个合适的哈希函数是
- en: '![13-unnumb-1-equation-13-5](../Images/13-unnumb-1-equation-13-5.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-1-equation-13-5](../Images/13-unnumb-1-equation-13-5.png)'
- en: Once the generator has been seeded, the pseudorandom sequence can be generated
    by the recurrence formula. The recurrence formula for this generator uses an index
    or placemarker, n.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器一旦被初始化，伪随机序列就可以通过递推公式生成。此生成器的递推公式使用索引或标记符号 n。
- en: '![13-unnumb-1-equation-13-6](../Images/13-unnumb-1-equation-13-6.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-1-equation-13-6](../Images/13-unnumb-1-equation-13-6.png)'
- en: At the end of each pass through the seed array, when n = 40, the index is reset
    to 1, and the next pseudorandom number is generated by x[1] = (x[1]⊕x[40])>>>1\.
    That is, the first 29-bit word x[1] is cyclically shifted right one bit position.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过种子数组时，当 n = 40 时，索引会重置为 1，并且下一个伪随机数将由 x[1] = (x[1]⊕x[40])>>>1 生成。也就是说，第一个
    29 位字 x[1] 循环向右移动一个位位置。
- en: This pseudorandom sequence passes many of the randomness tests, but it falls
    far short of being cryptographically secure. To produce a secure sequence, the
    trick is to take each successive output byte from a different part of the 29-bit
    word. The pseudorandom sequence itself can be used to select these locations.
    Suppose the next 3 pseudorandom outputs are a, b and c. Take s = a mod 25\. If
    s is in the range 0 to 21, then shift b right by s positions and take the low-order
    8 bits. In this case only a and b are generated. c will be generated for the next
    pseudorandom number. If s > 21, then shifting s positions right would leave fewer
    than 8 bits. In this case discard a and take s = b mod 22\. Shift c right by s
    positions and take the low-order 8 bits as the random output. To put this algebraically,
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪随机序列通过了许多随机性测试，但远远达不到密码学安全的要求。为了产生一个安全的序列，诀窍是从 29 位字的不同部分获取每个连续的输出字节。伪随机序列本身可以用来选择这些位置。假设下一个
    3 个伪随机输出分别是 a、b 和 c。取 s = a mod 25。如果 s 在 0 到 21 的范围内，则将 b 向右移动 s 个位置并取低 8 位。在这种情况下只生成
    a 和 b。c 将为下一个伪随机数生成。如果 s > 21，则将 s 位置向右移动会留下少于 8 位。在这种情况下丢弃 a 并取 s = b mod 22。将
    c 向右移动 s 个位置并将低 8 位作为随机输出。代数表示如下，
- en: '![13-unnumb-1-equation-13-7](../Images/13-unnumb-1-equation-13-7.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-1-equation-13-7](../Images/13-unnumb-1-equation-13-7.png)'
- en: This process uses an average of 2.12 pseudorandom outputs to produce each secure
    key byte. That way, the key byte comes from the even-numbered outputs about half
    the time, and from the odd-numbered outputs half the time. The generator switches
    back and forth from odd to even and back about once every 8 cycles in an irregular
    pattern.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程平均使用 2.12 个伪随机输出来产生每个安全密钥字节。这样，密钥字节大约一半的时间来自偶数输出，另一半的时间来自奇数输出。生成器会以不规则的方式大约每
    8 个周期在奇数和偶数之间来回切换。
- en: 13.9 Mersenne Twister
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.9 梅森推土机
- en: '*Mersenne Twister* has the longest period of any class of PRNG. It was developed
    in 1997 by Makoto Matsumoto and Takuji Nishimura of Hiroshima University. It is
    named for French theologian Marin Mersenne, 1588-1648, widely known for his work
    on primes of the form 2^n-1, and important for disseminating the works of Galileo,
    Descartes, Pascal and Fermat, among others.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*梅森推土机* 是任何 PRNG 类别中周期最长的。它由广岛大学的松本真和西村拓士于 1997 年开发。它以法国神学家马林·梅森（Marin Mersenne，1588-1648）的名字命名，他以形式为
    2^n-1 的素数而闻名，并因传播伽利略、笛卡尔、帕斯卡和费马等人的作品而广为人知。'
- en: The twister has decent random properties, although it fails some randomness
    tests. It is far slower than the other random number generators described in this
    chapter. Its main importance is its humongous period, the Mersenne prime 2^(19937)-1,
    which was discovered in 1971 by Bryant Tuckerman of IBM Research, Yorktown, NY.
    IBM Research was so proud of this discovery that it put “2^(19937)-1 is prime”
    on its stationery and its postage meter imprint.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*推土机* 具有良好的随机特性，尽管它在一些随机性测试中失败。它比本章描述的其他随机数生成器要慢得多。它的主要重要性在于其庞大的周期，即梅森素数 2^(19937)-1，该数在
    1971 年由 IBM 纽约州约克敦的 IBM 研究院的 Bryant Tuckerman 发现。IBM 研究院为此发现感到非常自豪，将“2^(19937)-1
    是质数”印在了其信笺和邮资表上。'
- en: Like FRand, Mersenne Twister suffers from the drawback that if the initial state
    is mostly zero, it could take many cycles to become random-looking. With the Mersenne
    Twister it is common to require 10,000 or even 50,000 startup cycles before beginning
    to use the outputs. By contrast, the FRand package has a function that initializes
    the generator without needing any startup cycles.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与 FRand 一样，梅森推土机也存在一个缺点，即如果初始状态大部分为零，则可能需要许多周期才能变得看起来随机。对于梅森推土机，通常需要 10,000
    或甚至 50,000 个启动周期才能开始使用输出。相比之下，FRand 软件包有一个函数，它可以在不需要任何启动周期的情况下初始化生成器。
- en: 13.10 Linear feedback shift registers
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.10 线性反馈移位寄存器
- en: The *linear feedback shift register* (LFSR) is the darling of electrical engineers,
    because it is so simple to implement as a digital circuit. The LFSR uses an array
    of bits x[1], x[2], ... , x[n]. The next bit is generated by exclusive-ORing several
    of the preceding bits, for example
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性反馈移位寄存器*（LFSR）是电气工程师的宠儿，因为它在数字电路中实现起来非常简单。LFSR使用一系列位 x[1]、x[2]、...、x[n]。下一个位通过对前面的几个位进行异或运算来生成，例如'
- en: '![13-unnumb-1-equation-13-8](../Images/13-unnumb-1-equation-13-8.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-1-equation-13-8](../Images/13-unnumb-1-equation-13-8.png)'
- en: using 3 feedbacks. The number of feedbacks, of course, need not be 3, but an
    odd number of feedbacks will typically give a much longer period than an even
    number of feedbacks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用3个反馈。当然，反馈的数量不一定是3，但是奇数个反馈通常会比偶数个反馈给出更长的周期。
- en: This LFSR would have k+1 bit positions, assuming i < j < k. After each new bit
    is generated the low-order bit is shifted out, and the new bit is placed in the
    high-order position, so the register always contains the most recent k+1 bits
    of the pseudorandom sequence.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 i < j < k，则此 LFSR 将有 k+1 位位置。生成每个新位后，低阶位被移出，新位被放置在高阶位置，因此寄存器始终包含伪随机序列的最新的
    k+1 位。
- en: An obvious disadvantage of using an LFSR is that they are slow because they
    require 8 cycles to produce each pseudorandom output byte. LFSRs are also the
    weakest of the pseudorandom generating functions because they are entirely linear.
    If Emily has some known plaintext, and if she can determine the corresponding
    key bits, then she can reconstruct the entire pseudorandom sequence just by solving
    a set of linear equations, which is easy. Emily can determine the key bits if
    Sandra has used **xor**, **add** or **madd** for the combining function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LFSR 的一个明显缺点是它们速度较慢，因为它们需要 8 个周期才能生成每个伪随机输出字节。LFSR 也是伪随机生成函数中最弱的，因为它们完全是线性的。如果
    Emily 有一些已知的明文，并且能够确定相应的关键位，则她可以通过解一组线性方程来重构整个伪随机序列，这很容易。如果 Sandra 使用**xor**、**add**或**madd**作为组合函数，Emily
    可以确定关键位。
- en: For this reason, the pseudorandom outputs are usually run through a non-linear
    substitution before combining them with the plaintext. This can be done two ways,
    bitwise or bytewise. Non-linear bitwise substitutions are possible because at
    every cycle there are k+1 bits accessible in the register. The bits that are used
    as inputs to the non-linear function are called *taps*, and may be taken from
    anywhere in the register. Using these non-linear functions makes it harder for
    Emily to determine the key bits.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，伪随机输出通常在与明文结合之前通过非线性替换。这可以通过两种方式进行，按位或按字节。非线性按位替换是可能的，因为在每个周期中，寄存器中有 k+1
    个位可访问。用作非线性函数输入的位称为*taps*，可以从寄存器的任何位置获取。使用这些非线性函数使得 Emily 更难确定关键位。
- en: One suitable non-linear function is the *majority* *function*. This function
    has the value 1 if the majority of its input bits are 1, and the value 0 otherwise.
    For the case with 3 input bits A, B and C the majority function is AB∨BC∨CA, where
    ∨ is the Boolean OR function. The majority function is defined for any odd number
    of inputs, 3, 5, 7, ... One elaboration of this idea is to use 9 taps and three
    3-bit majority function circuits. Three of the 9 bits go into each circuit. Then
    the 3 output bits are run through a fourth majority circuit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的非线性函数是*多数* *函数*。如果其输入位的大多数为 1，则此函数的值为 1，否则为 0。对于具有 3 个输入位 A、B 和 C 的情况，多数函数是
    AB∨BC∨CA，其中 ∨ 是布尔 OR 函数。多数函数对于任何奇数个输入，如 3、5、7，等等，都是定义的。这个想法的一个扩展是使用 9 个 taps 和三个
    3 位多数函数电路。9 位中的三个位进入每个电路。然后，将 3 个输出位通过第四个多数电路。
- en: Bytewise substitutions are inherent if the combining function is **sxor**, **sadd**
    or **poly**. Construction of these non-linear substitutions is discussed at length
    in section 12.3\. It is possible to combine bitwise and bytewise substitutions.
    Each of the 8 bits in an output byte is generated using the taps and a non-linear
    bit function, then the 8 single-bit outputs of those circuits are fed into the
    bytewise substitution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组合函数是**sxor**、**sadd**或**poly**，则字节替换是固有的。这些非线性替换的构造在第 12.3 节中详细讨论。可以将按位和按字节替换组合起来。生成输出字节中的每个
    8 位都使用 taps 和非线性位函数，然后将这些电路的 8 个单个位输出馈入按字节替换中。
- en: Let’s look at what Emily must do to break an LFSR cipher. Suppose that Sandra
    is using a 40-bit hardware LFSR with taps at bit positions 3, 6 and 9 feeding
    into a majority function circuit, M, and that she has naively used **xor** as
    the combining function. Suppose further that Emily has a few characters of known
    plaintext, and therefore knows a sequence of the output bits. For each known bit,
    the 3 LFSR tap positions that feed into M are narrowed to only 4 of the 8 possible
    values. If the bit is 0, then the 3 taps must be 000, 001, 010 or 100\. If the
    bit is 1, the 3 taps must be 011, 101, 110 or 111.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Emily 必须做些什么来破解一个 LFSR 密码。假设 Sandra 使用一个 40 位的硬件 LFSR， taps 位于位位置 3、6
    和 9，进入到一个大多数功能电路 M 中，并且她天真地使用 **xor** 作为组合函数。进一步假设 Emily 有一些已知纯文本的字符，因此知道了一系列输出位。对于每个已知位，进入
    M 的 3 个 LFSR taps 位置只缩小到了 8 个可能值中的 4 个。如果位是 0，则 3 个 taps 必须是 000、001、010 或 100。如果位是
    1，则 3 个 taps 必须是 011、101、110 或 111。
- en: After 4 cycles, 12 bits have fed into the 3 taps, so there are 4⁴ = 256 possible
    combinations for the 12 bits. This is a great reduction from 2^(12) = 4096 combinations.
    Even better, from Emily’s standpoint, the bit that was originally at position
    3 is now at position 6, and the bit that was originally at position 6 has now
    moved to position 9\. This means that some of the 12-bit combinations can be eliminated.
    The number of combinations that can be removed depends on the sequence of output
    bits. If the first and fourth output bits are the same, fewer combinations are
    eliminated. If they are different, more combinations are eliminated. Each additional
    known output bit gives a further reduction in the number of possible combinations
    for the bits in the shift register.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 经过 4 个周期，12 位已经进入了 3 个 taps，所以对于这 12 位有 4⁴ = 256 种可能的组合。这相比于 2^(12) = 4096 种组合大大减少了。更好的是，从
    Emily 的角度来看，最初位于位置 3 的位现在位于位置 6，而最初位于位置 6 的位现在已经移动到位置 9。这意味着一些 12 位组合可以被消除。可以消除的组合数量取决于输出位的序列。如果第一个和第四个输出位相同，则消除的组合较少。如果它们不同，则消除的组合较多。每个额外的已知输出位进一步减少了移位寄存器中可能组合的数量。
- en: An example may help. Suppose Sandra is using a 40-bit LFSR with 3 taps that
    feed into the majority function to produce each output bit. Also suppose Emily
    knows all the details of the device and knows that the message came from General
    Headquarters, where all the messages begin *GHQ*. That gives her 24 bits of known
    plaintext. If she exclusive-ORs these 24 bits with the corresponding bits of the
    ciphertext, she gets 24 output bits from the device. For each of these output
    bits there are 4 possible 3-bit input combinations that produce the known value.
    That makes 72 bits of possible bit values at the 3 tap positions. Since the bits
    in the LFSR shift one position every cycle, these bit combinations will overlap,
    so the total number of combinations can be continually reduced.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子。假设 Sandra 使用一个 40 位的 LFSR，带有 3 个 taps，每个 taps 都进入到大多数功能中以产生每个输出位。还假设 Emily
    知道设备的所有细节，并知道消息来自总部，所有消息都以 *GHQ* 开头。这给了她 24 位已知纯文本。如果她将这 24 位与密文的对应位进行异或运算，她就从设备中得到了
    24 个输出位。对于这些输出位中的每一个，都有 4 种可能的 3 位输入组合来产生已知值。这就在 3 个 tap 位置产生了 72 位可能的位值。由于 LFSR
    中的位每个周期向前移动一个位置，这些位组合会重叠，因此总的组合数量可以不断减少。
- en: What should Sandra learn from this brief analysis? (1) Make the shift register
    big, preferably at least 128 bits. (2) Space the taps far apart. (3) Do not space
    the taps evenly. Here 3, 6, 9 was an exceptionally poor choice. (4) Use a combining
    function that makes it hard for the opponent to determine the key bits. Do not
    use **xor**, **add** or **madd** for the combining function. Better choices are
    **xors** and **adds**, but the best choice is **poly**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Sandra 应该从这个简要分析中学到什么？(1) 扩大移位寄存器，最好至少为 128 位。(2) 将 taps（触发器）远离得越远越好。(3) 不要均匀地分布
    taps。在这里，3、6、9 是一个异常糟糕的选择。(4) 使用一种让对手难以确定关键位的组合函数。不要使用 **xor**、**add** 或 **madd**
    作为组合函数。更好的选择是 **xors** 和 **adds**，但最佳选择是 **poly**。
- en: 13.11 Estimating the period
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.11 估计周期
- en: If you are a crypto hobbyist, you may want to try designing your own pseudorandom
    generator. This book will not cover how to test a PRNG, which is a big subject,
    but let’s look at how you can estimate the period of your generator. The method
    depends on the size of the state vector (section 13.2).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个密码学爱好者，你可能想要尝试设计自己的伪随机生成器。本书不会涵盖如何测试 PRNG，这是一个很大的主题，但让我们看看你如何估计你的生成器的周期。该方法取决于状态向量的大小（第
    13.2 节）。
- en: If the state vector is small, say 31 bits, you can just run your generator for
    2^(31) cycles and see when it repeats. Unfortunately, it is possible that the
    initial seed will never repeat. There is a trick to handle that possibility. Make
    2 copies of your PRNG and initialize them with the same seed, S. Then run the
    first copy 1 step at a time, and run the second copy 2 steps at a time. Suppose
    you find after 3000 cycles that the 2 copies produce the same state vector. That
    means R[3000] = R[6000], so the period of your generator is 3000, at least with
    the seed S.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态向量很小，比如31位，您可以只运行您的生成器2^(31)个周期，看看何时重复。不幸的是，初始种子可能永远不会重复。有一个处理这种可能性的技巧。制作2个PRNG的副本，并使用相同的种子S进行初始化。然后逐步运行第一个副本，每次运行第二个副本2步。假设您发现在3000个周期后，这2个副本产生相同的状态向量。这意味着R[3000]
    = R[6000]，因此您的生成器的周期至少为3000，使用种子S。
- en: If the state vector is larger, say 64 bits, it is not feasible to run your generator
    for potentially 2^(64) cycles. You can still estimate the period by using sampling.
    Make a table of, say, T = 1,000,000 entries. Entry N in this table will hold the
    number of the cycle when your generator produces the value N. Initially, set all
    of the entries in this table to zero, since no values have been produced yet.
    Choose a seed in the range 1 to T-1 and run your generator for, perhaps, G = 1,000,000,000
    cycles. On each cycle, if the value N that is produced is less than T, you record
    the cycle number in table entry N. If the entry is not zero, then you have a repeat,
    and that tells you the period. For example, if the value 12795 was produced on
    cycle 33,000 and again on cycle 73,500, then the period of your generator for
    that seed is 73500-33000 = 40500.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态向量较大，比如64位，那么运行您的生成器潜在地2^(64)个周期是不可行的。您仍然可以通过抽样来估计周期。制作一个表，比如T = 1,000,000个条目。这个表中的第N个条目将保存您的生成器产生值N时的周期数。最初，将这个表中的所有条目都设置为零，因为尚未产生任何值。选择范围在1到T-1之间的种子，并运行您的生成器，也许是G
    = 1,000,000,000个周期。在每个周期，如果生成的值N小于T，则记录表中的周期号N。如果条目不为零，则表示有重复项，这告诉您周期。例如，如果值12795在第33000个周期和第73500个周期再次产生，则该种子的生成器周期为73500-33000
    = 40500。
- en: If you do not find any repeats, then you can estimate the period by seeing how
    many of the T values were produced. If E entries in the table are nonzero, then
    the portion of entries that are produced is E/T. Since you ran the generator for
    G cycles, the estimated period is G/(E/T) = GT/E.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到任何重复项，那么您可以通过查看生成了多少个T值来估计周期。如果表中的E个条目不为零，则生成的条目比例为E/T。由于您运行了G个周期的生成器，估计周期为G/(E/T)
    = GT/E。
- en: As we saw with the chained digit generator (section 4.5.1), a generator may
    have several different cycles, some long and some short. You should make several
    estimates for the period of your generator, using different seeds. One good strategy
    is first to use the seed 1\. For the second seed, use the lowest value that was
    not generated by the first seed. For the third seed, use the lowest value that
    was not generated by the first or second seed. You can do this by making the table
    cumulative. Do not reset it to zero between estimation runs. If the estimates
    for the period are consistent over, say, 20 to 100 such runs, then you can have
    confidence that your generator has a long period for most seeds.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在链式数字生成器（第4.5.1节）中看到的，一个生成器可能有几个不同的循环，有些长，有些短。您应该对生成器的周期进行多次估计，使用不同的种子。一个好的策略是首先使用种子1。对于第二个种子，使用第一个种子未生成的最低值。对于第三个种子，使用第一个或第二个种子未生成的最低值。您可以通过制作累积表来做到这一点。在估计运行之间不要将其重置为零。如果在大约20到100次这样的运行中周期的估计是一致的，那么您可以确信您的生成器对大多数种子具有长周期。
- en: 13.12 Strengthening a generator
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.12 加强生成器
- en: One method for strengthening a PRNG is using a *selection generator* that separates
    the operation of generating the numbers from the operation of selecting the numbers.
    This can be done by keeping N numbers in an array, say 32, 64 or 256 numbers.
    Each number in the array should be the size of the desired random outputs. For
    example, if you want to generate random bytes, the array should contain 8-bit
    numbers. The PRNG is first run for N cycles to produce the initial numbers, which
    are put into the array in the order that they are generated. Then the PRNG is
    restarted with a new seed. The generator is then used to produce a sequence of
    pseudorandom numbers in the range 1 to N. Each of these numbers is used to select
    an element of the array. This element becomes the next pseudorandom output. The
    selected array element then gets replaced by a new pseudorandom number using the
    PRNG.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 加强PRNG的一种方法是使用一个*选择生成器*，将生成数字的操作与选择数字的操作分开。 这可以通过在数组中保留N个数字来完成，比如32、64或256个数字。
    数组中的每个数字应该是所需随机输出的大小。 例如，如果要生成随机字节，则数组应包含8位数字。 首先对PRNG运行N个周期以产生初始数字，这些数字按生成顺序放入数组中。
    然后使用新种子重新启动PRNG。 然后使用生成器生成范围为1到N的伪随机数序列。 每个数字用于选择数组的一个元素。 该元素成为下一个伪随机输出。 然后使用PRNG用新的伪随机数替换所选数组元素。
- en: This means that the first, third, fifth, ... random numbers are used for selection,
    while the second, fourth, sixth, ... numbers are used to replace the numbers in
    the array. It may be convenient to use two separate copies of the PRNG with different
    seeds, however, this will not increase the period. A better strategy is to use
    two different generators whose periods are coprime. Then the period of the combined
    generator is the product of their periods. For example, if the numbers are generated
    by a multiplicative congruential generator with period 2^(31)-1, and the numbers
    are selected by a linear congruential generator with period 2^(31), then the period
    of the combined generator is 2^(62)-2^(31), or 4.612×10^(18).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第一个、第三个、第五个，... 随机数用于选择，而第二个、第四个、第六个，... 数字用于替换数组中的数字。 使用两个具有不同种子的PRNG的两个独立副本可能很方便，但这不会增加周期。
    更好的策略是使用两个周期互质的不同生成器。 然后，组合生成器的周期是它们周期的乘积。 例如，如果数字是由具有周期2^(31)-1的乘法同余生成器生成的，而数字是由具有周期2^(31)的线性同余生成器选择的，那么组合生成器的周期是2^(62)-2^(31)，或4.612×10^(18)。
- en: The period of 4.612×10^(18) is long enough for cryptographic work, but the selection
    generator is still not cryptographically secure. That is because Emily can brute-force
    the selector sequence and try all 2^(31) possible seeds. With enough known plaintext
    this could give her a sequence of outputs from the first generator, which would
    be enough to solve it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 4.612×10^(18)的周期对于密码工作已经足够长，但选择生成器仍然不具有密码学安全性。 这是因为艾米莉可以穷举选择器序列并尝试所有2^(31)种可能的种子。
    有足够的已知明文，这可能会给她第一个生成器的输出序列，这足以解决问题。
- en: There are several possible remedies. (1) Use a combining function like **xors**,
    **adds** or **poly****,** which makes it hard for Emily to determine the random
    outputs. (2) Make the selector generator bigger, say 63 bits instead of 31 bits.
    (3) Make the seed for the selector generator bigger, for example by making the
    multiplier and/or the additive constant part of the seed, namely m and c in the
    generating function x[n+1] = (mx[n]+c) mod P. (4) Use the techniques in the following
    section to construct a selector with a longer period.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可能的解决方法。 (1) 使用像**xors**、**adds**或**poly**这样的组合函数，这样艾米莉就很难确定随机输出。 (2) 使选择器生成器更大，比如说63位而不是31位。
    (3) 使选择器生成器的种子更大，例如通过使乘数和/或加法常数成为种子的一部分，即生成函数x[n+1] = (mx[n]+c) mod P中的m和c。 (4)
    使用下一节中的技术来构建一个具有更长周期的选择器。
- en: 13.13 Combining generators
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.13 组合生成器
- en: Pseudorandom number generators can be combined in a variety of ways to get longer
    periods or better randomness properties, or to become cryptographically secure.
    These improvements usually go hand in hand. You do not trade one off to achieve
    the other. If you increase the period, you will normally improve the randomness
    at the same time. There are two classes of combined generators, fixed combinations
    and variable combinations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数生成器可以以各种方式组合，以获得更长的周期或更好的随机性属性，或者变得具有密码学安全性。 这些改进通常是相辅相成的。 你不会为了实现另一个而牺牲一个。
    如果增加周期，通常会同时改善随机性。 有两类组合生成器，固定组合和可变组合。
- en: Fixed combinations
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 固定组合
- en: In fixed combinations, there are several PRNGs, preferably with periods that
    are coprime. These could be multiplicative congruential, linear congruential or
    Xorshift generators. The outputs of these generators can be combined bitwise or
    bytewise. One bitwise method is to take a fixed set of bits from each generator
    and input them into some combining function. For example, the high-order bit could
    be taken from each of 8 generators, or the two high-order bits could be taken
    from each of 4 generators. These 8 bits would then be input into a highly non-linear
    substitution. The substitution step prevents Emily from separating the outputs
    from each of the generators and solving them individually.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定组合中，有几个 PRNG，最好是周期互质的。这些可以是乘法同余、线性同余或 Xorshift 生成器。这些生成器的输出可以按位或按字节组合。一种按位的方法是从每个生成器中取一组固定的位，并将它们输入到某个组合函数中。例如，可以从
    8 个生成器中分别取高阶位，或者从 4 个生成器中分别取两个高阶位。然后，这 8 位将被输入到一个高度非线性的替换中。替换步骤防止 Emily 将每个生成器的输出分离并单独解决它们。
- en: One bytewise method is to take the high-order byte from each generator and combine
    them by adding them modulo 256, or by exclusive-ORing them. Two generators may
    be combined by multiplying their outputs and taking the middle 8 bits of the product.
    Another technique is to take a linear combination such as (a[1]x[1]+a[2]x[2]+a[3]x[3]+a[4]x[4])
    mod 256, where x[1], x[2], x[3] and x[4] are the 8-bit outputs taken from four
    PRNGs, and the four coefficients a[1], a[2], a[3] and a[4] may be any odd integers
    from 1 to 255\. These coefficients may be different for each message.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一种按字节的方法是从每个生成器中取高阶字节，并通过对它们进行模 256 相加或者异或来组合它们。两个生成器可以通过将它们的输出相乘并取乘积的中间 8 位来组合。另一种技术是取线性组合，例如
    (a[1]x[1]+a[2]x[2]+a[3]x[3]+a[4]x[4]) mod 256，其中 x[1]、x[2]、x[3] 和 x[4] 是来自四个 PRNG
    的 8 位输出，并且四个系数 a[1]、a[2]、a[3] 和 a[4] 可以是 1 到 255 之间的任意奇数整数。这些系数可以针对每条消息不同。
- en: For example, the four PRNGs could be multiplicative congruential generators
    using the prime modulus 2^(31)-1 with 4 different, but fixed, multipliers. The
    four 31-bit seeds plus the four 7-bit coefficients make a combined seed of 152
    bits.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，四个 PRNG 可以使用素数模 2^(31)-1 和 4 个不同但固定的乘数来生成。这四个 31 位种子加上四个 7 位系数组成了 152 位的组合种子。
- en: Three PRNGs can be combined by using the >>> cyclic shift operation (section
    13.7). With a 32-bit unsigned generator, the 32-bit outputs can be combined using
    x[1] + (x[2] >>>11) + (x[3] >>>21) mod 2^(32). The optimal shift amounts are 1/3
    and 2/3 of the 32-bit register size. If you wish to use more than 3 generators,
    make the shift amounts as uniform as possible. For example, with 5 generators
    the shift amounts should be 1/5, 2/5, 3/5 and 4/5 of the word size, rounded to
    the nearest integer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 三个 PRNG 可以通过使用循环移位操作（第 13.7 节）来组合。使用 32 位无符号生成器时，32 位输出可以使用 x[1] + (x[2] >>>11)
    + (x[3] >>>21) mod 2^(32) 来组合。最佳移位量是 32 位寄存器大小的 1/3 和 2/3。如果你希望使用超过 3 个生成器，请尽可能使移位量均匀。例如，使用
    5 个生成器时，移位量应该是字长的 1/5、2/5、3/5 和 4/5，四舍五入到最接近的整数。
- en: Another fixed generator, *CyGen*, combines two generators, C and G, by cyclic
    shifting. C may be any size, but G should be either 32 bits or 64 bits. On each
    cycle 5 or 6 bits, respectively, are taken from C to get the shift amount. The
    output from G is then cycled left that number of positions to get the output from
    CyGen. This makes it infeasible for Emily to reconstruct G from a sequence of
    its outputs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个固定生成器 *CyGen*，通过循环移位来组合两个生成器 C 和 G。C 可以是任何大小，但 G 应该是 32 位或 64 位。在每个周期中，分别从
    C 中取 5 或 6 位，以获取移位量。然后，从 G 中取得的输出将向左循环移动该数量的位置，以获得 CyGen 的输出。这使得 Emily 无法从其输出序列重构
    G。
- en: You are not restricted to linear combinations. For example, 3 generators can
    be combined using x[n]+y[n]z[n], or x[n]+y[n]²+z[n]z[n-1]z[n-3], or ... At least
    one term in the sum should be linear. The possibilities are endless, and, of course,
    you can switch around among multiple methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 没有限制线性组合。例如，可以使用 x[n]+y[n]z[n] 或 x[n]+y[n]²+z[n]z[n-1]z[n-3] 将 3 个生成器组合起来。至少求和中的一项应该是线性的。可能性是无限的，当然，你可以在多种方法之间进行切换。
- en: Variable combinations
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可变组合
- en: One example of a variable combination is the selection generator shown in section
    13.11\. However, let me start this section with a cautionary tale. Here is a combined
    generator, *CG5*, that seems to be surefire secure, but is not.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可变组合的一个示例是第 13.11 节中显示的选择生成器。但是，让我用一个警示故事开始这一节。这里有一个组合生成器 *CG5*，似乎是绝对安全的，但实际上不是。
- en: 'The combined generator CG5 uses 5 multiplicative congruential generators, each
    with a different multiplier and different 31-bit prime modulus. Call these generators
    G0, G1, G2, G3 and SEL. (Alternatively, SEL could be a linear congruential or
    Xorshift generator with a 2^(31) period.) The production generators G0 through
    G3 are used to produce pseudorandom numbers, and the selection generator SEL is
    used to select which of G0-G3 to use to produce the next pseudorandom output.
    Specifically, the high-order 2 bits of SEL determine which among G0-G3 to use.
    Suppose SEL generates 10, which selects G2\. Then the G2 generator is run for
    1 cycle, and its output becomes the next output for CG5\. The combined generator
    will have a period of about 2^(155) and will have good random properties ... but
    will not be cryptographically secure. Here’s why:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 组合生成器CG5使用5个乘法同余生成器，每个都有不同的乘数和不同的31位素数模数。将这些生成器称为G0、G1、G2、G3和SEL。（或者，SEL可以是一个线性同余或Xorshift生成器，具有2^(31)周期。）生产生成器G0到G3用于产生伪随机数，选择生成器SEL用于选择G0-G3中的哪一个用于产生下一个伪随机输出。具体来说，SEL的高2位确定了在G0-G3中选择哪一个。假设SEL生成了10，这选择了G2。然后G2生成器运行1个周期，其输出成为CG5的下一个输出。组合生成器的周期约为2^(155)，具有良好的随机特性...但不会是密码学安全的。原因如下：
- en: Assume that Emily has sufficient known plaintext, and consider the first 17
    outputs from CG5\. At least 5 of these 17 outputs must have been produced by the
    same generator. (If 4 generators produced at most 4 outputs each, then there could
    be at most 16 outputs, not 17.) There are only 6188 ways that 5 items can be chosen
    out of 17\. Emily can try all of them. This gives about 1.33×10^(13) combinations
    of placement plus seed to test, however, this can be reduced substantially. Emily
    knows the high-order 8 bits of each of the 5 chosen outputs. Instead of starting
    with the first of the 17 outputs, she should start with the first of the 5 chosen
    outputs. Then she needs to try only 2^(23) values instead of 2^(31) values. That
    cuts her work down to a manageable 5.19×10^(10) combinations. The CG5 combined
    generator is not safe.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设艾米莉有足够的已知明文，并考虑从CG5中得到的前17个输出。这17个输出中至少有5个必须由同一个生成器产生。（如果4个生成器最多产生4个输出，那么最多只能有16个输出，而不是17个。）从17个中选择5个项目的方式只有6188种。艾米莉可以尝试所有这些方式。这样一来，就有大约1.33×10^(13)种放置加种子的组合需要测试，然而，这可以大大减少。艾米莉知道这5个选择输出的每个的高8位。她不应该从17个输出的第一个开始，而应该从5个选择输出的第一个开始。然后，她只需要尝试2^(23)个值，而不是2^(31)个值。这样一来，她的工作量就减少到了可管理的5.19×10^(10)个组合。CG5组合生成器并不安全。
- en: Let’s look at a safer generator. I will call it *Gen5*. Once more, the combined
    generator uses 5 multiplicative congruential generators, each with a different
    multiplier and different 31-bit prime modulus. The moduli and multipliers are
    fixed, and chosen to have good random properties. This time let’s call the generators
    G1, G2, G4, G8 and SEL. Only the 4 high-order bits of the selector SEL are used.
    In this 4-bit number, a 1 in the first bit means select G1, a 1 in the second
    bit selects G2, a 1 in the third bit will select G4 and a 1 in the fourth bit
    selects G8\. Whenever fewer than two generators are selected, SEL is run for another
    cycle to generate a new selection. Only 11 out of the 16 possible 4-bit output
    values from SEL are used, so SEL is run for an additional cycle 5/16 of the time,
    two additional cycles 25/256 of the time, and so forth.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更安全的生成器。我将其称为*Gen5*。再次，组合生成器使用5个乘法同余生成器，每个都有不同的乘数和不同的31位素数模数。模数和乘数是固定的，并且选择得具有良好的随机特性。这次让我们称这些生成器为G1、G2、G4、G8和SEL。只使用选择器SEL的4个高阶位。在这个4位数中，第一个位上的1表示选择G1，第二个位上的1表示选择G2，第三个位上的1表示选择G4，第四个位上的1表示选择G8。当选择少于两个生成器时，SEL将再运行一个周期以生成新的选择。只使用SEL生成的16个可能的4位输出值中的11个，因此SEL将额外运行一个周期的时间为5/16，额外运行两个周期的时间为25/256，依此类推。
- en: When two or more generators are selected, they are each run for 1 cycle, and
    their outputs are added together modulo 2^(31) to produce the Gen5 pseudorandom
    output. The generators that were not selected are not run, so that the 4 generators
    run asynchronously. This output is slightly biased toward lower numbers, but not
    nearly enough for Emily to exploit. If you are concerned about this bias, either
    (1) discard the high-order bit and use high-order bits 2 through 9 of the sum
    as the output byte, or (2) use the Meld8 operation (section 12.3.7). That is,
    form the output byte from the Gen5 generator by exclusive-ORing the high-order
    8 bits of the sum with the second 8 bits of the sum, namely exclusive-OR bits
    1 to 8 with bits 9 to 16.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择两个或更多发生器时，它们每个都会运行 1 个周期，它们的输出将模 2^(31) 加在一起，以产生 Gen5 伪随机输出。未选择的发生器不会运行，因此
    4 个发生器会异步运行。该输出略微偏向较低的数字，但对 Emily 来说并不足以利用。如果您担心这种偏差，可以（1）丢弃高阶位并使用和为输出字节的高阶位 2
    到 9，或者（2）使用 Meld8 操作（第 12.3.7 节）。也就是说，通过将和的高阶 8 位与和的第二个 8 位进行异或运算来从 Gen5 发生器形成输出字节，即将位
    1 到 8 的异或位与位 9 到 16 的位进行异或。
- en: '*****Emily can no longer isolate any of the four generators. It might appear
    feasible for Emily to separate out one of the 6 pairs Gi+Gj, where i and j can
    be 1, 2, 4 or 8\. Such a pair could be treated like a single generator, and then
    Gi could be separated from Gj later. Let’s look at that approach first. In order
    to solve for the seeds of both Gi and Gj, at least 9 random outputs from Gen5
    are needed. Since each of these pairings occurs only 1/11 of the time, Emily may
    have to look at 89 or more message characters. This is because, simply by chance,
    the 5 combinations of 3 or 4 generators may occur more frequently than the 6 combinations
    of 2 generators.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*****Emily 再也无法分离出任何一个发生器。Emily 可能看起来可以分离出其中的 6 对 Gi+Gj 中的一个，其中 i 和 j 可以是 1、2、4
    或 8。这样的一对可以被视为单个发生器处理，然后稍后可以将 Gi 与 Gj 分离出来。让我们首先看看这种方法。为了求解 Gi 和 Gj 的种子，至少需要来自
    Gen5 的 9 个随机输出。由于这些配对每次只发生 1/11 的概率，Emily 可能需要查看 89 个或更多的消息字符。这是因为，仅仅由于偶然，3个或4个发生器的
    5 个组合可能比 2 个发生器的 6 个组合更频繁地发生。'
- en: There are about 6.356×10^(11) possible placements for 9 items out of 89, so
    it is more efficient for Emily simply to try all of the approximately 2^(31) =
    2.147×10⁹ seeds for the SEL generator. This lets Emily find the next 10 positions
    for all 6 of the Gi+Gj pairs. It also lets her count how many times Gi and Gj
    have been used up to each of those occurrences. For example, suppose that G2+G4
    occurs at the 14th cycle of Gen5\. It may happen that among those 14 cycles, G2
    was used in 6 of those cycles and G4 was used in 9 of those cycles. So now Emily
    knows the value of the 6th output of G2 plus the 9th output of G4.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 89 个物品中的 9 个物品，大约有 6.356×10^(11) 种可能的放置方式，因此 Emily 只需尝试 SEL 发生器的所有约 2^(31)
    = 2.147×10⁹ 个种子，这样 Emily 就可以找到所有 6 对 Gi+Gj 的下一个 10 个位置。这也让她可以计算出 Gi 和 Gj 在每次出现时已经被使用了多少次。例如，假设
    G2+G4 出现在 Gen5 的第 14 个周期。在这 14 个周期中，可能有 6 个周期中使用了 G2，而 9 个周期中使用了 G4。现在 Emily 知道了
    G2 的第 6 个输出加上 G4 的第 9 个输出的值。
- en: If Emily can put together 10 such output values for, say, G2+G4 then she can
    determine the seeds of those two generators in about 2^(31+31-8) = 2^(54) = 1.801×10^(16)
    trials. This must be done for each of the approximately 2^(31) seeds of SEL, so
    the total work is about 2^(85) = 3.869×10^(25). This is a huge improvement over
    the 2^(155) trials that a brute-force solution to Gen5 would require, but it falls
    far short of the goal of 2^(128) trials. This generator is rated Nine.******
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Emily 可以为 G2+G4 这样的 10 个输出值组合起来，那么她可以在大约 2^(31+31-8) = 2^(54) = 1.801×10^(16)
    次试验中确定这两个发生器的种子。这必须对 SEL 的约 2^(31) 个种子进行操作，因此总工作量约为 2^(85) = 3.869×10^(25)。这相比于
    Gen5 的暴力解决方案需要 2^(155) 次试验有了巨大的改进，但远远不及 2^(128) 次试验的目标。此发生器被评为 Nine.******
- en: Now we are ready for the coup de grâce. This is a souped-up version of Gen5,
    which I will call *GenX*. There are two parts to GenX, a pseudorandom number generator
    and a cipher. The GenX PRNG will generate a sequence of 10-bit pseudorandom outputs,
    and the cipher will combine the key bytes k[n] with the message bytes x[n] to
    produce the ciphertext. This will push the cipher beyond the 128-bit key size.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进行致命一击了。这是 Gen5 的升级版本，我将其称为 *GenX*。GenX 由伪随机数生成器和密码两部分组成。GenX PRNG
    将生成一个 10 位伪随机输出序列，密码将把密钥字节 k[n] 与消息字节 x[n] 结合起来产生密文。这将使密码超出 128 位密钥大小。
- en: The GenX generator is just an extended version of the Gen5 generator. It uses
    four production generators, G1, G2, G4 and G8, and a selection generator, SEL.
    The high-order 4 bits of SEL are used to select some combination of 2 to 4 production
    generators. The selected production generators are run for one cycle, and their
    outputs are added modulo 2^(31) to produce a sum, G. The high-order 10 bits of
    G are exclusive-ORed with the next 10 bits of G to produce the 10-bit output.
    The 10-bit output is divided into an 8-bit key byte k[n] and a 2-bit control c[n].
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GenX 生成器只是 Gen5 生成器的扩展版本。它使用四个生产生成器 G1、G2、G4 和 G8，以及一个选择生成器 SEL。SEL 的高阶 4 位用于选择
    2 到 4 个生产生成器的某种组合。所选的生产生成器运行一个周期，它们的输出相加模 2^(31) 以产生一个和 G。G 的高阶 10 位与下一个 10 位的
    G 进行异或运算以产生 10 位输出。10 位输出被分为一个 8 位密钥字节 k[n] 和一个 2 位控制位 c[n]。
- en: The GenX cipher combines the key byte k[n] with the message byte x[n] according
    to the control c[n] using a well-mixed keyed substitution, S. The control bits
    c[n] determine which combining function is used for each plaintext byte. One possible
    way to interpret the 2 control bits is
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: GenX 密码器将密钥字节 k[n] 与消息字节 x[n] 根据控制位 c[n] 使用混合的键控替换 S 进行组合。控制位 c[n] 决定了每个明文字节使用哪种组合函数。解释这
    2 个控制位的一种可能方式是
- en: '![13-unnumb-1-equation-13-10](../Images/13-unnumb-1-equation-13-10.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-1-equation-13-10](../Images/13-unnumb-1-equation-13-10.png)'
- en: All sums are modulo 256\. Cipher GenX is rated Ten. The keys for this cipher
    are the five 31-bit seeds for G1, G2, G4, G8 and SEL plus the key for mixing the
    substitution S, for example a SkipMix key.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的和都是模256。Cipher GenX 被评为十。该密码的密钥是用于 G1、G2、G4、G8 和 SEL 的五个 31 位种子以及用于混合替换 S
    的密钥，例如 SkipMix 密钥。
- en: 13.14 True random numbers
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.14 真随机数
- en: All of the techniques for generating random numbers that have been discussed
    so far in this chapter produce pseudorandom numbers. Every book I have ever seen
    that discusses random numbers repeats the belief that it is impossible to produce
    true random numbers using software. This is because they are limiting themselves
    to a too-narrow range of possible methods. In this section I will present a workable
    method for producing true random numbers in bulk using software.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在本章讨论过的生成随机数的技术都产生伪随机数。我看过的每一本讨论随机数的书都重复着这样的观念，即使用软件产生真正的随机数是不可能的。这是因为他们将自己限制在了一种太狭窄的可能方法范围内。在本节中，我将介绍一种使用软件批量生成真正随机数的可行方法。
- en: All the methods in the literature for producing true random numbers depend on
    physical phenomena like cosmic rays, thermal noise, vibration, nuclear decay,
    and so forth. These methods are much too slow for cryptographic purposes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文献中所有用于生成真正随机数的方法都依赖于诸如宇宙射线、热噪声、振动、核衰变等物理现象。这些方法对于加密目的来说太慢了。
- en: Instead, you can produce true random numbers by a 3-step process. (1) Build
    up a large body of true random numbers taken from nature. (2) Make their probability
    distribution uniform. (3) Generate the random numbers by selecting and combining
    numbers from this corpus. The next few sections will detail how these steps can
    be done.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以通过一个 3 步过程产生真正的随机数。 (1) 从自然界中获取大量真正的随机数。 (2) 使它们的概率分布均匀。 (3) 通过从这个语料库中选择和组合数字来生成随机数。接下来的几节将详细介绍如何完成这些步骤。
- en: Nature is full of randomness. The shape, coloration and position of every leaf
    on every plant and tree on earth is random. They are the result of winds and breezes,
    sunlight filtering through the foliage, nutrients flowing up from the roots, raindrops
    and hailstones that have struck the foliage, insects that have chewed it, birds,
    squirrels, ground tremors, and many other factors. Every wave on every ocean,
    every plant and rock in every desert, every ripple on every river, every cloud,
    every shell on every beach is random in size, shape, colors, location, orientation
    and sometimes velocity.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 自然界充满了随机性。地球上每一棵植物和树上每片叶子的形状、颜色和位置都是随机的。它们是风和微风、阳光透过叶片、从根部流上的养分、打在叶片上的雨滴和冰雹、咬过叶片的昆虫、鸟类、松鼠、地面震动以及许多其他因素的结果。每一个海洋上的波浪、每一个沙漠中的植物和岩石、每一条河流上的涟漪、每朵云、每一个海滩上的贝壳在大小、形状、颜色、位置、方向甚至速度上都是随机的。
- en: Some of this randomness can be captured simply by photographing these locales.
    You don’t even need to leave home. Just take a handful of popcorn and drop it
    on a patterned surface. You can also use your own photos of people you know and
    places you have been. There are photos you have downloaded from websites and emails.
    There are hundreds more that have been placed on your computer by the operating
    system and by apps you have. There are billions more photos you can find using
    a web browser. As an experiment, I invented a pseudo-word, ZRMWKNV, and searched
    for images. I got over 6,000 search results with pictures related to ZRMWKNV,
    and some of those sites contained hundreds of images.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些随机性的一部分可以通过简单地拍摄这些地点来捕捉。你甚至不需要离开家。只需拿一把爆米花撒在有图案的表面上。你还可以使用你认识的人和你去过的地方的照片。有些照片是你从网站和电子邮件中下载的。还有成千上万张照片被操作系统和你使用的应用程序放在了你的计算机上。你可以使用网络浏览器找到数十亿张照片。作为一个实验，我编造了一个伪单词ZRMWKNV，并搜索了图片。我得到了超过6,000个与ZRMWKNV相关的搜索结果，其中一些网站包含了数百张图片。
- en: 13.14.1 Lagged linear addition
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滞后线性加法
- en: 'Each such image file contains lots of randomness, particularly if the resolution
    is high, but the distribution of byte values is far from uniform, and far from
    independent. The distribution can be flattened out by using *lagged linear addition*,
    treating the whole image file, including the headers, as one long byte string
    of length L. Here is an example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这样的图像文件包含大量的随机性，特别是如果分辨率很高，但字节值的分布远非均匀，也远非独立。通过使用*滞后线性加法*，将整个图像文件，包括头部在内，视为长度为L的一个长字节字符串，可以使分布变得平坦。以下是一个示例：
- en: '![13-unnumb-1-equation-13-11](../Images/13-unnumb-1-equation-13-11.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-1-equation-13-11](../Images/13-unnumb-1-equation-13-11.png)'
- en: The subscripts wrap around, as always. Three passes, as shown, are sufficient,
    but feel free to use more. You don’t want the frequencies too uniform, because
    that would no longer be random. If you want to use a streamlined version, like
    x[n] = (x[n]+x[n-179]) mod 256, note that five passes are needed. Be sure to use
    a different lag on each pass.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下标总是循环的。如所示，三次传递足够了，但随时可以使用更多。你不希望频率太均匀，因为那将不再是随机的。如果你想使用简化版本，比如 x[n] = (x[n]+x[n-179])
    mod 256，请注意需要五次传递。确保在每次传递中使用不同的滞后。
- en: There is nothing special about these coefficients, 7, 31, et al. I picked them
    arbitrarily. They may be any odd integers from 1 to 255\. For each pass the lags
    40, 1581, etc. should be chosen so that one lag is considerably larger than the
    other. Small step, big step. One idea is to make the smaller lag about ∛*L* and
    the larger lag around about ∛*L*². For example, if the image file is 1,000,000
    bytes, you might make the lags about 100 and about 10,000, respectively. The smaller
    lag could be chosen between 50 and 200, and the larger lag could be between 5000
    and 20,000\. Following the lagged linear addition with a keyed simple substitution
    makes it harder for Emily to reconstruct the image file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系数7、31等并没有什么特别之处，我是随意选择的。它们可以是从1到255的任意奇整数。对于每次传递，滞后40、1581等应该被选择得一个远大于另一个。小步长，大步长。一个想法是使较小的滞后约为∛*L*，而较大的滞后约为∛*L*²。例如，如果图像文件大小为1,000,000字节，你可以分别使滞后约为100和约为10,000。较小的滞后可以在50和200之间选择，而较大的滞后可以在5000和20,000之间选择。在滞后线性加法之后使用一个带有密钥的简单替换，使得艾米莉更难重建图像文件。
- en: 13.14.2 Layering images
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像分层
- en: Another way to construct a true random sequence is to take two images and layer
    them one over the other using some combining function such as **xor** or **add**
    (see section 13.1). A good method would be to perform one pass of lagged linear
    addition on each image before combining, and a final pass after they have been
    combined.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种构建真随机序列的方法是取两个图像，使用某种组合函数（如**异或**或**加法**，参见第13.1节）将它们层叠在一起。一个好的方法是在组合之前对每个图像进行一次滞后线性加法传递，然后在它们被组合后进行最后一次传递。
- en: 'Three images can be combined bit by bit using the non-linear majority function
    (section 13.10). Again, I suggest one pass of lagged linear addition on each image
    before combining, and a final pass after they have been combined. This method
    can be used even when none of the three images are the same size. Align one short
    image to begin at the same point as the largest image, and the other short image
    to end at the same point as the longest image, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 三个图像可以使用非线性大多数函数（第13.10节）逐位进行组合。同样，在组合之前，我建议对每个图像进行一次滞后线性加法的传递，然后在它们被组合之后进行最后一次传递。即使三个图像中没有一个大小相同，也可以使用这种方法。将一个短图像对齐到与最大图像相同的位置，并将另一个短图像对齐到与最长图像相同的位置，就像这样：
- en: '![13-unnumb-2](../Images/13-unnumb-2.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-2](../Images/13-unnumb-2.png)'
- en: Where only two of the images overlap, add them bytewise modulo 256\. Where all
    three images overlap, combine them bitwise using the majority function, or use
    a linear combination modulo 256, such as c[n] = (113x[n]+57y[n]+225z[n]) mod 256\.
    The coefficients may be any odd integers from 1 to 255.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有两幅图像重叠时，按字节模256进行相加。当所有三幅图像重叠时，使用大多数函数逐位进行组合，或者使用模256的线性组合，如c[n]=(113x[n]+57y[n]+225z[n])
    mod 256。系数可以是从1到255的任意奇整数。
- en: An alternative approach to aligning the images is to extend the short images
    by repeating them. In the example, the x image has 22 bytes and the y image has
    33 bytes. The x image can be extended to 33 bytes by repeating the first 11 bytes
    of x. This way, the majority function can be used in all 33 byte positions. In
    practice these images would have millions of bytes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐图像的另一种替代方法是通过重复来扩展短图像。在这个例子中，x图像有22个字节，y图像有33个字节。通过重复x的前11个字节，可以将x图像扩展到33个字节。这样，大多数函数可以在所有33个字节位置使用。实际上，这些图像将有数百万个字节。
- en: 13.15 Refreshing the random bytes
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.15 刷新随机字节
- en: Good. Now we have a table, T, of several million true random bytes. They are
    true random because, if Emily had all but one of the bytes in T, that would not
    enable her to determine the one missing byte. Both Sandra and Riva have a copy.
    What then? Surely we cannot repeat this process every time we want to send a message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在我们有一个名为T的表，里面有几百万个真随机字节。它们是真正的随机字节，因为如果艾米丽拥有除了一个字节之外的所有字节，这并不会使她能够确定缺失的那一个字节。桑德拉和莉娃都有一份拷贝。那么呢？我们肯定不能每次发送消息都重复这个过程。
- en: One way to utilize T is to partition it into keys for use with a block cipher.
    One million random bytes can make 62,500 keys of 128 bits each. Eventually the
    million bytes will get used up. If Sandra is using a strong block cipher, perhaps
    that does not matter. She can use keys repeatedly, as long as Emily cannot tell
    which messages have been enciphered with the same key. Of course, Sandra cannot
    reuse keys with a stream cipher.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 利用T的一种方法是将其划分为用于分组密码的密钥。一百万个随机字节可以制作出62,500个每个128位的密钥。最终这一百万字节将被用完。如果桑德拉正在使用一个强大的分组密码，或许这并不重要。她可以重复使用密钥，只要艾米丽无法知道哪些消息使用了相同的密钥进行了加密。当然，桑德拉不能对流密码重复使用密钥。
- en: Suppose Sandra does not wish to take the risk of reusing keys. One solution
    is for her to refresh the list of random numbers. Sandra could layer on another
    image, but that means Riva also must have a copy of the same image. That could
    be managed if the image comes from a website to which both Sandra and Riva have
    access. This could be a good strategy if there is a high risk that transmitted
    keys could be intercepted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设桑德拉不愿意冒再次使用密钥的风险。一个解决方案是刷新随机数列表。桑德拉可以添加另一幅图像，但这意味着莉娃也必须有同样的图像的拷贝。如果图像来自桑德拉和莉娃都可以访问的网站，那么这可能是一个不错的策略。如果传输的密钥可能被截获，这可能是一个很好的策略。
- en: A different method is to refresh T using lagged linear addition (section 13.14.1).
    Call the refreshed table T[1]. Now Sandra needs to transmit only the 9 coefficients
    and the 6 lags, and she has another 62,500 keys to use. Assuming 1 byte for each
    coefficient and 2 bytes for each lag, Sandra needs to transmit only 21 bytes to
    generate T[1]. Then to select a key for a message, only the position of this message
    key within T[1] is needed. Two bytes are sufficient for this because all of the
    positions are multiples of 16\. When T[1] is exhausted, a new set of coefficients
    and lags can be used to construct T[2], and so forth.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用滞后线性加法（第13.14.1节）刷新T。称刷新后的表为T[1]。现在桑德拉只需要传输9个系数和6个滞后，她就有另外62500个密钥可用。假设每个系数需要1字节，每个滞后需要2字节，桑德拉只需传输21字节即可生成T[1]。然后为了选择消息的密钥，只需要知道该消息密钥在T[1]中的位置。对此，两个字节足够了，因为所有位置都是16的倍数。当T[1]用尽时，可以使用新的系数和滞后来构造T[2]等等。
- en: In sections 13.5 and 13.6, linear functions were used to assure a long period
    for the generator. Here there is no period, so there is no such constraint. Some
    non-linear functions that can be used are
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13.5节和13.6节中，线性函数用于确保生成器具有长周期。这里没有周期，因此没有这样的约束。可以使用一些非线性函数，例如
- en: '![13-unnumb-2-equation-13-12](../Images/13-unnumb-2-equation-13-12.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-2-equation-13-12](../Images/13-unnumb-2-equation-13-12.png)'
- en: Here the subscripts wrap around, a and b are odd integers from 1 to 255, and
    i, j and k are integers between 1 and L-1\. S can be either a fixed non-linear
    substitution or a variable key-mixed substitution. The function E(x) is defined
    as
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里下标循环，a和b是从1到255的奇整数，i、j和k是介于1和L-1之间的整数。S可以是一个固定的非线性替换或者一个变量密钥混合替换。函数E(x)定义为
- en: '![13-unnumb-2-equation-13-13](../Images/13-unnumb-2-equation-13-13.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-2-equation-13-13](../Images/13-unnumb-2-equation-13-13.png)'
- en: When you take E(x[n-j]x[n-k]) mod 256 you are essentially adding the individual
    bytes of x[n-j]x[n-k]. This is stronger than just using x[n-j]x[n-k] because x[n-j]x[n-k]
    is even 3/4 of the time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你取E(x[n-j]x[n-k]) mod 256时，实际上是将x[n-j]x[n-k]的各个字节相加。这比仅仅使用x[n-j]x[n-k]更强，因为x[n-j]x[n-k]有3/4的概率是偶数。
- en: Alternatively, Sandra could obtain keys from T by taking 1 byte, skipping 3,
    taking the next byte, skipping 2, taking 2 bytes, skipping 4, and so forth in
    some periodic sequence. The skips can be small, so 2 or 3 skips could be coded
    in one key byte. It is possible that if Emily obtained the random source T she
    could determine the sequence of small skips. To prevent this, skipping could be
    combined with adding a sequence of numbers to the selected bytes modulo 256, also
    periodically. It is safest if the number of skips and the number of additives
    are coprime, say 12 skips and 11 additives. Using this method, each message key
    would use 2 bytes for the starting point, 6 bytes to encode the 12 skips, plus
    the 11 additives, for a total of 20 bytes, or 160 bits. This method could be called
    *Skip & Add*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，桑德拉可以通过按1字节、跳过3字节、取下一个字节、跳过2字节、取2字节、跳过4字节等一些周期序列中的步骤，从T获得密钥。跳过可以很小，因此2或3个跳过可以编码在一个密钥字节中。可能如果艾米莉获得了随机源T，她可以确定小跳过的序列。为防止这种情况，跳过可以与在选定字节上添加一系列数字相结合，对256取模，同样周期性。如果跳过的数量和添加的数量是互质的，比如12个跳过和11个添加，那么是最安全的。使用这种方法，每个消息密钥将使用2字节作为起点，6字节来编码12个跳过，再加上11个添加，总共20字节，或者160位。这种方法可以称为*跳跃与添加*。
- en: It is essential in this type of system that it is infeasible for Emily to reconstruct
    T. For example, Emily might, over time, acquire the plaintexts for numerous messages
    and recover their keys. If she also knows the placement of these keys within T,
    perhaps because Sandra transmits the location to Riva with each message, then
    she may be able to reconstruct portions of T. For this reason, T itself should
    never be used for keys. T should be retained to construct T[1], T[2], ... which
    then may be carved up into message keys. Retaining T protects Sandra and Riva
    in case any of the T[i] are lost or garbled. T could be called the *base* key
    and T[1], T[2], ... the *derived* keys.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的系统中，Emily无法重建T是至关重要的。例如，Emily可能随着时间的推移获得了许多消息的明文并恢复了它们的密钥。如果她还知道这些密钥在T中的位置，也许是因为桑德拉在每条消息中将位置传输给了Riva，那么她可能能够重建T的部分。因此，T本身不应该用于密钥。应该保留T以构建T[1]、T[2]，...，然后可以将其划分为消息密钥。保留T可以保护桑德拉和Riva，以防T[i]中的任何一个丢失或损坏。T可以称为*基础*密钥，T[1]、T[2]，...可以称为*派生*密钥。
- en: Even if Emily could somehow reconstruct T[1] or T[2], she cannot go backward
    to recover T, because T is true random. If Emily tried all possible combinations
    of coefficients and lags, there is nothing that would indicate which among those
    quintillions of strings is the correct random string, T.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Emily 可以以某种方式重建 T[1] 或 T[2]，她也无法倒退恢复 T，因为 T 是真正的随机。如果 Emily 尝试所有可能的系数和滞后组合，没有任何东西能表明哪个是正确的随机字符串
    T，因为有数以万计的字符串。
- en: 13.16 Synchronized key streams
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.16 同步密钥流
- en: In Secret Key cryptography Sandra and Riva must use the same key. Usually that
    means either (1) the key is enciphered and transmitted with the message, or (2)
    they have a list of keys, and choose each key from the list based on the date,
    time of day, or some other external factor. There is a third method that is unique
    to stream ciphers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在秘钥密码学中，Sandra 和 Riva 必须使用相同的密钥。通常这意味着要么（1）密钥被加密并与消息一起传输，要么（2）他们有一个密钥列表，并根据日期、时间或其他外部因素从列表中选择每个密钥。还有一种方法是流密码独有的。
- en: Sandra and Riva could use synchronized key streams. This means that Sandra and
    Riva both continuously generate the same key streams. When Sandra enciphers a
    message, she begins with the next key byte in her key stream, which must also
    be the next key byte in Riva’s key stream. When Riva receives the message, she
    must begin from the same point in the key stream. Sandra and Riva must begin generating
    from the same initial seed at precisely the same time. The synchronized method
    is most useful when there is a direct cable from Sandra to Riva, or a line-of-sight
    tower-to-tower connection, or when both receive over-the-air broadcasts from the
    same transmitter. It is well-suited for transmitting digitized speech in close
    quarters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Sandra 和 Riva 可以使用同步密钥流。这意味着 Sandra 和 Riva 都持续生成相同的密钥流。当 Sandra 加密一条消息时，她从她的密钥流中的下一个密钥字节开始，这也必须是
    Riva 的密钥流中的下一个密钥字节。当 Riva 收到消息时，她必须从密钥流中的相同点开始。Sandra 和 Riva 必须在完全相同的时间从相同的初始种子开始生成。当
    Sandra 和 Riva 之间有直接电缆连接，或者有视线塔到塔的连接，或者两者都从同一发射机接收过空中广播时，同步方法最为有用。它非常适合在狭小空间内传输数字化语音。
- en: If the messages are being sent over a network that has significant delays at
    the nodes or relay points, particularly packet-switched networks where portions
    of a message may arrive by different paths and must be reassembled at the receiving
    end, it is necessary for the sender to provide a time stamp for the start of transmission,
    say in a message header.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息是通过具有节点或中继点有显著延迟的网络发送的，特别是分组交换网络，其中消息的部分可能通过不同路径到达并必须在接收端重新组装，发送方必须在传输开始时提供时间戳，比如在消息头中。
- en: Since it takes time for Sandra to encipher the message and time for the message
    to travel from Sandra to Riva, it might seem that Riva would have to generate
    the random keys a few microseconds later than Sandra. By the same token, when
    Riva sends a message to Sandra, Sandra would have to generate the keys a few microseconds
    later than Riva.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Sandra 加密消息需要时间，消息从 Sandra 到 Riva 的传输也需要时间，似乎 Riva 必须比 Sandra 慢几微秒生成随机密钥。同样，当
    Riva 发送消息给 Sandra 时，Sandra 也必须比 Riva 慢几微秒生成密钥。
- en: There are several ways out of this impasse. One method would be for Sandra to
    begin messages only at specific cycles in the pseudorandom stream. For example,
    Sandra might begin a message only at every 100,000th cycle. Then when Riva receives
    a message at, say, cycle 123,456,789,123, she knows that the key started at cycle
    123,456,700,000\. If the message were received closer to an even multiple of 100,000,
    say cycle 123,456,701,234, Riva could try 123,456,700,000 and 123,456,600,000\.
    Riva would need to store the last two sets of 100,000 pseudorandom numbers. The
    figure 100,000 cycles can be adjusted up or down according to the speed of the
    PRNG and the transmission time between the two parties.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以摆脱这一僵局。一种方法是让 Sandra 只在伪随机流中的特定周期开始消息。例如，Sandra 可能只在每 100,000 个周期开始一条消息。然后当
    Riva 在第 123,456,789,123 个周期收到一条消息时，她知道密钥从第 123,456,700,000 个周期开始。如果消息接收时间更接近 100,000
    的整数倍，比如第 123,456,701,234 个周期，Riva 可以尝试 123,456,700,000 和 123,456,600,000。Riva
    需要存储最后两组 100,000 个伪随机数。100,000 个周期的数字可以根据 PRNG 的速度和两方之间的传输时间调整。
- en: There is one issue left to tackle, namely how Riva can detect the start and
    end of each enciphered message. If the communications channel has an idle state
    where neither zeros nor ones are being transmitted, then there is no problem.
    Let the channel idle between messages. Otherwise, let’s assume that the channel
    emits a steady stream of zeros whenever it is idle. In this case, you add an extra
    1 bit before and after the message, like enclosing the message in quotation marks,
    and you require that a minimum of 64 zeros must be transmitted before the next
    message can begin. The odds of 64 zeros happening by chance within a legitimate
    message are negligible. (Also, note that the average time between messages will
    actually be more than 50,000 cycles; 64 cycles is just the worst case.) So, when
    Riva detects a 1 bit after at least 64 zeros, she can be confident that is the
    start of the next message, and when she finds a 1 followed by 64 or more zeros,
    that marks the end of the message.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题需要解决，即 Riva 如何检测到每个加密消息的起始和结束。如果通信通道有一个空闲状态，在该状态下既不传输零也不传输一，则没有问题。让通道在消息之间保持空闲。否则，让我们假设通道在空闲时发出一串稳定的零。在这种情况下，您需要在消息前后添加额外的
    1 位，就像用引号括起消息一样，并要求在下一条消息开始之前必须传输至少 64 个零。在合法消息中发生 64 个零的几率微乎其微。 （此外，请注意，消息之间的平均时间实际上将超过
    50,000 个周期；64 个周期只是最坏情况。）因此，当 Riva 检测到至少 64 个零后的 1 位时，她可以确信这是下一条消息的开始，当她发现 1 位后跟着
    64 个或更多的零时，那标志着消息的结束。
- en: 13.17 Hash functions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.17 哈希函数
- en: Hash functions are not ciphers, but they are closely related to ciphers and
    often used together with cryptography. In this section I will discuss two uses
    for hash functions, and present one hash function suited for each use.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数不是密码，但与密码密切相关，通常与密码学一起使用。在本节中，我将讨论哈希函数的两个用途，并为每个用途提供一个适用的哈希函数。
- en: Hash functions are often used for searching. Suppose you have a list of people
    such as customers, patients or students, and you need to search this list frequently
    for information about those people. Hashing provides a quick way of searching
    by converting the person’s name into a number that can be found directly in a
    table. For example, the name “John Smith” could get turned into the number 2307,
    where entry 2307 in the table contains the information about John Smith.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数经常用于搜索。假设您有一个人员列表，如客户、患者或学生，并且您经常需要搜索此列表以获取有关这些人的信息。哈希提供了一种快速搜索的方式，即通过将人的姓名转换为可以直接在表中找到的数字。例如，名称“John
    Smith”可以转换为数字 2307，其中表中的条目 2307 包含有关 John Smith 的信息。
- en: Here is a hash designed for this purpose. For each letter L of the alphabet,
    randomly choose a binary value R(L) of some fixed size, say 32 bits. To hash the
    name, simply exclusive-OR the 32-bit numbers for each letter in the name. A weakness
    of this hash is that names that are anagrams will have the same hash value. For
    example, ARNOLD, ROLAND and RONALD all hash to the same value. To avoid this problem,
    after adding each letter, cycle the hash value left 1 bit position. That is,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个专为此目的设计的哈希。对于字母表中的每个字母 L，随机选择某个固定大小（例如 32 位）的二进制值 R(L)。要对名称进行哈希，只需对名称中每个字母的
    32 位数字执行异或操作。该哈希的一个弱点是具有相同字母的名称将具有相同的哈希值。例如，ARNOLD、ROLAND 和 RONALD 的哈希值都相同。为了避免这个问题，在添加每个字母后，将哈希值向左循环移动
    1 位位置。也就是说，
- en: '![13-unnumb-2-equation-13-14](../Images/13-unnumb-2-equation-13-14.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-2-equation-13-14](../Images/13-unnumb-2-equation-13-14.png)'
- en: Call the final hash value H. H can be converted to an index I into a name table
    of size T by scaling it, I = ⌊HT/2^(32)⌋. For example, if the name hashes to 917354668
    and the table has 5000 entries, the index is ⌊917354668×5000/4294967296⌋ = ⌊1067.94⌋
    = 1067\. Let’s call this hashing method *Hash32*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将最终的哈希值称为 H。H 可以通过缩放转换为大小为 T 的名称表的索引 I，公式为 I = ⌊HT/2^(32)⌋。例如，如果名称的哈希值为 917354668，表中有
    5000 个条目，则索引为 ⌊917354668×5000/4294967296⌋ = ⌊1067.94⌋ = 1067。我们称这种哈希方法为 *Hash32*。
- en: There can be several names that produce the same index. Various methods are
    used for handling these index crashes, such as having a separate table to hold
    the duplicates, hashing the name a second time to choose a different slot in the
    table, or chaining the duplicate names together.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有几个名称产生相同的索引。有各种方法用于处理这些索引冲突，例如使用一个单独的表来保存重复项，第二次对名称进行哈希以在表中选择不同的插槽，或将重复名称链接在一起。
- en: Hash functions are also used for message authentication. In this case the entire
    message is hashed to produce a long hash value. Let’s suppose 16 bytes. This hash
    value must be sent to Riva in a tamper-proof way, such as sending it via a trusted
    third party that records and timestamps the hash value. Riva will then hash the
    message and compare the hash values. If they are different, then the message may
    have been altered. The hash function used for this purpose must make it infeasible
    for Emily to modify the message without changing the hash value. That is, Emily
    cannot find a different message that produces the same hash value. Likewise, Sandra
    cannot change the message and claim that she had sent the changed message, because
    the hash value will no longer match.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数也用于消息认证。在这种情况下，整个消息被哈希为一个长的哈希值。假设是16个字节。这个哈希值必须以防篡改的方式发送给Riva，例如通过一个可信赖的第三方，该第三方记录并加上时间戳的哈希值。然后Riva将对消息进行哈希处理并比较哈希值。如果它们不同，那么消息可能已被更改。用于此目的的哈希函数必须使得Emily无法修改消息而不改变哈希值成为不可行。也就是说，Emily无法找到一个产生相同哈希值的不同消息。同样，Sandra无法更改消息并声称她发送了更改后的消息，因为哈希值将不再匹配。
- en: For this hash we will use 4 highly non-linear substitutions, A, B, C and D.
    These may be publicly known fixed substitutions. It is worthwhile putting some
    effort into making the four substitutions highly non-linear and minimally correlated
    with one another. The basic operation is to combine each byte of the message with
    4 previous bytes using the **xors** combining function, that is, to perform an
    exclusive-OR and then to make a simple substitution on the result. Let H be a
    copy of the message M, so that the message is not destroyed by the hashing process.
    Each character H[n] in the copy is hashed by
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个哈希函数，我们将使用4个高度非线性的替换，分别为A、B、C和D。这些可能是公开已知的固定替换。值得花一些精力使这四个替换高度非线性且彼此之间的相关性最小化。基本操作是使用**异或**的组合函数将消息的每个字节与前4个字节进行组合，即执行异或操作，然后对结果进行简单的替换。让H是消息M的一个副本，以便消息在哈希处理过程中不被破坏。副本中的每个字符H[n]都经过以下哈希处理：
- en: '![13-unnumb-2-equation-13-15](../Images/13-unnumb-2-equation-13-15.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-2-equation-13-15](../Images/13-unnumb-2-equation-13-15.png)'
- en: This way, every byte of the hash depends on every byte that came before, and
    every byte that comes after depends on it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，哈希的每个字节都依赖于前面的每个字节，并且每个后续的字节都依赖于它。
- en: The hash requires an initialization vector (section 11.10) in order to hash
    the first 16 bytes of the message. A copy of the first 16 bytes of the message
    can be used for this purpose. That is, initially bytes H[-15] through H[0] are
    the same as bytes H[1] through H[16], which are the same as bytes M[1] through
    M[16] of the message. With the initialization vector it is possible to propagate
    the hash from H[1] to H[L], where L is the length of the message.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希需要一个初始化向量（第11.10节）以便对消息的前16个字节进行哈希处理。可以使用消息的前16个字节的副本。也就是说，最初字节H[-15]到H[0]与字节H[1]到H[16]相同，这些字节是消息的字节M[1]到M[16]相同。有了初始化向量，就可以将哈希从H[1]传播到H[L]，其中L是消息的长度。
- en: This leaves the last few bytes rather weakly hashed. It may be possible for
    Emily to change the last few bytes of the message without much effort. The solution
    is to continue the hashing process beyond the end of the message. To do this,
    when we hash the first 16 bytes of the message, we save these hash values for
    later use. When we reach the end of the message, we append those 16 bytes and
    continue the hashing until the end of the extended message. Those last 16 bytes
    become the hash value for the message. Call this hash method *Hash128*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得最后几个字节的哈希相对较弱。Emily可能很容易改变消息的最后几个字节。解决方法是在消息结束后继续哈希处理。为此，当我们对消息的前16个字节进行哈希处理时，我们保存这些哈希值以供以后使用。当我们到达消息的末尾时，我们附加这16个字节并继续哈希直到扩展消息的末尾。这最后的16个字节成为消息的哈希值。将此哈希方法称为*Hash128*。
- en: For some machines it may be faster to hash a message 4 bytes at a time using
    the machine’s 32-bit arithmetic functions. The message and hash values are treated
    as lists of L 32-bit words rather than 4L bytes. The hash array H is initially
    a copy of the message. If the message length is not an even multiple of 4 bytes,
    up to 3 bytes are appended to fill out the last word. Copies of the first two
    words of H are appended to the front, namely H[-1] = H[1] and H[0] = H[2]. After
    the first 4 words of the message have been hashed, these 4 words are appended
    to the end of the message.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些机器，使用机器的 32 位算术函数，每次对消息进行 4 字节的哈希可能更快。消息和哈希值被视为 L 个 32 位字的列表，而不是 4L 字节。哈希数组
    H 最初是消息的一个副本。如果消息长度不是 4 字节的偶数倍，则会附加多达 3 个字节以填充最后一个字。H 的前两个字的副本被附加到前面，即 H[-1] =
    H[1] 和 H[0] = H[2]。在对消息的前 4 个字进行哈希后，这 4 个字将附加到消息的末尾。
- en: This hash, called *HashPQ*, uses two primes which are P = 2^(32)-5 = 4294967291
    and Q = 2^(32)-17 = 4294967279, and the magic multiplier R = 77788888, which is
    a primitive root of both P and Q. The hashing operation is
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种哈希，称为 *HashPQ*，使用两个素数 P = 2^(32)-5 = 4294967291 和 Q = 2^(32)-17 = 4294967279，以及魔法乘数
    R = 77788888，它是 P 和 Q 的一个原根。哈希操作为
- en: '![13-unnumb-2-equation-13-16](../Images/13-unnumb-2-equation-13-16.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![13-unnumb-2-equation-13-16](../Images/13-unnumb-2-equation-13-16.png)'
- en: If the sum exceeds 2^(32)-1, the value is truncated to 32 bits simply by ignoring
    the extra high-order bit(s). That is, we get the modulo 2^(32) operation free.
    The last 4 words of the H array are the 16-byte hash value. HashPQ uses less storage
    than Hash128 since it does not need the 4 simple substitutions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总和超过 2^(32)-1，则通过简单地忽略额外的高位比特来将值截断为 32 位。也就是说，我们可以自由得到模 2^(32) 运算。H 数组的最后
    4 个字是 16 字节哈希值。与 Hash128 相比，HashPQ 使用的存储空间更少，因为它不需要 4 个简单的替换。
- en: Hash32, Hash128 and HashPQ all have the ideal property required for a good hash
    function, namely that a change to any bit or combination of bits in the input
    causes about half of the bits in the output to change. All three hashes are fast,
    and can be done in a single left-to-right pass.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Hash32、Hash128 和 HashPQ 都具有良好哈希函数所需的理想属性，即对输入的任何位或位的组合进行更改会导致输出中大约一半的位发生更改。这三种哈希都很快，并且可以在单个从左到右的传递中完成。
